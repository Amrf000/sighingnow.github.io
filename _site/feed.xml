<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sighingnow</title>
    <description>Sighingnow&#39;s homepage using Jekyll Metro</description>
    <link>http://sighingnow.github.io/</link>
    <atom:link href="http://sighingnow.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 01 Jan 2016 01:05:40 +0800</pubDate>
    <lastBuildDate>Fri, 01 Jan 2016 01:05:40 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Tak函数和Tarai函数的性能</title>
        <description>&lt;p&gt;Tak函数和Tarai函数是两个非常类似，但本质上差异显著的函数，具体的定义参考[Wikipedia 的页面][1]。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tak 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is defined as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math&quot;&gt;\[
\tau (x,y,z) = {
    \begin{cases}
        \tau (\tau (x-1,y,z), \tau (y-1,z,x), \tau (z-1,x,y))
            &amp;amp; {\text{if }}y &amp;lt; x \\
        z
            &amp;amp; {\text{otherwise}}
    \end{cases}}
\]&lt;/span&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;!--links--&gt;
&lt;p&gt;[1]. https://en.wikipedia.org/wiki/Tak_(function)&lt;/p&gt;
</description>
        <pubDate>Thu, 31 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/tak_tarai_performance.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/tak_tarai_performance.html</guid>
        
        <category>Haskell</category>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>Combinator &quot;seq&quot;</title>
        <description>&lt;p&gt;Haskell 是一门拥有惰性赋值特性的函数式编程语言，Normal Form是表达惰性求值的重要概念， &lt;code&gt;seq&lt;/code&gt; 和 &lt;code&gt;deepseq&lt;/code&gt; 用于将表达式求值到不同等级的 Normal Form。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&quot;normal-form&quot;&gt;Normal Form&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Normal Form&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NF是指已经被完全求值，不能再规约的表达式。对于一个求值能结束的表达式，non-strict语义可以 保证一个表达式中存在多个可规约项时，不同求值顺序最终将其规约到同样的Normal Form。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Weak Head Normal Form&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WHNF指将表达式求值到最外层构造器或者函数抽象或者一个部分调用的内建函数。惰性求值(Lazy Evaluation)就是将一个表达式求值到WHNF。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Head Normal Form&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 Head Normal Form的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A term describing a lambda expression whose top level is either a variable, a data value, a built-in function applied to too few arguments, or a lambda abstraction whose body is not reducible. I.e. the top level is neither a redex nor a lambda abstraction with a reducible body.&lt;/p&gt;
&lt;p&gt;An expression in HNF may contain redexes in argument postions whereas a normal form may not.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体来说，相当于HNF的函数体不可规约，但参数中可以可规约项。&lt;/p&gt;
&lt;p&gt;这三者之间的关系，可以表述为HNF是WNHF的真子集，NF是HFN的真子集。&lt;/p&gt;
&lt;h2 id=&quot;seq&quot;&gt;seq&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;seq&lt;/code&gt; 函数用于 strict evaluation：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The seq function is the most basic method of introducing strictness to a Haskell program. &lt;code&gt;seq :: a -&amp;gt; b -&amp;gt; b&lt;/code&gt; takes two arguments of any type, and returns the second. However, it also has the important property that it is magically strict in its first argument.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;seq&lt;/code&gt; 的原理并不是直接对第一个参数求值，而是&lt;strong&gt;引入数据依赖&lt;/strong&gt;，当 &lt;code&gt;seq&lt;/code&gt; 函数的结果，也 就是第二个参数被严格求值时，保证第一个参数一定会被求值。因此也就不难理解，&lt;code&gt;seq x x&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 是等价的。&lt;code&gt;seq&lt;/code&gt; 与 &lt;code&gt;strictness annotations&lt;/code&gt; 和 &lt;code&gt;BangPatterns&lt;/code&gt; 一样，都 用在程序的语义解释阶段，用于表达严格求值。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;f &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;x &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; z&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的语义等价于&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;f x y
    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;`seq`&lt;/span&gt; y &lt;span class=&quot;ot&quot;&gt;`seq`&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; undefined
    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise             &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; z&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GHC 的惰性求值通过 &lt;code&gt;thunks&lt;/code&gt; 来实现，&lt;code&gt;seq&lt;/code&gt; 可以被用于累积参数以确保不会形成过大的 &lt;code&gt;thunks&lt;/code&gt; 导致程序运行时内存压力过大。例如，&lt;code&gt;fold&lt;/code&gt;函数就可以通过严格求值来提高效率。&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foldl&amp;#39; ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [b] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
foldl&amp;#39; _ z [] &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; z
foldl&amp;#39; f z (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; z&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f z x &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; z&amp;#39; &lt;span class=&quot;ot&quot;&gt;`seq`&lt;/span&gt; foldl&amp;#39; f z&amp;#39; xs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子中，&lt;code&gt;seq&lt;/code&gt; 函数保证了每次 &lt;code&gt;z&#39;&lt;/code&gt; 都会被严格求值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt; 运算符表示将函数应用到参数上，求值。&lt;code&gt;$!&lt;/code&gt; 是 Call-by-value 的函数应用运算符，使用 &lt;code&gt;$!&lt;/code&gt; 时，参数会先被求值到 WHNF(Weak head normal form，弱首范式)，然后再调用函数。 可以使用 &lt;code&gt;seq&lt;/code&gt; 函数来定义 &lt;code&gt;$!&lt;/code&gt; 运算符（实际实现是使用 strictness annotations，与 &lt;code&gt;seq&lt;/code&gt;在语义上等价）：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;($!) ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b
f &lt;span class=&quot;fu&quot;&gt;$!&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;`seq`&lt;/span&gt; f x

&lt;span class=&quot;co&quot;&gt;-- f $! x = let !vx = x in f vx&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;seq&lt;/code&gt; is the only way to force evaluation of a value with a function type (except by applying it, which is liable to cause other problems).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于函数来说，&lt;code&gt;seq&lt;/code&gt;会将函数求值到lambda表达式的形式，也就是&lt;code&gt;ready for application&lt;/code&gt;的 形式。例子：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- ok, lambda is outermost&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; seq (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; undefined) &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- not ok.  Because of the inner seq, `undefined` must be evaluated before&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- the lambda is showing&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; seq (seq undefined (\x &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; x)) &lt;span class=&quot;ch&quot;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; Prelude.undefined&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GHC中，&lt;code&gt;case...of&lt;/code&gt;对于参数也是严格求值，因此可以认为：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;seq a b &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                _ &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;deepseq-和-nfdata&quot;&gt;deepseq 和 NFData&lt;/h2&gt;
&lt;p&gt;deepseq 将表达式求值到NF。函数类型声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deepseq :: NFData a =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;deepseq&lt;/code&gt; 和 &lt;code&gt;seq&lt;/code&gt; 的区别在于&lt;code&gt;deepseq&lt;/code&gt;会将参数彻底严格求值，而不仅仅是&lt;code&gt;seq&lt;/code&gt;那样只 在顶层求值。&lt;code&gt;deepseq&lt;/code&gt;可以被用于强制抛出异常、减少内存消耗和严格求值IO操作等，以及用于 连接并行计算策略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deepseq&lt;/code&gt;对参数的求值是并行求值，&lt;strong&gt;不保证参数各部分的求值顺序&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;code&gt;Control.Parallel&lt;/code&gt; in the parallel package.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时，&lt;code&gt;deepseq&lt;/code&gt;包中还包含了两个常用的函数：&lt;code&gt;$!!&lt;/code&gt;和&lt;code&gt;force&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$!!&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;$!!&lt;/code&gt;跟&lt;code&gt;$&lt;/code&gt;和&lt;code&gt;$!&lt;/code&gt;类似，区别在于&lt;code&gt;$!!&lt;/code&gt;首先将参数求值到NF而不是WHNF。&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;($!!) ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;NFData&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b
f &lt;span class=&quot;fu&quot;&gt;$!!&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;`deepseq`&lt;/span&gt; f x&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;force&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;force&lt;/code&gt;函数对参数进行严格求值，并返回结果：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;force ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;NFData&lt;/span&gt; a) &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
force x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;`deepseq`&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;deepseq&lt;/code&gt;包中定义了数据类型&lt;code&gt;NFData&lt;/code&gt;用于表达可以被彻底地严格求值的数据类型。数据类型 Int, Float, Bool 以及 List 等都是&lt;code&gt;NFData&lt;/code&gt;类型类的实例类型。&lt;code&gt;deepseq&lt;/code&gt;包中的函数&lt;code&gt;rnf&lt;/code&gt; 可以对一个&lt;code&gt;NFData&lt;/code&gt;的实例类型的表达式进行严格求值，将其规约到NF(rnf: reduce to normal form)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rnf :: (NFData a) -&amp;gt; a -&amp;gt; ()&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;rnf&lt;/code&gt; should reduce its argument to normal form (that is, fully evaluate all sub-components), and then return &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;seq-is-bad-and-why&quot;&gt;&lt;code&gt;seq&lt;/code&gt; is bad, and why?&lt;/h2&gt;
&lt;p&gt;Polymorphic &lt;code&gt;seq&lt;/code&gt; 可能会破坏一些变换的等价性。例如在Haskell中，以下等式成立：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map g (f xs) = f (map g xs)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;f&lt;/code&gt;、&lt;code&gt;g&lt;/code&gt; 和 &lt;code&gt;xs&lt;/code&gt; 的类型声明分别为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f :: [a] -&amp;gt; [b]
g :: a -&amp;gt; b
xs :: [a]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为&lt;code&gt;f&lt;/code&gt;、&lt;code&gt;g&lt;/code&gt;和分别取值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f (x:y:_) = [seq x y]
g True = True&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;xs&lt;/code&gt;的值为&lt;code&gt;xs = [False, True]&lt;/code&gt;，那么：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map g (f xs) = map g (f [False, True]) = map g [True] = True
f (map g [False, True]) = f [undefined, True] = [undefined]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等式两边的值不一样，破坏了等式的性质。之所以会出现这个问题，愿意就在于&lt;code&gt;seq&lt;/code&gt;会将List &lt;code&gt;xs&lt;/code&gt; 中不同位置的两个值建立起依赖。更深层次的探讨，这一问题与Free Theorem有关， &lt;em&gt;[Free Theorems in the Presence of seq][3]&lt;/em&gt; 以及 Philip Wadler 的论文 &lt;em&gt;[Theorems for free!][1]&lt;/em&gt; 就在讨论这一问题，此外，&lt;em&gt;[Improvements for Free][2]&lt;/em&gt; 一文看上去也很有 意思。&lt;/p&gt;
&lt;p&gt;Polymorphic &lt;code&gt;seq&lt;/code&gt; 在特定情况下会产生一些问题，但是其他的可选方案同样不是非常理想。如果 为&lt;code&gt;seq&lt;/code&gt;添加一个类型类作为依赖，在使用&lt;code&gt;seq&lt;/code&gt;时可能就需要很多的类型约束。同时，已经明确很多 内存占用过大的问题可以通过&lt;code&gt;seq&lt;/code&gt;来解决，因此，&lt;code&gt;seq&lt;/code&gt;也不可能被去除。&lt;/p&gt;
&lt;p&gt;StackOverflow上另一个问题 [A simple example showing that IO doesn’t satisfy the monad laws?][6] 也很有意思，答案是使用 &lt;code&gt;seq&lt;/code&gt; !!! 事实上，将&lt;code&gt;seq&lt;/code&gt;和&lt;code&gt;undefined&lt;/code&gt;组合 会破坏Monad Laws，因此，所有的 Monad 都会失效。&lt;/p&gt;
&lt;p&gt;对于一个Monad，有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(Monad m) =&amp;gt; m &amp;gt;&amp;gt;= return  = m&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; seq ( undefined &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; return ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; () ) &lt;span class=&quot;st&quot;&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; seq (&lt;span class=&quot;ot&quot;&gt; undefined ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; () ) &lt;span class=&quot;st&quot;&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; Prelude.undefined&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个例子中：&lt;code&gt;undefined &amp;gt;&amp;gt;= return&lt;/code&gt; 与 &lt;code&gt;undefined&lt;/code&gt; 的值不相等。使用 &lt;code&gt;unsafePerformIO&lt;/code&gt;也会产生类似的效果。&lt;/p&gt;
&lt;p&gt;另一个使得 &lt;code&gt;Maybe&lt;/code&gt; 不满足 Monad Laws 的例子：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; seq ( undefined &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; return ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; () ) &lt;span class=&quot;st&quot;&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; Prelude.undefined

&lt;span class=&quot;dt&quot;&gt;Prelude&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; seq (&lt;span class=&quot;ot&quot;&gt; undefined ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; () ) &lt;span class=&quot;st&quot;&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; Prelude.undefined  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引用一段证明如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the Kleisli category the monad gives rise to, return is the identity morphism and &lt;code&gt;(&amp;lt;=&amp;lt;)&lt;/code&gt; is composition. So return must be an identity for &lt;code&gt;(&amp;lt;=&amp;lt;)&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;return &amp;lt;=&amp;lt; x = x&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Using &lt;code&gt;seq&lt;/code&gt; even &lt;code&gt;Identity&lt;/code&gt; and &lt;code&gt;Maybe&lt;/code&gt; fail to be monads:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;seq (return &amp;lt;=&amp;lt; undefined :: a -&amp;gt; Identity b) () = () seq (undefined :: a -&amp;gt; Identity b) () = undefined&lt;/p&gt;
&lt;p&gt;seq (return &amp;lt;=&amp;lt; undefined :: a -&amp;gt; Maybe b) () = () seq (undefined :: a -&amp;gt; Maybe b) () = undefined&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;最后一部分内容关于 &lt;code&gt;seq&lt;/code&gt; is bad 的内容参考了 Jan Christiansen 在 StackOverflow 上的问题 [Why is seq bad?][4] 下的 [回答][5]。&lt;/p&gt;
&lt;!--links--&gt;
&lt;p&gt;[1]. http://dl.acm.org/citation.cfm?id=99404 [2]. http://arxiv.org/pdf/1107.1203.pdf [3]. http://www.janis-voigtlaender.eu/papers/FreeTheoremsInThePresenceOfSeq.pdf [4]. http://stackoverflow.com/questions/12687392/why-is-seq-bad [5]. http://stackoverflow.com/a/12688908 [6]. http://stackoverflow.com/questions/12617664/a-simple-example-showing-that-io-doesnt-satisfy-the-monad-laws/12620418#12620418&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/seq_and_its_trouble.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/seq_and_its_trouble.html</guid>
        
        <category>Haskell</category>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>Haskell List Append Performance</title>
        <description>&lt;p&gt;阅读 Graham Hutton 的书 &lt;em&gt;Programming in Haskell&lt;/em&gt; 的 Chapter 13 Reasoning about programs 时，书中分析 &lt;code&gt;reverse&lt;/code&gt; 函数的时间复杂度时提到Haskell中列表拼接运算符&lt;code&gt;(++)&lt;/code&gt;的时间复杂度是&lt;span class=&quot;math&quot;&gt;\(O(n)\)&lt;/span&gt;的！&lt;/p&gt;
&lt;h2 id=&quot;implement-reverse&quot;&gt;Implement &lt;code&gt;reverse&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt;函数用于将一个List倒转方向，不难写出一个简单的实现：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- | reverse a list.&lt;/span&gt;
reverse&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]
reverse [] &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []
reverse (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; reverse xs &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; [x]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析这一实现的时间复杂度：&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;(++)&lt;/code&gt;的时间复杂度与第一个参数List的长度正相关，一共需要 n 次拼接操作，以此，最终的结果为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt; takes quadratic time in the length of its argument.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们不难看出，&lt;code&gt;(++)&lt;/code&gt;函数的复杂度是瓶颈所在，Hutton 的书中给出了另一个实现：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- | reverse a list in linear time.&lt;/span&gt;
reverse&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]
reverse xs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; auxiliary xs [] &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    auxiliary [] ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
    auxiliary (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; auxiliary xs (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个实现中，辅助函数&lt;code&gt;auxiliary&lt;/code&gt;的作用是将已经reverse的结果保存到一个List中，每次采用&lt;code&gt;(:)&lt;/code&gt;操作来更新结果，这样，每一步&lt;code&gt;reverse&lt;/code&gt;的时间复杂度都是&lt;span class=&quot;math&quot;&gt;\(O(1)\)&lt;/span&gt;的，因此，整个列表的reverse可以在&lt;span class=&quot;math&quot;&gt;\(O(n)\)&lt;/span&gt;的时间内完成，也即&lt;code&gt;reverse&lt;/code&gt;函数具有线性时间复杂度。&lt;/p&gt;
&lt;p&gt;Haskell的&lt;code&gt;reverse&lt;/code&gt;函数定义在base库中，具体实现：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- | &amp;#39;reverse&amp;#39; @xs@ returns the elements of @xs@ in reverse order.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- @xs@ must be finite.&lt;/span&gt;
reverse&lt;span class=&quot;ot&quot;&gt;                 ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]
&lt;span class=&quot;st&quot;&gt;#ifdef USE_REPORT_PRELUDE&lt;/span&gt;
reverse                 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;  foldl (flip (&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;)) []
&lt;span class=&quot;st&quot;&gt;#else&lt;/span&gt;
reverse l &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;  rev l []
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    rev []     a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; a
    rev (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; rev xs (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;a)
&lt;span class=&quot;st&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个实现也采取了使用&lt;code&gt;(:)&lt;/code&gt;而不是&lt;code&gt;(++)&lt;/code&gt;的思路，以保证函数的效率。&lt;/p&gt;
&lt;p&gt;关于几个&lt;code&gt;reverse&lt;/code&gt;的实现的简单的benchmark：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;{-# LANGUAGE BangPatterns #-}&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;{-# OPTIONS -O2 #-}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Data.Time.Clock&lt;/span&gt;

reverse1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; reverse

reverse2 [] &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []
reverse2 (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; reverse2 xs &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; [x]

reverse3 xs &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; auxiliary xs [] &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    auxiliary [] ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
    auxiliary (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; auxiliary xs (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ys)


main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;ns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;]
    start &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
    print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; sum &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; reverse1 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;ns
    end &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
    putStrLn &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;reverse from standard library took &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show (diffUTCTime end start)
    start &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
    print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; sum &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; reverse2 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;ns    
    end &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
    putStrLn &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;reverse of quadratic time took &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show (diffUTCTime end start)
    start &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
    print &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; sum &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; reverse3 &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;ns    
    end &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
    putStrLn &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;reverse of linear time took &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show (diffUTCTime end start)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;50005000
reverse from standard library took 0.0016954s
50005000
reverse of quadratic time took 1.5450966s
50005000
reverse of linear time took 0s&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;reverse&lt;/code&gt;的高效实现方法中所采取的缓存结果的思路对于算法设计和分析有着重要的启发意义。&lt;/p&gt;
&lt;h2 id=&quot;efficient-concatenation&quot;&gt;Efficient concatenation&lt;/h2&gt;
&lt;p&gt;基于命令式语言的列表拼接操作极其简单，并且具有常数级别的时间复杂度。但函数是编程语言中，数据是不可变的(pure data is immutable)，因此，也无法做到将后一个列表的head pointer直接指向上一个列表的tail这样的操作。Haskell中，每一次做拼接操作都需要创建一个新的List。看标准库中&lt;code&gt;(++)&lt;/code&gt;的实现：&lt;/p&gt;
&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;(++) ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a]
&lt;span class=&quot;ot&quot;&gt;{-# NOINLINE [1] (++) #-}&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;-- We want the RULE to fire first.&lt;/span&gt;
                             &lt;span class=&quot;co&quot;&gt;-- It&amp;#39;s recursive, so won&amp;#39;t inline anyway,&lt;/span&gt;
                             &lt;span class=&quot;co&quot;&gt;-- but saying so is more explicit&lt;/span&gt;
(&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;) []     ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ys
(&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;) (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) ys &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; xs &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; ys

&lt;span class=&quot;co&quot;&gt;{-# RULES&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;&amp;quot;++&amp;quot;    [~1] forall xs ys. xs ++ ys = augment (\c n -&amp;gt; foldr c n xs) ys&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;  #-}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相当于将第一个参数列表展开成单个元素，再一个一个地加到第二个List的开头。因此，&lt;code&gt;(++)&lt;/code&gt;函数的时间复杂度与第一个参数列表的长度成线性关系。&lt;/p&gt;
&lt;p&gt;但是，有没有更高效的实现？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Difference lists are implemented as single-argument functions, which take a list as argument and prepend to that list. As a consequence, concatenation of difference lists of the second type is implemented essentially as &lt;strong&gt;function composition&lt;/strong&gt;, which is &lt;span class=&quot;math&quot;&gt;\(O(1)\)&lt;/span&gt;. However, of course the list still has to be constructed eventually (assuming all of its elements are needed), which is plainly at least &lt;span class=&quot;math&quot;&gt;\(O(n)\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Difference List是一个很有意思的东西，他用函数来表达List，将List上的操作表达为对 function application，能够实现constant time的append/prepend操作。仅仅在最后队列表求值时的时间复杂度为&lt;span class=&quot;math&quot;&gt;\(O(n)\)&lt;/span&gt;。对于需要重复多次的列表拼接操作来说，这一数据结构在效率方面具有明显的优势。&lt;/p&gt;
&lt;p&gt;DList的核心在于将数据保存在函数中，用函数的组合来表示数据的组合，这是一个很自然而然地想法。DList的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- Lists as functions
newtype DList a = DL { unDL :: [a] -&amp;gt; [a] }

-- The empty list
empty       = DL id

-- The append case: composition, a la Hughes
append xs ys = DL (unDL xs . unDL ys)

-- Converting to a regular list, linear time.
toList      = ($[]) . unDL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一个高效地实现List的append/prepend的数据结构是 Figure Tree。Haskell的库containers中导出了Figure Tree的一个实现 &lt;code&gt;Data.Sequence&lt;/code&gt;，具有很好的执行效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Standard &lt;code&gt;Sequence&lt;/code&gt; has &lt;span class=&quot;math&quot;&gt;\(O(1)\)&lt;/span&gt; for addition from ‘both ends’ and &lt;span class=&quot;math&quot;&gt;\(O(log(min(n1,n2)))\)&lt;/span&gt; for general concatenation (The difference from lists though is that &lt;code&gt;Sequence&lt;/code&gt; is strict).&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 14 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/haskell_append_performance.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/haskell_append_performance.html</guid>
        
        <category>Haskell</category>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>自然数的除法与取模</title>
        <description>&lt;p&gt;Coq 对自然数的除法与取模的实现很有讲究！&lt;/p&gt;
&lt;h2 id=&quot;皮亚诺公理&quot;&gt;皮亚诺公理&lt;/h2&gt;
&lt;p&gt;自然数，natural number, 严格定义有皮亚诺公理给出。平亚诺序数理论提出自然数的五条公理，这五条公理的非形式化描述如下：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;0 是自然数；&lt;/li&gt;
&lt;li&gt;每一个确定的自然数 n 都有一个确定的后继，记作 n+1, n+1 也是自然数。&lt;/li&gt;
&lt;li&gt;如果 m，n 都是自然数，并且 m+1=n+1, 那么，m = n。&lt;/li&gt;
&lt;li&gt;0 不是任何自然数的后继。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一些自然数的集合 S 具有性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 在 S 中；&lt;/li&gt;
&lt;li&gt;若 n 在 S 中，那么 n+1 也在 S 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么 &lt;strong&gt;S = N&lt;/strong&gt;。(公理 5 保证了&lt;strong&gt;数学归纳法的正确性&lt;/strong&gt;，因此也被称作归纳法原理。)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;皮亚诺公理的形式化描述：&lt;/p&gt;
&lt;p&gt;(e in S) (forall a in S)(f(a) in S) (forall b in S)(forall c in S)(f(b) = f(c) -&amp;gt; b = c) (forall a in S)( f(a) /= e) (forall A in S)(((e in A) and (forall a in A)(f(a) in A)) -&amp;gt; (A = S) )&lt;/p&gt;
&lt;h2 id=&quot;自然数的运算&quot;&gt;自然数的运算&lt;/h2&gt;
</description>
        <pubDate>Fri, 06 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/coq/natural_number_div_mod.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/coq/natural_number_div_mod.html</guid>
        
        <category>Coq</category>
        
        <category>自然数</category>
        
        <category>Logic</category>
        
        
        <category>Coq</category>
        
      </item>
    
      <item>
        <title>Church Numerals</title>
        <description>&lt;p&gt;在一个可以时过程做各种操作的语言里，我们完全可以没有输(至少在只考虑非负整数的情况下) ，可以将 “0” 和 “加一” 操作实现为：&lt;/p&gt;
&lt;pre class=&quot;sourceCode scheme&quot;&gt;&lt;code class=&quot;sourceCode scheme&quot;&gt;&lt;span class=&quot;co&quot;&gt;;; Church numeral: 0&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt; zero&lt;/span&gt;
  (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (f)
    (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (x) x)))

&lt;span class=&quot;co&quot;&gt;;; Chruch numeral: +1&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt; &lt;/span&gt;(add&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt; n)
  (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (f)
    (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (x)
      (f ((n f) x)))))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这一表示形式称为Church计数，各宇来醺于其发明人数理逻辑学家Alonzo Church (丘奇) ，lambda 演算也是他发明的。 &lt;strong&gt;丘奇数(Church numeral)，并不是一个数字，而是指应用某个函数的次数。&lt;/strong&gt; (这两个参数可以组合起来，但是，formal lambda calculus只允许使用一个参数。)&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&quot;sicp-exercise-2.6&quot;&gt;SICP Exercise 2.6&lt;/h2&gt;
&lt;p&gt;SICP Exercise 2.6 的题目要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个丘奇数种包括两部分：&lt;code&gt;f&lt;/code&gt;和&lt;code&gt;x&lt;/code&gt;。&lt;code&gt;f&lt;/code&gt;指的是将会被应用(apply) n 次的函数，x 指的是函数&lt;code&gt;f&lt;/code&gt;的操作数。例如：Church numeral 的 4 的表示：&lt;/p&gt;
&lt;pre class=&quot;sourceCode scheme&quot;&gt;&lt;code class=&quot;sourceCode scheme&quot;&gt;&lt;span class=&quot;co&quot;&gt;;; 4&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (f)
  (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (x)
    (f (f (f (f x))))))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回到 SICP Exercise 2.6, 用这种形式来表达 1，2：&lt;/p&gt;
&lt;pre class=&quot;sourceCode scheme&quot;&gt;&lt;code class=&quot;sourceCode scheme&quot;&gt;&lt;span class=&quot;co&quot;&gt;;; 1&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt; one&lt;/span&gt;
  (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (f)
    (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (x)
      (f x))))

&lt;span class=&quot;co&quot;&gt;;; 2&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt; two&lt;/span&gt;
  (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (f)
    (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (x)
      (f (f x)))))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么就如何实现 Church Numerals 的 &lt;code&gt;add&lt;/code&gt; 运算呢？参考 &lt;code&gt;(+1)&lt;/code&gt;的实现，不难得到：&lt;/p&gt;
&lt;pre class=&quot;sourceCode scheme&quot;&gt;&lt;code class=&quot;sourceCode scheme&quot;&gt;&lt;span class=&quot;co&quot;&gt;;; `add`&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;;; Add a and b by applying a to the result of applying b.&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;define&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt; &lt;/span&gt;(add a b)
  (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (f)
    (&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; (x)
      ((a f) ((b f) x)))))&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 25 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/church_numerals.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/church_numerals.html</guid>
        
        <category>Haskell</category>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>Web Messaging 以及 jschannel.js 用于页面间跨域通信</title>
        <description>&lt;p&gt;Web Messaging (Cross-document Messaging) 技术是 HTML5 规范中定义的允许不同源站点的页面进行通信的应用程序接口。可以有效地解决在 同源策略的限制下不同站点的页面不能有数据交互的问题。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&quot;同源策略&quot;&gt;同源策略&lt;/h2&gt;
&lt;p&gt;同源策略(Same-origin Policy)，是Web应用程序安全模型中的重要概念，在同源策略的限制下，仅当两个文档页面(html)同源时，两个页面间也允许读取对方页面上的数据。同源(same orgin)的具体含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;same url scheme&lt;/li&gt;
&lt;li&gt;same hostname&lt;/li&gt;
&lt;li&gt;same port&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我们谈论如何使用JavaScript访问DOM时，我们便需要考虑同源策略的这三个要素：URL协议、主机名、端口号，当我们使用浏览器同时打开两个不同站点的页面时，在同源策略的保证下，一个页面无法直接读取另外一个页面中的数据。&lt;/p&gt;
&lt;p&gt;来自于同一个根域，但不同子域的页面之间也无法直接进行数据交互，例如，a.xxx.com 与 b.xxx.com 的页面之间就无法直接使用js来读取对 方dom节点中的数据。如果要允许这两个页面进行交互，需要先将这两个页面的 &lt;code&gt;document.domain&lt;/code&gt; 属性设置为根域(xxx.com)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.domain = &amp;#39;xxx.com&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这表示，在当前页面， &lt;code&gt;xxx.com&lt;/code&gt; 下的任何站点都可以访问当前页面的 DOM 资源。&lt;/p&gt;
&lt;p&gt;使用XMLHttpRequest对象发起HTTP请求(Ajax)就必须遵守同源策略。具体而言，Web应用程序能且只能使用XMLHttpRequest对象向其加载的源域名发 起HTTP请求，而不能向任何其它域名发起请求。跨源资源共享这种机制让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。要想 使子域与根域之间有一个双向的 XMLHttpRequest 通信通道，服务器需要访问如下的响应头：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: *.Httpsecure.org
Access-Control-Allow-Methods: OPTIONS, GET, POST, HEAD, PUT
Access-Control-Allow-Headers: X-custom
Access-Control-Allow-Credentials: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于Ajax的跨域问题，可以使用JSONP，或者在页面中嵌入IFrame将XMLHttpRequest转换成提交表单来解决。&lt;/p&gt;
&lt;h2 id=&quot;web-messaging&quot;&gt;Web Messaging&lt;/h2&gt;
&lt;p&gt;同源策略引起的不同源页面的数据交互的限制，可以使用 Web Messaging API 来解决。具体来说，使用&lt;code&gt;window&lt;/code&gt;对象的&lt;code&gt;postMessage&lt;/code&gt;方法向另一 个&lt;code&gt;window&lt;/code&gt;发送纯文本的内容，然后，另一个&lt;code&gt;window&lt;/code&gt;可以监听到这个消息，然后调用注册到&lt;code&gt;message&lt;/code&gt;事件的回掉函数来处理消息中的数据。举例：&lt;/p&gt;
&lt;p&gt;父级页面：&lt;/p&gt;
&lt;p&gt;域：&lt;code&gt;http://www.a.com&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;text&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;message&amp;quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;button&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; onclick=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;sendMessage();&amp;quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;Send Message&lt;span class=&quot;kw&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;iframe&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;remotepage&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;http://www.a.com/addr/target.html&amp;quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sendMessage&lt;/span&gt;() = {
        &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;#39;#remotepage&amp;#39;&lt;/span&gt;).&lt;span class=&quot;ot&quot;&gt;contentWindow&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;postMessage&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;plain text message&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;http://www.example.com&amp;quot;&lt;/span&gt;);
    }
&amp;lt;&lt;span class=&quot;ot&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子页面：&lt;/p&gt;
&lt;p&gt;域: &lt;code&gt;http://www.b.com&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;messagebox&amp;quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;receiver&lt;/span&gt;(event) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;ot&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;origin&lt;/span&gt; == &lt;span class=&quot;st&quot;&gt;&amp;quot;http://www.a.com&amp;quot;&lt;/span&gt;) {
            &lt;span class=&quot;fu&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;get message: &amp;quot;&lt;/span&gt; + &lt;span class=&quot;ot&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;data&lt;/span&gt; + &lt;span class=&quot;st&quot;&gt;&amp;quot; from &amp;quot;&lt;/span&gt; + &lt;span class=&quot;ot&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;origin&lt;/span&gt; + &lt;span class=&quot;st&quot;&gt;&amp;quot;, source window: &amp;quot;&lt;/span&gt; + &lt;span class=&quot;ot&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;source&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// event.source.postMessage(&amp;quot;got it!&amp;quot;);&lt;/span&gt;
        }
    }
    &lt;span class=&quot;ot&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;#39;message&amp;#39;&lt;/span&gt;, receiver, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
&amp;lt;&lt;span class=&quot;ot&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子页面中的最后一条语句&lt;code&gt;window.addEventListener(&#39;message&#39;, receiver, false);&lt;/code&gt;用来绑定事件，当&lt;code&gt;window&lt;/code&gt;接收到一个message时，就会调用这个函数进行处理。如果使用 jQuery 来绑定事件：&lt;/p&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;ot&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;on&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;#39;message&amp;#39;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (event) {
    &lt;span class=&quot;fu&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;ot&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;ot&quot;&gt;originalEvent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;data&lt;/span&gt;);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是，jQuery对于message事件做了一层封装，要想获取到 &lt;code&gt;event.origin&lt;/code&gt;, &lt;code&gt;event.data&lt;/code&gt; 等属性，需要使用&lt;code&gt;event.originalEvent&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;jschannel.js&quot;&gt;jschannel.js&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mozilla/jschannel&quot;&gt;jschannel.js&lt;/a&gt;是 Mozilla 开发的一个页面间使用 Web Messaging 技术进行通信的JS库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A JavaScript library which implements fancy IPC semantics on top of postMessage.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jschannel.js 将页面间的方法调用封装成 json 文本，使用 postMessage来发送消息，在另一个页面上，按照同样的协议来解析消息内容，调用对应的函数并最终返回函数的执行结果给另一个页面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Page Setup&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;making a simple HTML page that includes the JSChannel script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;jschannel.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And a trivial child frame:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;iframe id=&amp;quot;childId&amp;quot; src=&amp;quot;child.html&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Creating a Channel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s create a channel in our child frame:&lt;/p&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;chan = &lt;span class=&quot;ot&quot;&gt;Channel&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;({
    &lt;span class=&quot;dt&quot;&gt;window&lt;/span&gt;: &lt;span class=&quot;ot&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;childId&amp;quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;contentWindow&lt;/span&gt;,
    &lt;span class=&quot;dt&quot;&gt;origin&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&amp;quot;*&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;dt&quot;&gt;scope&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&amp;quot;testScope&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;dt&quot;&gt;onReady&lt;/span&gt;: &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;ot&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;channel is ready!&amp;quot;&lt;/span&gt;);
    }
});&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Remote Methods&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now we’ll define a simple function in our child frame:&lt;/p&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chan&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;bind&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;reverse&amp;quot;&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(trans, s) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;s&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;reverse&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;);
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And call it in our parent frame.&lt;/p&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chan&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;call&lt;/span&gt;({&lt;span class=&quot;dt&quot;&gt;method&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&amp;quot;reverse&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;dt&quot;&gt;params&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt;,
    &lt;span class=&quot;dt&quot;&gt;success&lt;/span&gt;: &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(v) { &lt;span class=&quot;fu&quot;&gt;emit&lt;/span&gt;(&lt;span class=&quot;ot&quot;&gt;v&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;()); }
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更详细的 jschannel.js 使用的方式，可以查看&lt;a href=&quot;http://mozilla.github.io/jschannel/docs&quot;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;!--links--&gt;
</description>
        <pubDate>Fri, 23 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/web-tech/web_messaging.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/web-tech/web_messaging.html</guid>
        
        <category>Web-Front-End</category>
        
        
        <category>Web-Tech</category>
        
      </item>
    
      <item>
        <title>使用 VS2015 编译 Cython 程序</title>
        <description>&lt;p&gt;Cython, C-Extensions for Python, 通过 Cython，可以把 Python代码编译到 C 语言代码，甚至在 Python 代码中混用 C 语言的 native 数据类型， 进一步编译成动态链接库，从而极大地提升程序的运行效率。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;Hello world&lt;/h2&gt;
&lt;p&gt;创建一个后缀为 &lt;code&gt;.pyx&lt;/code&gt; 的文件，在其中写入：&lt;/p&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;dt&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后创建一个 setuptools 的构建脚本，指定使用 Cython 编译扩展模块：&lt;/p&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;ch&quot;&gt;from&lt;/span&gt; distutils.core &lt;span class=&quot;ch&quot;&gt;import&lt;/span&gt; setup
&lt;span class=&quot;ch&quot;&gt;from&lt;/span&gt; Cython.Build &lt;span class=&quot;ch&quot;&gt;import&lt;/span&gt; cythonize

setup(
    ext_modules = cythonize(&lt;span class=&quot;st&quot;&gt;&amp;quot;helloworld.pyx&amp;quot;&lt;/span&gt;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行编译命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python setup.py build&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;便会在当前目录下得到一个 helloworld.c 的文件，这便是 Cython 根据 Python 代码转换出来的 C 语言程序。此外，当前目录下还有一个 build 文件夹，里面的 lib.xxx.3.4 目录下有一个 helloworld.pyd 的文件，这便是我们得到的动态链接库。使用这个库，直接 import 即可：&lt;/p&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;ch&quot;&gt;import&lt;/span&gt; helloworld&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;便会得到 &lt;code&gt;hello world&lt;/code&gt; 的输出。&lt;/p&gt;
&lt;p&gt;在 Cython 的扩展模块中编写函数以及调用这些函数同样很简单：&lt;/p&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; greet():
    &lt;span class=&quot;dt&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;ch&quot;&gt;import&lt;/span&gt; helloworld

helloworld.greet()&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;编译-cython-遇到的问题&quot;&gt;编译 Cython 遇到的问题&lt;/h2&gt;
&lt;p&gt;在 Linux 上，编译 Cython 模块，只要有 gcc 即可，在 Windows 上，可以使用 Mingw 或者 MSVC 作为 C 语言代码的编译器。关于如何指定具体的编译器，可以参考&lt;a href=&quot;https://docs.python.org/3/install/#building-extensions-tips-and-tricks&quot;&gt;Building Extensions: Tips and Tricks&lt;/a&gt;。具体做法：&lt;/p&gt;
&lt;p&gt;在 Windows 平台上，Python 默认使用的编译器是 MSVC，如果要使用 mingw 作为编译器，在 Python 安装目录下的 &lt;code&gt;Lib\distutils&lt;/code&gt; 下面的 distutils.cfg 文件(如果没有这个文件，创建一个即可)中加入一下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[build]
compiler = mingw32&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而想要指定使用 MSCV 编译器，在 distutils.cfg 中加入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[build]
compiler = msvc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可。&lt;/p&gt;
&lt;p&gt;由于 MinGW 并没有官方发行的 64 位版本，在 Cython 的Wiki中也强调 &lt;strong&gt;Do not use MinGW-w64&lt;/strong&gt;。在 Windows 平台上，如果我们安装的是 64 位版本的 Python，当我们使用设置 &lt;code&gt;compiler=mingw32&lt;/code&gt; 来构建上面的 helloworld的例子时，只要我们 import 得到的动态链接库，Python 就会 Crash，这是由于库的二进制不兼容的问题。因此，需要使用 MSVS 编译器。&lt;/p&gt;
&lt;p&gt;而是用 MSVC 编译，就需要安装 MSVC 编译器，在 Windows 7 上可以通过安装 Windows SDK 来解决，但在 Windows 8 及之后的版本中，已经没有独立的 SDK 安装包了，这就需要安装 Visual Studio。&lt;/p&gt;
&lt;p&gt;而安装了 MSVC 的可能会遇到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Unable to find vcvarsall.bat&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的问题，这是因为 VS 的版本问题，找到 Python 安装目录下的 &lt;code&gt;Lib\distutils\msvc9compiler.py&lt;/code&gt;，找到第 292 行(Python 3.4.3)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;VERSION = get_build_version()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改为安装的 VS 中 VC 编译器的版本，例如，VS 2015 就对应着 14.0，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;VERSION = 14.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就解决了这个问题。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cython/cython/wiki/CythonExtensionsOnWindows&quot;&gt;CythonExtensionsOnWindows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/install/#building-extensions-tips-and-tricks&quot;&gt;Building Extensions: Tips and Tricks&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;!--links--&gt;
</description>
        <pubDate>Sun, 04 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/use_vs2015_build_cython.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/use_vs2015_build_cython.html</guid>
        
        <category>Python</category>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>《Purely Functional Data Structures》笔记</title>
        <description>&lt;p&gt;&lt;strong&gt;Purely Functional Data Structures&lt;/strong&gt;. Chris Okasaki. September 1996. CMU-CS-96-177. School of Computer Science. Carnegie Mellon University.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf&quot;&gt;Download pdf version&lt;/a&gt; from CMU.&lt;/p&gt;
&lt;p&gt;C语言程序员学习数据结构往往很容易找到很多优秀的教科书，但是，诸如使用 Standard ML 和 Haskell 的函数式编程语言程序员去很难拥有这种奢侈品。尽管有一些为命令式语言设计的 数据结构很容易用函数式编程语言实现，但是，&lt;strong&gt;most cannot&lt;/strong&gt;，原因在于函数式编程语言并不赞成使用这些数据结构所依赖的那种赋值方式。这本书将展示延迟求值(lazy evaluation) 在 amortized functional data structure 中的基础性的作用，以及与可持久化(presistance)数据结构的联系，还有将 strict 和 lazy 两种求值策略组合在一起，以及 polymorphic recursion, higher-order 和 recursive modules.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id=&quot;chapter-1-introduction&quot;&gt;Chapter 1: Introduction&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Programmers can use any language thry want, as long as it’s imperative. – by Henry Ford.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽管函数式编程方法论层面的好处(methodological benefits)已经众所周知，但这些益处并没有在使用函数式语言来描述数据结构这一点上体现出来。有两个基本的原因：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;函数式语言反对 destructive updates (assignments)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;destructive updates can be dangerous when misused, but tremendously effective when used properly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot; type=&quot;1&quot;&gt;
&lt;li&gt;与命令式语言相比，人们对函数式编程语言描述的数据结构的灵活性的期待更高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用命令式语言时，当我们更新一个数据结构时，原来的值已经不复存在，但当我们更新函数式语言的数据结构时，我们希望能够同时使用原来的值和新的值，用来完成后续的计算。函数式编程中，数据结构自动地就是 可持久化的(autommatically presistent)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Furthermore, theoreicians have established lower bounds suggesting that functional programming languages may be fundamentally less efficient than imperative languages in some situation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;严格(strict)求值与惰性(lazy)求值主要的表现实在对函数的参数的处理上。&lt;/p&gt;
&lt;h2 id=&quot;chapter-2-lazy-evaluation-and--notation&quot;&gt;Chapter 2: Lazy Evaluation and $-Notation&lt;/h2&gt;
&lt;p&gt;Two essential properties of lazy evaluation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the evaluation of a given expression id delayed(suspended), until its result is neeeded.&lt;/li&gt;
&lt;li&gt;the first time a suspended expression is evalated, the result is mmeoized, so that the next time it is needed, it can be looked up rather than recomputed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Primitives of lazy evaluation(delay and force):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type a susp
val delay: (unit -&amp;gt; a) -&amp;gt; a susp
val force: a susp -&amp;gt; a&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$-notation: import $-notation to make suspending an expression as syntactically lightweight as possible.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delay(e): `$_e`: to suspend the evaluation of some expression `e`.
force(e): evaluate and memoize the contents of `$_e` and return the result.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;function &lt;code&gt;take(ns, s)&lt;/code&gt;: extract the first n element of a stream.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun take(ns, s) = delay(fn() =&amp;gt; case n of
                                     0 =&amp;gt; Nil
                                     _ =&amp;gt; case force s of
                                               Nil =&amp;gt; Nil
                                               Cons (x, s&amp;#39;) =&amp;gt; Cons (x, take (n-1, s&amp;#39;)))&lt;/code&gt;&lt;/pre&gt;
&lt;!--links--&gt;
</description>
        <pubDate>Sun, 04 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/pfds_notes.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/pfds_notes.html</guid>
        
        <category>Haskell</category>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>static_assert</title>
        <description>&lt;p&gt;&lt;code&gt;assert&lt;/code&gt; 是 C/C++ 中的运行时断言机制，但是，如果包含断言的函数不被调用，就无法触发该断言， 实际上，编译期的断言也非常重要，例如在模板实例化时的编译期断言很有利于提高程序的质量。Boost 库中内置了 &lt;code&gt;BOOST_STATIC_ASSERT&lt;/code&gt; 断言机制，C++0x/C++11标准中也加入了 &lt;code&gt;static_assert&lt;/code&gt; 断言。不借助 Boost 库和 C++0x/C++11，如何实现一个编译期断言？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 &lt;code&gt;switch...case&lt;/code&gt; 语句中两个 &lt;code&gt;case expression&lt;/code&gt; 不能相等的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#define assert_static(e) &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    do { &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        switch (e) case 0: case(e): ; &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    } while (0)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;do {} while (0)&lt;/code&gt; 可以使得 &lt;code&gt;assert_static&lt;/code&gt; 宏在使用的时候更像是函数调用。这一技巧在 Linux 内核中的队列实现部分也有很多非常精彩的运用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用数组长度不能为负数的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#define assert_static(e) &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    do { &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;        int __assert_static[(e) ? 1 : (-1)]; &lt;/span&gt;\
&lt;span class=&quot;ot&quot;&gt;    } while (0)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这么使用 &lt;code&gt;do {} while (0)&lt;/code&gt; 可以将数组定义包裹在一个新的作用域中，不至于引起和程序中已经定义 的变量的冲突。&lt;/p&gt;
&lt;p&gt;值得一提的是，&lt;em&gt;深入理解 C++11 新特性解析与应用&lt;/em&gt; 一书中第30页使用了 “‘除0’会导致编译器报错” 来实现 &lt;code&gt;assert_static&lt;/code&gt; 的方法是不正确的。在 C++ 中，“除0” 是未定义行为，在 C++11 标准 (ISO/IEC14882) Section 5.6 中，明确指出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the second operand of / or % is zero the behavior is undefined.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于为什么要这么做，C++ 之父 &lt;strong&gt;Bjarne Stroustrup&lt;/strong&gt; 的 &lt;em&gt;The Design and Evolution of C++&lt;/em&gt; (Addison Wesley, 1994) 一书中提到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;low-level events, such as arithmetic overflows and divide by zero, are assumed to be handled by a dedicated lower-level mechanism rather than by exceptions. This enables C++ to match the behaviour of other languages when it comes to arithmetic. It also avoids the problems that occur on heavily pipelined architectures where events such as divide by zero are asynchronous.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 02 Oct 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/static_assert.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/static_assert.html</guid>
        
        <category>C/C++</category>
        
        
        <category>编程语言</category>
        
      </item>
    
      <item>
        <title>钱币兑换问题</title>
        <description>&lt;p&gt;钱币兑换问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;仅有 n 种指定面值的硬币(c1, c2, c3, …, cn), 将钱 N 兑换成 这些面值的硬币，总共有多少种兑换方法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--more--&gt;
&lt;h2 id=&quot;递推&quot;&gt;递推&lt;/h2&gt;
&lt;p&gt;最简单的递推的想法: 枚举每种货币的使用次数，当使用 &lt;code&gt;k&lt;/code&gt; 次第 &lt;code&gt;n&lt;/code&gt; 种硬币凑出了 &lt;code&gt;j&lt;/code&gt; 钱数的方案，应当等于只使用了前 &lt;code&gt;n-1&lt;/code&gt; 种硬币凑出了 &lt;code&gt;dp[j-k*coin[n]]&lt;/code&gt; 钱数，而凑出钱数 &lt;code&gt;money&lt;/code&gt; 的总方案，应当等于仅使用了 前 &lt;code&gt;1&lt;/code&gt; 中硬币、仅使用的前 &lt;code&gt;2&lt;/code&gt; 种硬币、…、仅使用了前 &lt;code&gt;n-1&lt;/code&gt; 中硬币、使用了全部n种硬币的方案的&lt;strong&gt;总和&lt;/strong&gt;。暗按照这个想法，直接递推求解即可。&lt;/p&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dp[MAX_N] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; exchange(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; money, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; coin[]) {
    dp[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i &amp;lt;= n; ++i) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = money; j &amp;gt;= coin[i]; --j) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = j / coin[i]; k &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; --k) {
                dp[j] += dp[j - k*coin[i]];
            }
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dp[money];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个方法还可以进一步简化。在上面的方法中，我们从大往小地枚举钱数，考虑到每种硬币都有无限枚可以选，因此，在选择第 i 中硬币时，我们只需要从一个绝无已经选择第 &lt;code&gt;i&lt;/code&gt; 种硬币的可能的情形 开始枚举递推即可。在具体实现上，只要改变总钱数 &lt;code&gt;j&lt;/code&gt; 的递推顺序即可。进一步地，采用压缩空间的写法，代码如下：&lt;/p&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; dp[MAX_N] = {&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;};

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; exchange(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; money, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; coin[])
{
    dp[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i &amp;lt;= n; ++i) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = coin[i]; j &amp;lt;= money; ++j) {
            dp[j] += dp[j-coin[i]];
        }
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dp[money];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方法与求解完全背包的算法的思路有很大的相似之处。&lt;/p&gt;
&lt;h2 id=&quot;母函数&quot;&gt;母函数&lt;/h2&gt;
&lt;p&gt;钱币兑换问题本质上是一个组合问题：以 n 中硬币来组合出制定的钱数。因此，也可以通过母函数的方法来求解钱币组合问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f(n) = (1+x+x^(c1)+x^(2*c1)+...) * (1+x+x^(c2)+x^(2*c2)+...) * (1+x+x^(c3)+x^(2*c2)+...) * ... * (1+x+x^(cn)+x^(2*cm)+...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所要求的兑换方案数，即第 n 项的系数，接下来，模拟多项式展开即可。&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Sep 2015 00:00:00 +0800</pubDate>
        <link>http://sighingnow.github.io/algorithm/coin.html</link>
        <guid isPermaLink="true">http://sighingnow.github.io/algorithm/coin.html</guid>
        
        <category>Algorithm</category>
        
        
        <category>Algorithm</category>
        
      </item>
    
  </channel>
</rss>
