<!DOCTYPE HTML>

<html lang="en">
  
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | DHDave</title>
  <meta name="author" content="DHDave">
  
  <meta name="description" content="DHDave&#39;s Personal Page.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="DHDave"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <meta http-equiv="Content-Language" content="en"/>
  

  <link href="/img/favicon.png" rel="icon">
  
    <link rel="apple-touch-icon" href="/img/apple-icon.png">
    <link rel="apple-touch-icon-precomposed" href="/img/apple-icon.png">
    

  <link rel="alternate" href="/atom.xml" title="DHDave" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <style type="text/css">
  /* Tim Pietrusky advanced checkbox hack (Android <= 4.1.2) */
body{ -webkit-animation: bugfix infinite 1s; }
@-webkit-keyframes bugfix { from {padding:0;} to {padding:0;} }

  

  
    article .post-content-index .entry{max-height: 550px; overflow:hidden;}
  
</style>

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'null', 'auto');
  ga('send', 'pageview');
 
</script>




  
    
      <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400|Playball' rel='stylesheet' type='text/css'>
    
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.11.1.min.js"></script>

  



</head>


<body>
  <header id="header" class="inner"><div class="padding">
	<div class="alignleft logo">
	  <h1><a href="/">DHDave</a></h1>
	</div>
	<nav id="main-nav" class="alignright">
		<input type="checkbox" id="toggle" />
		<label for="toggle" class="toggle" data-open="Main Menu" data-close="Close Menu" onclick><i class="fa fa-bars"></i></label>
	  <ul class="menu">
	    
	      <li><a href="/">Home</a></li>
	    
	      <li><a href="/archives">Archives</a></li>
	    
	    
	  </ul>
	</nav>
	<div class="clearfix"></div>
</div>
</header>
  <div id="page-heading-wrap">
  	<div class="inner">
      <div class="padding">
    		
          <h2>DHDave&#39;s Personal Page</h2>
        
      </div>
  	</div>
  </div>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper" class="padding">
  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/02/programming language/c_cpp/c_cpp_callback/">C和C++中的回调函数</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-01T16:00:00.000Z">2015-02-02</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/02/programming language/c_cpp/c_cpp_callback/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="回调函数(Callback_Functions)">回调函数(Callback Functions)</h2><p>回调函数是指一个通过函数指针调用的函数。回掉函数不是由该函数的实现方法直接调用，而是在特定时间或条件发生时由另一方调用的，用于对该事件或条件进行响应。</p>
<h2 id="回调函数的简单实现">回调函数的简单实现</h2><p>C和C++中，可以通过函数指针的方式实现回调函数。如下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*callf)</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回调函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fa</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a is called, a is %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回调函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fb</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b is called, b is %d\n"</span>, b);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call1</span><span class="params">(callf pcf, <span class="keyword">int</span> arg)</span> </span>&#123; <span class="comment">/* 通过typedef函数指针的方式 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"call1 is called, arg is %d\n"</span>, arg);</span><br><span class="line">    pcf(arg); <span class="comment">// 调用回调函数</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call2</span><span class="params">(<span class="keyword">int</span> (*ptr)</span><span class="params">(<span class="keyword">int</span> )</span>, <span class="keyword">int</span> arg) </span>&#123; <span class="comment">/* 通过直接定义函数指针的方式 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"call2 is called, arg is %d\n"</span>, arg);</span><br><span class="line">    ptr(arg); <span class="comment">// 调用回调函数</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arg = <span class="number">10</span>;</span><br><span class="line">    call1(&amp;fa, arg);</span><br><span class="line">    call2(&amp;fb, arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上例中，我们可以看到，在C/C++中可以直接将函数指针作为参数传参，并通过函数指针进行函数调用和传递参数，从而实现了回调函数。</p>
<h2 id="回调函数与事件模型">回调函数与事件模型</h2><p>首先声明时间模型、回调函数和事件注册函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件模型声明</span></span><br><span class="line"><span class="keyword">struct</span> Event;</span><br><span class="line"><span class="comment">// 回调函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pEvent_cbF)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> Event *e, <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="comment">// 事件注册函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_cbF_register</span><span class="params">(pEvent_cbF pf, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在事件调度器(event dispather)中，通常将回调函数放在结构体中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Event &#123;</span><br><span class="line">    pEvent_cbF callback;</span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，实现事件注册函数和回掉函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_cbF_register</span><span class="params">(Event *e, pEvent_cbF callback, <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    e-&gt;callback = callback;</span><br><span class="line">    e-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_event_cbF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> Event *e, <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"my event callback function is called.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"data: %s\n"</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"event data: %s\n"</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)(e-&gt;data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数中测试：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Event curtom_event;</span><br><span class="line">    <span class="keyword">char</span> custom_data[<span class="number">15</span>] = <span class="string">"Event occur !"</span>;</span><br><span class="line">    event_cbF_register(&amp;curtom_event, &amp;my_event_cbF, custom_data);</span><br><span class="line">    curtom_event.callback(&amp;curtom_event, curtom_event.data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述程序，将获得如下输出：</p>
<pre><code>ht@debian ~
$ ./callback
my <span class="keyword">event</span> callback <span class="function"><span class="keyword">function</span> <span class="title">is</span> <span class="title">called</span>.
<span class="title">data</span>:</span> <span class="keyword">Event</span> occur !
<span class="keyword">event</span> data: <span class="keyword">Event</span> occur !
</code></pre><h2 id="回调函数与异步非阻塞">回调函数与异步非阻塞</h2><p>将回调函数放在单独的线程中执行，便可以做到异步非阻塞处理。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/02/programming language/c_cpp/c_cpp_callback/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/02/programming language/haskell/dive_into_haskell_1_ghci/">Dive Into Haskell(1) GHCi</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-01T16:00:00.000Z">2015-02-02</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/02/programming language/haskell/dive_into_haskell_1_ghci/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="What’s_GHC_?">What’s GHC ?</h2><p>GHC(Glasgow Haskell Compiler):  an interactive and batch compilation system for the <a href="http://www.haskell.org/" title="Haskell" target="_blank" rel="external">Haskell 98</a> language.</p>
<p>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), and a batch compiler, described throughout. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</p>
<h2 id="What’s_GHCi_?">What’s GHCi ?</h2><p>GHCi是一个GHC的交互式环境，在GHCi中可以交互式地求得对Haskell表达式的值，Haskell程序也可以在GHCi中被解释。GCHi还包含了一个交互式的Haskell调试器。</p>
<h2 id="GHCi的常用命令：">GHCi的常用命令：</h2><ul>
<li>:? 或 :help 获取关于GHCi的帮助。</li>
<li>:q 或 :quit 退出GHCi。</li>
<li>:!<cmd> 执行外部命令<cmd>。</cmd></cmd></li>
<li>:l 和 :r 或 :load 和 :reload 加载外部的hs文件。</li>
<li>:t 或 :type 显示出表达式的类型。</li>
<li>:set + t 设置所有表达式默认显示出其类型。</li>
<li>:i<name> 显示<name>相关的信息(info)。可以通过这种方式获取帮助。例如：</name></name></li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :i print</span><br><span class="line"><span class="title">print</span> :: <span class="type">Show</span> a =&gt; a -&gt; <span class="type">IO</span>() <span class="comment">-- Defined in 'System.IO'</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :i +</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Num</span> a <span class="keyword">where</span></span></span><br><span class="line">  (+) :: a -&gt; a -&gt; a</span><br><span class="line">  ...</span><br><span class="line">        <span class="comment">-- Defined in 'CHC.Num'</span></span><br></pre></td></tr></table></figure>
<h2 id="GHCi_使用">GHCi 使用</h2><p>在GHCi的使用中，应该注意以下几点：</p>
<ul>
<li>GHCi 中可以直接进行数学表示式的运算，在这一点上和Python的交互式环境(Python Shell) 很像。</li>
<li><p>GHCi 中支持的数学运算符号：+, -, *, /, **(乘方)。<strong>注意</strong>：**计算得到的结果是浮点数：</p>
<pre><code>Prelude&gt; :t 2 <span class="keyword">*</span><span class="keyword">*</span> 2
2 <span class="keyword">*</span><span class="keyword">*</span> 100 :: Floating a-&gt;a
</code></pre></li>
<li><p>Haskell中不同类型的数不能直接进行数学运算。需要做类型转换。</p>
<ul>
<li><code>fromIntegral</code>函数可以将整数类型转换为别的类型。</li>
<li><code>toIntegral</code>函数可以将其他类型的数(如：浮点数)转换成整数。</li>
<li>类似的函数还有：<code>fromInteger</code>,<code>toInteger</code>。</li>
</ul>
</li>
<li><p>GHCi 中不能用 % 进行取模运算。</p>
</li>
<li><p>GHCi 中，用<code>/=</code>表达不等号。举例：</p>
<pre><code>Prelude&gt; <span class="number">10</span> /= <span class="number">20</span>
<span class="literal">True</span>
Prelude&gt; <span class="number">10</span> /= <span class="number">10</span>
<span class="literal">False</span>
</code></pre></li>
<li><p>GHCi 有一个名为 <code>it</code> 的变量，自动保存上一次计算的结果。其类型也随上一条表达式的结果的变化而变化。</p>
</li>
</ul>
<h2 id="GHCi交互式环境与加载hs文件的区别">GHCi交互式环境与加载hs文件的区别</h2><p>如果加载一个hs文件，GHCi会将整个文件看作一个过程，其解释顺序是不可预测的。<strong>但是</strong>，在GHCi中直接输入表达式是，其解释顺序是由输入(IO)的顺序的决定的。例如：</p>
<pre><code>c = <span class="tag">a</span> + <span class="tag">b</span>
<span class="tag">a</span> = <span class="number">1</span>
<span class="tag">b</span> = <span class="number">2</span>
</code></pre><p>将这段代码写在hs文件中，在load进GHCi中后，执行<code>c</code>可以正常输出<code>3</code>，但在GHCi中，无法通过直接输入表达式来得到这样的结果。这也是Haskell的函数式的特性所决定的。</p>
<h2 id="GHCi_与函数">GHCi 与函数</h2><p>在GHCi中输入加减乘除等表达式时都是在调用函数，<code>+, -, *, /</code> 等都是函数。因此，有如下的用法：</p>
<pre><code>Prelude&gt; <span class="comment">(+)</span> <span class="number">1</span> <span class="number">2</span>
<span class="number">3</span>
</code></pre><p>除此以外，还有这些函数可以使用：</p>
<ul>
<li><p><code>succ</code> 函数</p>
<pre><code>Prelude&gt; succ <span class="number">1</span>
<span class="number">2</span>
Prelude&gt; succ <span class="string">'a'</span>
<span class="string">'b'</span>
</code></pre></li>
<li><p><code>max</code> 和 <code>min</code> 函数</p>
</li>
</ul>
<p>前面提到的<code>/</code>表示的真除法(和Python类似)，如果只想保留结果的整数部分(和C++类似)，那么可以使用<code>div</code>函数:</p>
<pre><code>Prelude&gt; <span class="tag">div</span> <span class="number">10</span> <span class="number">3</span>
<span class="number">3</span>
</code></pre><p>显然，这种形式并不便于理解和区分除数和被除数，因此，可以写成中缀函数的形式(<strong>注意</strong> <code>div</code> 左右各有一个<strong>“`“</strong>符号)：</p>
<pre><code>Prelude&gt; <span class="number">10</span> <span class="escape">`d</span>iv<span class="escape">` </span><span class="number">3</span>
<span class="number">3</span>
</code></pre><p>前面提到，在GHCi中，不能用 <code>%</code> 来表示取模运算，可以这样实现取模:</p>
<pre><code>Prelude&gt; <span class="keyword">mod</span> <span class="number">10</span> <span class="number">3</span>
<span class="number">1</span>
Prelude&gt; <span class="number">10</span> `<span class="keyword">mod</span>` <span class="number">3</span>
<span class="number">1</span>
</code></pre><h2 id="GHCi_中定义变量">GHCi 中定义变量</h2><p>在GHCi中使用<code>let</code>来定义变量：</p>
<pre><code>Prelude&gt; let <span class="tag">a</span> = <span class="number">1</span>
Prelude&gt; <span class="tag">a</span>
<span class="number">1</span>
</code></pre><p>在GHCi中用<code>let</code>定义变量与在hs文件中通过用<code>=</code>赋值来定义变量是等价的。例如：</p>
<pre><code><span class="tag">a</span> = <span class="number">1</span>
</code></pre><p>在GHCi中，如果直接使用<code>=</code>对变量赋值会出错。</p>
<h2 id="GHCi_自动补全">GHCi 自动补全</h2><p>在GHCi中输入命令时，输入命令的前几个字符后，按<code>Tab</code>键便可以补全命令。如果有多个相匹配的命令，GHCi会在下一行列出这些命令。如果只有一个，会直接补全。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/02/programming language/haskell/dive_into_haskell_1_ghci/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/01/algorithm/joseph/">约瑟夫环问题求解</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-01-31T16:00:00.000Z">2015-02-01</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/01/algorithm/joseph/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="一、概述">一、概述</h2><p>约瑟夫环问题(Josephus)是考察队列的一个经典问题，通常可用循环队列解决，时间复杂度O(m*n)，通过数学递推的解法具有O(n)的时间复杂度，是一个很高效的算法。</p>
<h2 id="二、算法原理">二、算法原理</h2><p>约瑟夫环的递推公式：</p>
<center>$$<br>    f[1]=0;　f[i]=(f[i-1]+m)%i; (i&gt;1)<br>    f[1]=1;　f[i]=(f[i-1]+m)%i  (i&gt;1);   if(f[i]==0) f[i]=i;<br>$$</center>

<p>那么这两个公式有什么不同？<br>首先可以肯定的是这三个公式都正确。公式1，得到的是以0～n-1标注的最终序号；公式2得到的就是正常的1~n的序号。下面我们就分别推导两个公式。<br>公式1的推导：<br>给出一个序列，从0～n-1编号。其中，k代表出列的序号的下一个，即k-1出列。<br>$$ a: 0, 1, …, k-1, k, k+1, …, n-1 $$<br>那么，出列的序号是(m-1)%n，k=m%n（这个可真的是显而易见）。出列k-1后，序列变为<br>$$ b: 0, 1, …, k-2, k, k+1, …, n-1 $$<br>然后，我们继续从n-1后延长这个序列，可以得到<br>$$ c’: 0, 1, …, k-2, k, k+1, …, n-1, n, n+1, …, n+k-2 $$<br>我们取从k开始直到n+k-2这段序列。其实这段序列可以看作将序列b的0~k-2段移到了b序列的后面。这样，得到一个新的序列<br>$$ c: k, k+1, …, n-1, n, n+1, …, n+k-2 $$<br>好了，整个序列c都减除一个k，得到<br>$$ d: 0, 1, …, n-2 $$<br>c序列中的n-1, n, n+1都减除个k是什么？这个不需要关心，反正c序列是连续的，我们知道了头和尾，就能知道d序列是什么样的。</p>
<p>因此，从序列a到序列d，就是一个n序列到n-1序列的变化，约瑟夫环可以通过递推来获得最终结果。ok，继续向下。剩下的就是根据n-1序列递推到n序列。假设在n-1序列中，也就是序列d中，我们知道了最终剩下的一个序号是x，那么如果知道了x转换到序列a中的编号x’，不就是知道了最终的结果了么？</p>
<p>下面我们就开始推导出序列a中x的序号是什么。</p>
<ul>
<li>d-&gt;c，这个变换很容易，就是x+k；</li>
<li>c-&gt;b，从b-&gt;c，其实就是0~k-2这段序列转换为n~n+k-2这段序列，那么再翻转回去，简单的就是%n，即(x+k)%n。%n以后，k~n-1这段序列值不会发生变化，而n~n+k-2这段序列则变成了0~k-2；这两段序列合起来，就是序列b。</li>
</ul>
<p>于是，我们就知道了 $$ x’=(x+k)\%n $$并且，$$ k=m\%n $$所以$$ x’=(x+m\%n)\%n=(x+m)%n $$公式1就出来了：$$ f[i]=(f[i-1]+m)\%i $$当然，i=1就是特殊情况了，<code>f[1]=0</code>。这里还有一个小问题。也许你会迷惑为什么<code>x&#39;=(x+m%n)%n=(x+m)%n</code>中的<code>%n</code>变成公式中<code>f[i]=(f[i-1]+m)%i</code>中的<code>%i</code>？其实这个稍微想想就能明了。我们%n就是为了从序列c转换到序列b——这是在n-1序列转换成n序列时%n；那么从n-2转换到n-1呢？不是要<code>%(n-1)</code>了吗？所以这个值是变量，不是常量。</p>
<p>好了，这个最后需要注意的就是从一开始，我们将n序列从<code>0~n-1</code>编号，所以依据公式1得出的序号是基于0开始的。</p>
<h2 id="三、求解出圈序列(线段树)">三、求解出圈序列(线段树)</h2><p>如果需要输出出圈的序列，常规求解算法为队列的解法，可以用循环队列优化空间，但时间复杂度仍未 O(m*n), 可以采用线段树（排名树）的方法提高效率。通过线段树记录每个区间内还没有出圈的元素的个数，每次通过取模运算求出需要出列的元素从1开始的相对位置，再从线段树中找出该元素，并更新线段树。时间复杂度为O(n*logn)。参考 <a href="http://codevs.cn/problem/1282/" title="wikioi 1282" target="_blank" rel="external">wikioi 1282</a> 题，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// segment tree.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">120010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        sum[rt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    build(m+<span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    sum[rt]--;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, l);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= sum[rt &lt;&lt; <span class="number">1</span>]) &#123;</span><br><span class="line">        update(p, l, m, rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(p-sum[rt&lt;&lt;<span class="number">1</span>], m+<span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sum[rt] = sum[rt &lt;&lt; <span class="number">1</span>] + sum[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> seq = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        seq = (seq+m-<span class="number">1</span>) % sum[<span class="number">1</span>]; <span class="comment">// get the relative postion.</span></span><br><span class="line">        <span class="keyword">if</span> (seq == <span class="number">0</span>) &#123;</span><br><span class="line">            seq = sum[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        update(seq, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四_、参考：">四 、参考：</h2><p>1、<a href="http://hi.baidu.com/anywei/item/294351b5f432f144ba0e12f2" target="_blank" rel="external">http://hi.baidu.com/anywei/item/294351b5f432f144ba0e12f2</a></p>
<p>2、<a href="http://www.cnblogs.com/EricYang/archive/2009/09/04/1560478.html" target="_blank" rel="external">http://www.cnblogs.com/EricYang/archive/2009/09/04/1560478.html</a></p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/01/algorithm/joseph/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/01/algorithm/manacher/">Manacher算法</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-01-31T16:00:00.000Z">2015-02-01</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/01/algorithm/manacher/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="一、概述">一、概述</h2><p>Manacher算法是一个用来求解最长回文字串的高效算法。其核心是在枚举回文字串的中心位置，并在计算其对应的回文字串时充分前面的已经算出来的结果。</p>
<h2 id="二、算法原理">二、算法原理</h2><p>首先，需要考虑回文字串长度为奇数和为偶数的情形下的差异，为了消除这一差异，在长度为n的字符串中插入n+1个无关字符，例如’#’,’*‘等。这一步骤时间复杂度为O(n)。<br>Manacher算法需要O(n)的辅助数组，用来记录每一个位置可以向右扩展回文串的长度（包含其自身），同时，记录当前有最大向右扩展长度的索引位置 id，那么，辅助数组有如下性质：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f[id] + id &gt; i)</span><br><span class="line">    f[i] = min(f[<span class="number">2</span>*id-i], f[id]+id-i)</span><br></pre></td></tr></table></figure>
<p>解释：2*id-i为i关于id位置的对称位置，在考虑回文串长度时，i位置能够向右扩展的长度应不小于j位置向左扩展的长度，而以j为中心位置的回文串的左右扩展长度相同。同时，如果i在id的扩展范围内，在i位置未单独向右扩展之前，i位置能够向右扩展的位置应当小于id向右扩展的位置。</p>
<p>在找到<code>f[i]</code>的下界后，开始以i为中心，<code>f[i]</code>为长度下界，扩展此回文串。具体做法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(str[i-f[i]] == str[i+f[i]])</span><br><span class="line">    f[i]++</span><br></pre></td></tr></table></figure>
<p>找到i位置能够扩展的最大长度之后，如果i位置能够向右到达的最大位置大于id位置能够向右到达的最大位置，则更新id。</p>
<p>最后，由于之前已经在每两个字符之间插入了无关字符，因此，以i为中心位置的最长回文字串的长度为<code>f[i]-1</code>,线性扫一遍，便可以得到该字符串的最大回文字串长度。</p>
<h2 id="三、复杂度解释">三、复杂度解释</h2><p>由于每次最外层循环都在扩展能够向右到达的最大位置，而该位置值的最大值为字符串的长度，因此，此算法具有O(n)的优异复杂度。</p>
<h2 id="四、参考题目">四、参考题目</h2><p><a href="http://hihocoder.com/problemset/problem/1032" title="HihoCoder 1032" target="_blank" rel="external">http://hihocoder.com/problemset/problem/1032</a></p>
<p>题解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// manacher.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len, f[<span class="number">2000010</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>, mx = <span class="number">0</span>, ans = <span class="number">0</span>; <span class="comment">// mx = id + f[id]</span></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mx &gt; i) &#123;</span><br><span class="line">            f[i] = min(f[<span class="number">2</span> * id - i], f[id] + id - i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i-f[i] &gt;= <span class="number">0</span> &amp;&amp; i+f[i] &lt;= <span class="number">2</span>*len &amp;&amp; str[i+f[i]] == str[i-f[i]]) &#123;</span><br><span class="line">            f[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f[i] + i &gt; mx) &#123;</span><br><span class="line">            mx = f[i] + i;</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">'#'</span>) &#123;</span><br><span class="line">            ans = max(ans, ((f[i]-<span class="number">1</span>)/<span class="number">2</span>) * <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = max(ans, ((f[i]-<span class="number">1</span>)/<span class="number">2</span>) * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            str[<span class="number">2</span>*i+<span class="number">1</span>] = str[i];</span><br><span class="line">            str[<span class="number">2</span>*i+<span class="number">2</span>] = <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、扩展">五、扩展</h2><p>还可以利用后缀数组等其他算法解决最长回文子串问题，但时间复杂度和编程复杂度均高于Manacher算法。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/01/algorithm/manacher/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/01/algorithm/longestpathintree/">树的最长路径</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-01-31T16:00:00.000Z">2015-02-01</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/01/algorithm/longestpathintree/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="一、概述">一、概述</h2><p>树的最长路问题是一类求解树上两点之间最长距离的问题。针对此问题，有这样两类算法：DFS求解和树形DP。本文将以 <a href="http://hihocoder.com/problemset/problem/1050" target="_blank" rel="external">HihoCoder 1050 : 树中的最长路</a> 一题为例，详细阐述这两种解法。</p>
<h2 id="二、树形DP">二、树形DP</h2><p>树形DP的基本思路为由子节点的情况推出父节点的情况，针对树的最长路径这一问题，分别记录每个节点的子节点的最大深度和次大深度，父节点的最大深度等于所有子节点的最大深度和次大深度的最大值加1，父节点的次大深度等于所有子节点的最大深度和次大深度的次大值加1，最后，每个节点对应的最长路径值为该节点的<code>最大深度-次大深度+1</code>,由此可得到树的最长路径长度。伪代码描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初始值：</span><br><span class="line">    depth_0[leaf node] = depth_1[leaf node] = <span class="number">1</span></span><br><span class="line">递推：</span><br><span class="line">    depth_0[parent] = max(&#123;depth_0[&#123;sons&#125;], depth_1[&#123;sons&#125;]&#125;)</span><br><span class="line">    depth_1[parent] = max(&#123;depth_0[&#123;sons&#125;], depth_1[&#123;sons&#125;]&#125; - depth_0[parent])</span><br><span class="line">求解：</span><br><span class="line">    length[i] = depth_0[i] + depth_1[i] - <span class="number">1</span></span><br><span class="line">    longest = max(&#123;length[i]&#125;)</span><br></pre></td></tr></table></figure>
<p>由此，得到结果。</p>
<h2 id="三、DFS求解">三、DFS求解</h2><p>此题通过DFS求解的算法正确性基于以下性质：</p>
<p>以树上的任意一点为根节点，距离根节点最远的点一定是树的最长路径的一个端点。</p>
<p>证明：假设 s-t这条路径为树的最长路径，分以下两种情况证明：</p>
<ol>
<li>设u为s-t路径上的一点，结论显然成立，否则设搜到的最远点为T则<code>dis(u,T) &gt;dis(u,s)</code>且<code>dis(u,T)&gt;dis(u,t)</code>，则最长路不是s-t了，与假设矛盾。</li>
<li>设u不为s-t路径上的点，首先明确，假如u走到了s-t路径上的一点，那么接下来的路径肯定都在s-t上了，而且终点为s或t，在1中已经证明过了。<br>所以现在又有两种情况了：<br>1：u走到了s-t路径上的某点，假设为X，最后肯定走到某个端点，假设是t ，则路径总长度为<code>dis(u,X)+dis(X,t)</code><br>2：u走到最远点的路径u-T与s-t无交点，则<code>dis(u-T)&gt;dis(u,X)+dis(X,t)</code>显然，如果这个式子成立，<br>则<code>dis(u,T)+dis(s,X)+dis(u,X)&gt;dis(s,X)+dis(X,t)=dis(s,t)</code>最长路不是s-t矛盾。</li>
</ol>
<p>由此上性质，得到如下解法：从任意一点对树DFS，找出深度最大的点，该点即为树的最长路径的一个端点。再从该点出发，对树进行一次DFS，此时得到的深度最大的点，该点即为树的最长路径的另一个端点，此时改点的深度值即为树的最长路径的长度。</p>
<h2 id="四、代码实现">四、代码实现</h2><p><a href="http://hihocoder.com/problemset/problem/1050" target="_blank" rel="external">HihoCoder 1050</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;queue&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> e[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> depth[<span class="number">100100</span>], ans, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(depth));</span><br><span class="line">    <span class="stl_container"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;</span> Q;</span><br><span class="line">    Q.push(start);</span><br><span class="line">    flag[start] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123; </span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[e[u][i]]) &#123;</span><br><span class="line">                depth[e[u][i]] = depth[u]+<span class="number">1</span>;</span><br><span class="line">                flag[e[u][i]] = <span class="keyword">true</span>;</span><br><span class="line">                Q.push(e[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> point = -<span class="number">1</span>;</span><br><span class="line">    ans = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[i] &gt; ans) &#123;</span><br><span class="line">            ans = depth[i];</span><br><span class="line">            point = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> point; <span class="comment">// 返回距离最远的点的编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        e[x].push_back(y);</span><br><span class="line">        e[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(bfs(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/01/algorithm/longestpathintree/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/01/programming language/c_cpp/gotoxy_colored_output/">C语言控制台程序光标位置与文字颜色</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-01-31T16:00:00.000Z">2015-02-01</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/01/programming language/c_cpp/gotoxy_colored_output/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="Windows平台">Windows平台</h2><h3 id="控制光标定位">控制光标定位</h3><p>Windows环境下可以通过调用WIN32 API来实现光标定位，具体实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;windows.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    COORD cursorPosition;</span><br><span class="line">    cursorPosition.X = x;</span><br><span class="line">    cursorPosition.Y = y;</span><br><span class="line">    <span class="comment">// COORD cursorPosition = &#123;x, y&#125;;</span></span><br><span class="line">    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cursorPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：X, Y 的值都是从 <code>0</code> 开始的。</p>
<h3 id="隐藏光标">隐藏光标</h3><p>有了光标定位的基础，只需要将光标定位于控制台之外的为，便可以实现隐藏光标，例如，通过上文中实现的<code>gotoxy</code>函数将光标定位于<code>(-1, -1)</code> 位置便可以实现隐藏光标。</p>
<h3 id="清屏">清屏</h3><p>Windows环境下可以通过执行cls命令来实现清屏，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;windows.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"cls"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="color命令">color命令</h3><p>在cmd命令行中执行 <code>color /?</code>，可以得到color命令的用法如下：</p>
<pre><code>设置默认的控制台前景和背景颜色。
COLOR [attr]
    attr        指定控制台输出的颜色属性
颜色属性由两个十六进制数字指定 -- 第一个为背景，第二个则为
前景。每个数字可以为以下任何值之一:

    <span class="number">0</span> = 黑色       <span class="number">8</span> = 灰色
    <span class="number">1</span> = 蓝色       <span class="number">9</span> = 淡蓝色
    <span class="number">2</span> = 绿色       <span class="variable">A =</span> 淡绿色
    <span class="number">3</span> = 浅绿色     <span class="variable">B =</span> 淡浅绿色
    <span class="number">4</span> = 红色       <span class="variable">C =</span> 淡红色
    <span class="number">5</span> = 紫色       <span class="variable">D =</span> 淡紫色
    <span class="number">6</span> = 黄色       <span class="variable">E =</span> 淡黄色
    <span class="number">7</span> = 白色       <span class="variable">F =</span> 亮白色

如果没有给定任何参数，该命令会将颜色还原到 CMD.EXE 启动时
的颜色。这个值来自当前控制台窗口、/T 命令行开关或 
DefaultColor 注册表值。

如果用相同的前景和背景颜色来执行 COLOR 命令，COLOR 命令
会将 ERRORLEVEL 设置为 <span class="number">1</span>。

例如: <span class="string">"COLOR fc"</span> 在亮白色上产生亮红色
</code></pre><p>程序中，也可以通过 <code>system(&quot;color ... &quot;)</code> 调用color命令来实现改变控制台颜色的功能。</p>
<h3 id="彩色输出">彩色输出</h3><p>在Windows环境下，同样是通过调用WIN32 API来实现控制台程序的彩色输出。具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;windows.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">settextcolor</span><span class="params">(<span class="keyword">int</span> color)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，color的值定义在 wincon.h 中。多个颜色值可以综合在一起使用。具体颜色定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOREGROUND_BLUE	1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOREGROUND_GREEN	2</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOREGROUND_RED	4</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> FOREGROUND_INTENSITY	8</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BACKGROUND_BLUE	16</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BACKGROUND_GREEN	32</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BACKGROUND_RED	64</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BACKGROUND_INTENSITY	128</span></span><br></pre></td></tr></table></figure>
<p>多个值综合使用示例：(本质上为多个值得或运算)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), </span><br><span class="line">        FOREGROUND_GREEN|FOREGROUND_RED|FOREGROUND_INTENSITY);</span><br></pre></td></tr></table></figure>
<p>便可以在控制台将输出字符的颜色设置为黄色。</p>
<h2 id="Linux_平台">Linux 平台</h2><h3 id="控制光标定位-1">控制光标定位</h3><p>Linux环境下，控制台会解释ANSI转义序列，转义符是ESC，ASCII码为0x1b，因此，可以通过在中断输出转义序列来实现光标的定位，具体序列如下：</p>
<pre><code>Esc[<span class="keyword">Line</span>;Columnf
</code></pre><p>或</p>
<pre><code>Esc[<span class="keyword">Line</span>;ColumnH
</code></pre><p>应用举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c[%d;%df"</span>, <span class="number">0x1b</span>, y, x);</span><br><span class="line">    <span class="comment">// printf("%c[%d;%dH", 0x1b, y, x);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>: 光标位置的行和列都是从 <code>0</code> 开始索引。</p>
<p>转义序列列表：</p>
<ul>
<li>Esc[PnA 光标向上移动Pn行，如果光标已经处于最上方(the top line)，则忽略该转义序列。</li>
<li>Esc[PnB 光标向下移动Pn行，如果光标已经处于最下方(the buttom line)，则忽略该转义序列。</li>
<li>Esc[PnC 光标向右移动Pn行，如果光标已经处于最右处(the rightmost column)，则忽略该转义序列。</li>
<li>Esc[PnD 光标向左移动Pn行，如果光标已经处于最左处(the leftmost column)，则忽略该转义序列。</li>
<li>Esc[s 保存当前光标位置，之后可以通过恢复光标位置的转义序列回到被保存的光标位置。</li>
<li>Esc[u 恢复光标位置，将光标置于 Esc[s 序列保存的光标位置。</li>
<li>Esc[2J 清屏，将光标置于(0, 0)处(第一行第一列)。</li>
<li>Esc[K 删除从光标所在位置至当前行行末的所有字符，包括当前光标所在位置处的字符。</li>
<li>Esc[?25l 隐藏光标。</li>
<li>Esc[?25h 显示光标。</li>
</ul>
<h3 id="设置输出字符颜色">设置输出字符颜色</h3><p>同样，也可以通过输出控制符来控制输出字符的颜色，用法如下：</p>
<ul>
<li>Esc[Ps;Psm 设置图形模式(Set Graphics Mode)。第一个Ps的值为背景色的值，第二个Ps的值为前景色的值。</li>
</ul>
<p>背景色的颜色值范围为<code>40~49</code>，前景色的颜色值范围为<code>30-39</code>，具体颜色值如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Color</th>
<th style="text-align:center">Background</th>
<th style="text-align:center">Foreground</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">black</td>
<td style="text-align:center">40</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">red</td>
<td style="text-align:center">41</td>
<td style="text-align:center">31</td>
</tr>
<tr>
<td style="text-align:center">green</td>
<td style="text-align:center">42</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">yellow</td>
<td style="text-align:center">43</td>
<td style="text-align:center">33</td>
</tr>
<tr>
<td style="text-align:center">blue</td>
<td style="text-align:center">44</td>
<td style="text-align:center">34</td>
</tr>
<tr>
<td style="text-align:center">purple</td>
<td style="text-align:center">45</td>
<td style="text-align:center">35</td>
</tr>
<tr>
<td style="text-align:center">deep green</td>
<td style="text-align:center">46</td>
<td style="text-align:center">36</td>
</tr>
<tr>
<td style="text-align:center">white</td>
<td style="text-align:center">47</td>
<td style="text-align:center">37</td>
</tr>
</tbody>
</table>
<h3 id="其他转义序列控制">其他转义序列控制</h3><ul>
<li>Esc[0m 关闭所有属性。</li>
<li>Esc[1m 设置高亮度。</li>
<li>Esc[4m 下划线。</li>
<li>Esc[5m 闪烁。</li>
<li>Esc[7m 反显。</li>
<li>Esc[8m 消隐。</li>
</ul>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/01/programming language/c_cpp/gotoxy_colored_output/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/01/31/programming language/python/python_yield/">Python yield 关键字</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-01-30T16:00:00.000Z">2015-01-31</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/01/31/programming language/python/python_yield/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>Yield 表达式和声明仅仅用于定义一个“生成器(<code>generator</code>)”函数，并且仅仅用在“生成器”函数的函数体中。使用yield声明足以使得函数定义产生一个<code>generator</code>函数而非一个普通的函数。</p>
<blockquote>
<p>Yield expressions and statements are only used when defining a <code>generator</code> function, and are only used in the body of the generator function. Using yield in a function definition is sufficient to cause that definition to create a generator fun instead of a normal function.</p>
</blockquote>
<h2 id="The_yield_statement">The <code>yield</code> statement</h2><pre><code><span class="attribute">yield_stmt ::</span>=<span class="string"> yield_expression</span>
</code></pre><p><code>yield</code> 声明与yield表达式(<code>yield expression</code>) 在语义上等价。yield声明通常可以省略括号使用然而在yield表倒是中括号是必须的(required)。例如</p>
<pre><code><span class="keyword">yield</span> &lt;<span class="type">expr</span>&gt;
<span class="keyword">yield</span> <span class="keyword">from</span> &lt;<span class="type">expr</span>&gt;
</code></pre><p>和</p>
<pre><code>(<span class="keyword">yield</span> &lt;<span class="type">expr</span>&gt;)
(<span class="keyword">yield</span> <span class="keyword">from</span> &lt;<span class="type">expr</span>&gt;)
</code></pre><p>是等价的。</p>
<h2 id="Yield_expressions">Yield expressions</h2><pre><code><span class="string">yield_atom          :</span>:= <span class="string">"("</span> yield_expression <span class="string">")"</span>
<span class="string">yield_expression    :</span>:= <span class="string">"yield"</span> [expression_list] | <span class="string">"from"</span> expression]
</code></pre><p>当调用一个生成器函数时，返回一个生成器（迭代器）。然后这个生成器会控制生成器函数的执行。当生成器的一个方法被调用时生成器函数开始执行。</p>
<h2 id="Iterator和Generators">Iterator和Generators</h2><p>Iterator，迭代器，可以逐个地读取每一项。可以使用<code>for ... in ...</code>语句来操作可迭代对象。如list, str, tuple 等。</p>
<p>Generator，生成器，生成器同样是可迭代对象。但由于生成器是动态地生成值，并没有把所有制都放在内存中。因此，只能读取一次。</p>
<p>yield关键字产生生成器函数，其对象是生成器，可迭代。</p>
<h2 id="Generator-iterator_methods">Generator-iterator methods</h2><p>class generator</p>
<ul>
<li>generator.<strong>next</strong>()</li>
<li>generator.send()</li>
<li>generator.throw(type[, value[, traceback]])</li>
<li>generator.close()</li>
</ul>
<p>当第一次调用生成器的<strong>next</strong>() 方法时，函数执行并生成迭代器。如果调用生成器的<strong>next</strong>()方法，将会得到该生成器函数的下一个值。如果已经到达末尾，则抛出<code>StopIteration</code>异常。</p>
<p>如果调用生成器的send()方法，结果将会是send()方法传入的值。</p>
<p>yield 表达式可以用在 <code>try ... finally</code>结构的<code>try</code>部分中。当生成器的close()函数被调用时，<code>finally</code>语句块中的表达式会执行。</p>
<h2 id="Example">Example</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(bound)</span>:</span></span><br><span class="line">truea, b, n = <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">true<span class="keyword">while</span> n &lt; bound:</span><br><span class="line">true    <span class="keyword">yield</span> a</span><br><span class="line">true    a, b = b, a+b</span><br><span class="line">true    n += <span class="number">1</span></span><br><span class="line">true    </span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>g = fib(<span class="number">5</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>g.__next__()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>g.__next__()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>g.__next__()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>g.__next__()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">trueprint(i)</span><br><span class="line">true</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>由此，yield声明可以得到一个生成器函数。其类型为<code>&lt;class &#39;generator&#39;&gt;</code>。</p>
<p>yield 表示与 <code>try ... finally</code>语句块的运用:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(value = None):</span><br><span class="line">        print("Execution starts when 'next()' is called for the first time.")</span><br><span class="line">        try:</span><br><span class="line">            while True:</span><br><span class="line">                try:</span><br><span class="line">                    value = (yield value)</span><br><span class="line">                except Exception as e:</span><br><span class="line">                    value = e</span><br><span class="line">        finally:</span><br><span class="line">            print("Don't forget to clean up when 'close()' is called.")</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; g = func(1)</span><br><span class="line">&gt;&gt;&gt; g.__next__()</span><br><span class="line">Execution starts when 'next()' is called for the first time.</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(g.__next__())</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; g.close()</span><br><span class="line">Don't forget to clean up when 'close()' is called.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>读取文件时，如果直接对文件对象调用<code>read()</code>方法，会导致不可预测的内存占用，因此，常常需要用固定长度的缓冲区来不断读取文件内容。通过yield关键字，很容易实现文件的块读取。具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block_read</span><span class="params">(fpath, BLOCK_SIZE = <span class="number">1024</span>)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(fpath, mode = <span class="string">'rd'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            block = f.read(BLOCK_SIZE)</span><br><span class="line">            <span class="keyword">if</span> block:</span><br><span class="line">                <span class="keyword">yield</span> block</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h2 id="Reference">Reference</h2><ol>
<li><a href="">Python 34 Documentation</a></li>
</ol>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/01/31/programming language/python/python_yield/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/01/31/linux/cygwin-rebaseall/">Cygwin rebaseall</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-01-30T16:00:00.000Z">2015-01-31</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/01/31/linux/cygwin-rebaseall/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="Overview">Overview</h2><p>很多时候在升级Cygwin或安装Cygwin的软件包之后，加载dll会出错，或“fork()”出现错误，并提示“try rebaseall” , 此时，可以通过执行rebaseall命令来解决这些错误。</p>
<h2 id="Required">Required</h2><p>执行rebaseall命令，需要安装以下软件包</p>
<ol>
<li>dash (or ash)</li>
<li>rebase</li>
</ol>
<h2 id="Usage">Usage</h2><p>首先，需要暂停所有正在运行的Cygwin服务，可以通过在Cygwin的shell中执行如下命令获取当前正在运行的服务列表:</p>
<pre><code>cygrunsrv <span class="comment">--list </span>
</code></pre><p>关闭所有的Cygwin服务后，在Cygwin的安装目录下，找到/bin目录下的 <code>dash.exe</code> 或者 <code>ash.exe</code> 程序，右键，以管理员权限运行，然后在打开的shel中运行如下命令:</p>
<pre><code>/usr/bin/rebaseall -v
<span class="keyword">exit</span>
</code></pre><p><strong>Note</strong> 在运行rebasell时，可能会由于文件的权限问题而失败，可以将相关文件的权限设置为“可写”后重试。</p>
<h2 id="Reference">Reference</h2><ol>
<li><a href="http://cygwin.wikia.com/wiki/Rebaseall" target="_blank" rel="external">Cygwin Wiki</a></li>
</ol>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/01/31/linux/cygwin-rebaseall/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/01/25/algorithm/hihocoder1055_dp/">HihoCoder 1055 题解</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-01-24T16:00:00.000Z">2015-01-25</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/01/25/algorithm/hihocoder1055_dp/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="一、题目大意">一、题目大意</h2><p>树上每个点都有一个权值，找出与根节点连通的m个点，使得这m个点的权值之和最大。</p>
<p>题目链接: <a href="http://hihocoder.com/problemset/problem/1055" target="_blank" rel="external">HihoCoder 1055 刷油漆</a></p>
<h2 id="二、分析">二、分析</h2><h3 id="基本思路">基本思路</h3><p>树上的动态规划。</p>
<h3 id="具体解法">具体解法</h3><p>设<code>f[t][m]</code>表示以t为根节点，包括t节点在内的m个节点的权值总和的最大值，那么题目要求的便是<code>f[1][m]</code>的值。</p>
<p>假设t节点有孩子节点tc, 那么以tc为跟又可以构成一棵子树，并且在该子树上最多取m-1个节点，对于<code>f[t][m]</code>来说，有如下的状态转移方程:</p>
<p>$$ f[t][m] = max{f[t][m], f[t][m-m_tc]+f[tc][m_tc]} $$</p>
<p>其中，<code>m_tc</code>的取值范围为</p>
<p>$$ 1, 2, 3, …, m-1 $$</p>
<p>m的取值范围为</p>
<p>$$ m, m-1, m-2, …, 2 $$</p>
<p>由此，对整棵树进行一次后序遍历，每遍历玩一个根节点，便对该根节点做一次dp，由此，便可以得到<code>f[1][m]</code>的值。</p>
<h2 id="三、代码">三、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstdio&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Author: DHDave (buaahetao@gmai.com), SCSE, BUAA.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_n = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> v[max_n] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> graph[max_n][max_n];</span><br><span class="line"><span class="keyword">int</span> f[max_n][max_n]; <span class="comment">// f[t][j]以t为根的包括t在内的j个节点的得分</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    f[pos][<span class="number">1</span>] = v[pos];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != father &amp;&amp; graph[pos][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> mm = m; mm &gt;= <span class="number">2</span>; --mm) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m_tc = <span class="number">1</span>; m_tc &lt; mm; m_tc++) &#123;</span><br><span class="line">                    f[pos][mm] = max(f[pos][mm], </span><br><span class="line">                            f[pos][mm-m_tc] + f[i][m_tc]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> father)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != father &amp;&amp; graph[pos][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            post_order(i, pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(pos, father);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">true<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, v+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        graph[x][y] = graph[y][x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    post_order(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][m]);</span><br><span class="line">true<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* vim: set ts=4, sw = 4 */</span></span><br></pre></td></tr></table></figure>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/01/25/algorithm/hihocoder1055_dp/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>





<nav id="pagination">
  
    <a href="/page/3/" class="alignleft prev">上一页</a>
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright"><div class="padding">
	
	  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:dhdave.github.io">
  </form>
</div>
	
	  
<div class="widget recent-post">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2015/03/17/algorithm/backpack/">背包问题总结</a>
      </li>
    
      <li>
        <a href="/2015/02/28/programming language/haskell/dive_into_haskell_4_higher_order_function/">Dive Into Haskell(4) 高阶函数</a>
      </li>
    
      <li>
        <a href="/2015/02/26/algorithm/max_flow/">最大流算法</a>
      </li>
    
      <li>
        <a href="/2015/02/25/algorithm/gcd/">最大公约数算法</a>
      </li>
    
      <li>
        <a href="/2015/02/24/algorithm/binary_index_trees/">树状数组</a>
      </li>
    
  </ul>
</div>

	
	  
<div class="widget category">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Algorithm/">Algorithm</a><small>17</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>2</small></li>
  
    <li><a href="/categories/Math/">Math</a><small>4</small></li>
  
    <li><a href="/categories/Runtime/">Runtime</a><small>1</small></li>
  
    <li><a href="/categories/编程语言/">编程语言</a><small>14</small></li>
  
  </ul>
</div>

	
	  
<div class="widget tag">
  <h3 class="title">标签</h3>
  
    <a href="/tags/Algorithm/">Algorithm<small>17</small></a>
  
    <a href="/tags/C-C/">C/C++<small>4</small></a>
  
    <a href="/tags/CodeStyle/">CodeStyle<small>1</small></a>
  
    <a href="/tags/Cygwin/">Cygwin<small>1</small></a>
  
    <a href="/tags/Haskell/">Haskell<small>4</small></a>
  
    <a href="/tags/JNI/">JNI<small>1</small></a>
  
    <a href="/tags/JVM/">JVM<small>1</small></a>
  
    <a href="/tags/Javascript/">Javascript<small>1</small></a>
  
    <a href="/tags/Linux/">Linux<small>1</small></a>
  
    <a href="/tags/Mathematica/">Mathematica<small>4</small></a>
  
    <a href="/tags/Python/">Python<small>5</small></a>
  
</div>

	
</div></aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="padding">
	<div class="alignleft">
	  
	  &copy; 2015 DHDave
	  
	  Powerd by <a href="http://hexo.io/" target="_blank">hexo</a>
	  and Theme by <a href="https://github.com/halfer53/metro-light" target="_blank">metro-light</a>
	</div>

	<div class="alignright">
		
			<a href="https://plus.google.com/u/0/112661429129878562674/posts" target="_blank" title="DHDave Google Plus"><i class="fa fa-google-plus-square"></i></a>
		
		
			<a href="https://github.com/DHDave" target="_blank" title="DHDave Github"><i class="fa fa-github-square"></i></a>	
		
		
		
		
		
		
	</div>

	<div class="clearfix"></div>
</div>

<div class="scroll-top"><i class="fa fa-arrow-circle-up"></i></div>
</footer>
  

		<script type="text/javascript">
		var disqus_shortname = 'dhdavegithubiodhdave-github-io';

		        (function() {
		            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		        })();
		</script>

		<script type="text/javascript">
		var disqus_shortname = 'dhdavegithubiodhdave-github-io'; 

		(function () {
		var s = document.createElement('script'); s.async = true;
		s.type = 'text/javascript';
		s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
		(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
		}());
		</script>

  


<script src="//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/3.0.4/jquery.imagesloaded.js"></script>
<script src="/js/gallery.js"></script>



<script type="text/javascript">
$(window).scroll(function() {

    if($(this).scrollTop() > 400) {
        $('.scroll-top').fadeIn(200);
    } else {
        $('.scroll-top').fadeOut(200);
    }
});

$('.scroll-top').bind('click', function(e) {
    e.preventDefault();
    $('body,html').animate({scrollTop:0},200);
});
</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
