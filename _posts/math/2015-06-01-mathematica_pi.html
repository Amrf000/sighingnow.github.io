---
title: 几种求解PI的概率算法的探究和对比
author: He Tao
date: 2015-06-01
tag: Mathematica
category: Math
layout: post
---

<p><span class="math">\(\pi\)</span>是一个重要的随机数，在数学研究中占有重要地位。求解PI的数值值也一直是数学研究的经典问题之一。本文将主要探讨几种求解PI的概率算法的原理和实现，并对比其效率和准确度。</p>
<h2 id="一mathematica中的pi">一、Mathematica中的<span class="math">\(\pi\)</span></h2>
<p>我们发现，在Mathematica中可以使用<span class="math">\(\pi\)</span>来做符号运算，很多运算都涉及到非常高深的数学知识，使用N[Pi, n]函数也能够求得<span class="math">\(\pi\)</span>的前n位数值解。那么为什么Mathematica能够以如此高的精度求解<span class="math">\(\pi\)</span>的值呢？</p>
<p>通过查阅Mathematica的文档，得知，Mathematica求解<span class="math">\(\pi\)</span>使用的是Chudnovsky公式，因其具有很好的收敛速度而在数值计算中被广泛采用。Chudnovsky 算法的表述如下：</p>
<p><span class="math">\[ \frac{1}{\pi} = 12\sum_{k=0}^{\infty} \frac{(-1)^k(6k)! (163\cdot 3344418k + 13591409)}{(3k)!(k!)^3(640320^3)^{k+1/2}} \]</span></p>
<p>根据这个公式，可以编写如下Mathematica代码：</p>
<pre class="sourceCode mathematica"><code class="sourceCode mathematica">chud[<span class="dt">n_</span>] := <span class="fu">N</span>[<span class="dv">1</span>/(<span class="dv">12</span>*<span class="fu">Sum</span>[
    ((-<span class="dv">1</span>)^<span class="fu">k</span>*(<span class="dv">6</span> <span class="fu">k</span>)!*(<span class="dv">13591409</span> + <span class="dv">545140134</span> <span class="fu">k</span>))/
    ((<span class="dv">3</span> <span class="fu">k</span>)!*(<span class="fu">k</span>!)^<span class="dv">3</span>*<span class="dv">640320</span>^(<span class="dv">3</span> <span class="fu">k</span> + <span class="dv">3</span>/<span class="dv">2</span>)), 
    {<span class="fu">k</span>, <span class="dv">0</span>, <span class="fu">n</span>}], <span class="dv">5</span>];
]);</code></pre>
<p>运行如下命令：</p>
<pre><code>chud[1] // N</code></pre>
<p>将会输出</p>
<pre><code>3.14159</code></pre>
<p>可见，Chudnovsky算法确实具有非常好的收敛性能。</p>
<h2 id="二普通蒙特卡洛方法">二、普通蒙特卡洛方法</h2>
<p>普通蒙特卡洛(Monte Carlo)方法求解<span class="math">\(\pi\)</span>的值，是指每次随机产生一个在<span class="math">\(2\times 2\)</span>的正方形中的点，统计这个点在该正方形的内接圆里的概率<span class="math">\(p\)</span>。圆周率<span class="math">\(\pi\)</span>的估计值为<span class="math">\(4p\)</span>。算法原理和实现都很简单，Mathematica代码如下(此处，仅仅统计在第一象限内的随机点的分布情况)：</p>
<pre class="sourceCode mathematica"><code class="sourceCode mathematica">mc[<span class="dt">n_</span>] := <span class="fu">Module</span>[
    {
        <span class="fu">in</span> = <span class="dv">0</span>, 
        <span class="fu">total</span> = <span class="dv">0</span>
    },
    <span class="fu">For</span>[<span class="fu">k</span>=<span class="dv">1</span>,<span class="fu">k</span>&lt;=<span class="fu">n</span>,<span class="fu">k</span>=<span class="fu">k</span><span class="dv">+1</span>,
        <span class="fu">x</span>=<span class="fu">RandomReal</span>[];
        <span class="fu">y</span>=<span class="fu">RandomReal</span>[];
        <span class="fu">total</span>=<span class="fu">total</span><span class="dv">+1</span>;
        <span class="fu">If</span>[<span class="fu">x</span>*<span class="fu">x</span>+<span class="fu">y</span>*<span class="fu">y</span>&lt;=<span class="dv">1</span>,<span class="fu">in</span>=<span class="fu">in</span><span class="dv">+1</span>]
    ];
    <span class="fu">N</span>[<span class="fu">in</span>/<span class="fu">total</span>*<span class="dv">4</span>, <span class="dv">5</span>]
];</code></pre>
<p>重复运行1000000次随机：</p>
<pre><code>Print[mc[1000000]];</code></pre>
<p>得到如下的<span class="math">\(\pi\)</span>的近似值的序列：</p>
<pre><code>3.1432  3.1423  3.1399  3.1397  3.1429</code></pre>
<p>可见，蒙特卡洛随机化算法的准确性还是比较高的。使用点落在圆内的概率来模拟<span class="math">\(\pi\)</span>的值也是很正确的选择。</p>
<h2 id="三随机数互质的概率">三、随机数互质的概率</h2>
<p>接下来采用另一种概率算法来计算<span class="math">\(\pi\)</span>的近似值。这个算法不同于之前的蒙特卡洛、蒲风投针等随机算法模型，也不同于通过迭代来计算<span class="math">\(\pi\)</span>的近似值的算法模型。</p>
<p>这一算法的依据是：两个随机正整数<span class="math">\(a\)</span>,<span class="math">\(b\)</span>互质的概率为<span class="math">\(\frac{6}{\pi^2}\)</span>。这一性质的证明过程如下：</p>
<ol style="list-style-type: decimal">
<li>设两个数<span class="math">\(u\)</span>,<span class="math">\(v\)</span>互质的概率为<span class="math">\(p\)</span>，则<span class="math">\(gcd(u,v)=d\)</span>当且仅当<span class="math">\(d|u\)</span>,<span class="math">\(d|v\)</span>，<span class="math">\(gcd(u/d,v/d)=1\)</span>。</li>
<li>因此，任两个数最大公约数为d的概率为<span class="math">\(p/d/d\)</span>，即<span class="math">\(p/(d^2)\)</span>。</li>
<li>在正整数集合上有<span class="math">\(p+p/4+p/9+ \dots +p/(n^2)+ \dots = 1\)</span>，容易求得<span class="math">\(p=\frac{6}{\pi^2}\)</span>。</li>
</ol>
<p>利用这一性质，只需要采取如下做法：</p>
<p>取一大整数<span class="math">\(N\)</span>,在<span class="math">\(1\)</span>到<span class="math">\(N\)</span>之间随机地取一对整数<span class="math">\(a\)</span>,<span class="math">\(b\)</span>,找到它们的最大公约数<span class="math">\((a,b)\)</span>,做<span class="math">\(n\)</span>次这样的实验,记录<span class="math">\((a,b)=1\)</span>的情况次数<span class="math">\(m\)</span>,计算出<span class="math">\(p=\frac{m}{n}\)</span>的值。便可以计算出<span class="math">\(\pi\)</span>的近似值。</p>
<p>该算法的Mathematica实现如下：</p>
<pre class="sourceCode mathematica"><code class="sourceCode mathematica">(* 此处采用本机Mathematica的Machine ID作为随机数的最大范围: *)
(*        <span class="dv">6102-90797-51506</span> *)

primep[<span class="dt">n_</span>] := <span class="fu">Module</span>[
    {
        (* maximum <span class="fu">range</span> of random <span class="fu">number</span>. *)
        machineid = <span class="dv">61029079751506</span>, 
        is = <span class="dv">0</span>,
        <span class="fu">total</span> = <span class="dv">0</span>
    },
    <span class="fu">For</span>[<span class="fu">k</span> =<span class="dv">1</span>, <span class="fu">k</span> &lt;= <span class="fu">n</span>, <span class="fu">k</span> = <span class="fu">k</span><span class="dv">+1</span>,
        <span class="fu">total</span> = <span class="fu">total</span> + <span class="dv">1</span>;
        <span class="fu">x</span> = <span class="fu">RandomInteger</span>[{<span class="dv">1</span>, machineid}];
        <span class="fu">y</span> = <span class="fu">RandomInteger</span>[{<span class="dv">1</span>, machineid}];
        <span class="fu">If</span>[<span class="fu">GCD</span>[<span class="fu">x</span>,<span class="fu">y</span>]==<span class="dv">1</span>, is = is<span class="dv">+1</span>]
    ];
    <span class="fu">N</span>[<span class="fu">Sqrt</span>[<span class="dv">6</span>/(is/<span class="fu">total</span>)], <span class="dv">5</span>]
];</code></pre>
<p>重复运行：</p>
<pre><code>For[i=1,i&lt;=5,i=i+1,Print[primep[1000000]]];</code></pre>
<p>得到如下的结果序列：</p>
<pre><code>3.1408  3.1407  3.1408  3.1398  3.1419</code></pre>
<p>总的来看，结果的分布还是相当不错的，作为一个随机概率算法，有如此的准确性已经相当不容易了。</p>
<h2 id="四对比">四、对比</h2>
<p>画图分析<span class="math">\(\pi\)</span>, Chudnovsky算法，普通蒙特卡洛算法，整数互质概率算法这四种求解<span class="math">\(\pi\)</span>的数值值得结果：</p>
<pre class="sourceCode mathematica"><code class="sourceCode mathematica"><span class="fu">n</span> = <span class="dv">10</span>;
pis = <span class="fu">Table</span>[<span class="fu">N</span>[<span class="fu">Pi</span>, <span class="dv">5</span>], {<span class="fu">k</span>, <span class="dv">1</span>, <span class="fu">n</span>}];
chuds = <span class="fu">Table</span>[chud[<span class="fu">k</span>], {<span class="fu">k</span>, <span class="dv">1</span>, <span class="fu">n</span>}];
mcs = <span class="fu">Table</span>[mc[<span class="fu">Prime</span>[<span class="dv">2</span>^<span class="fu">k</span>]], {<span class="fu">k</span>, <span class="dv">1</span>, <span class="fu">n</span>}];
primeps = <span class="fu">Table</span>[primep[<span class="fu">Prime</span>[<span class="dv">2</span>^<span class="fu">k</span>]], {<span class="fu">k</span>, <span class="dv">1</span>, <span class="fu">n</span>}];
<span class="fu">Print</span>[pis];
<span class="fu">Print</span>[chuds];
<span class="fu">Print</span>[mcs];
<span class="fu">Print</span>[primeps];
<span class="fu">ListLinePlot</span>[{pis, chuds, mcs, primeps}, 
    <span class="fu">AxesOrigin</span> -&gt; {<span class="dv">0</span>, <span class="dv">0</span>}, 
    <span class="fu">PlotRange</span> -&gt; {<span class="dv">0</span>, <span class="dv">4</span>}
]</code></pre>
<p>如下图所示：</p>
<div class="figure">
<img src="{{site.url}}/resource/mathematica_pi/image.png" alt="结果对比图" />
<p class="caption">结果对比图</p>
</div>
<p>通过图像对比，不难看出Chudnovsky算法的高效和精确。在保留5位小数的情况下，Chudnovsky算法得到的结果和Mathematica自身算出来的结果已经重合，Chudnovsky算法仅仅做了一次迭代！</p>
<p>对比两种概率算法的结果，我们发现尽管是不同的概率模型，但由于其理论概率的保证，最终仍然都会收敛到<span class="math">\(\pi\)</span>的精确数值值。初期，you’yu基于整数互质概率的方法得到的结果偏离实际情况过大，这也与随机整数的因数分布有关系，而当迭代次数增大时，这个方法得到的结果似乎要优于朴素蒙特卡洛方法的结果。这也启示我们，除了使用面积等古典概率模型来进行数值模拟计算以外，数学上其他方面的一些理论成果也很有借鉴意义。</p>
<h2 id="五参考文献">五、参考文献</h2>
<ol style="list-style-type: decimal">
<li><a href="https://en.wikipedia.org/wiki/Chudnovsky_algorithm">Chudnovsky algorithm</a></li>
<li><a href="http://reference.wolfram.com/language/tutorial/SomeNotesOnInternalImplementation.html">WOLFRAM语言教程-关于内部实现的一些注释</a></li>
</ol>
<h2 id="六附录mathematica代码">六、附录：Mathematica代码</h2>
<pre class="sourceCode mathematica"><code class="sourceCode mathematica">(* Chudnovsky algorithm*)
chud[<span class="dt">n_</span>] := <span class="fu">N</span>[<span class="dv">1</span>/(<span class="dv">12</span>*<span class="fu">Sum</span>[
    ((-<span class="dv">1</span>)^<span class="fu">k</span>*(<span class="dv">6</span> <span class="fu">k</span>)!*(<span class="dv">13591409</span> + <span class="dv">545140134</span> <span class="fu">k</span>))/
    ((<span class="dv">3</span> <span class="fu">k</span>)!*(<span class="fu">k</span>!)^<span class="dv">3</span>*<span class="dv">640320</span>^(<span class="dv">3</span> <span class="fu">k</span> + <span class="dv">3</span>/<span class="dv">2</span>)), 
    {<span class="fu">k</span>, <span class="dv">0</span>, <span class="fu">n</span>}], <span class="dv">5</span>];
]);

(* Monte Carlo *)
mc[<span class="dt">n_</span>] := <span class="fu">Module</span>[
    {
        <span class="fu">in</span> = <span class="dv">0</span>, 
        <span class="fu">total</span> = <span class="dv">0</span>
    },
    <span class="fu">For</span>[<span class="fu">k</span>=<span class="dv">1</span>,<span class="fu">k</span>&lt;=<span class="fu">n</span>,<span class="fu">k</span>=<span class="fu">k</span><span class="dv">+1</span>,
        <span class="fu">x</span>=<span class="fu">RandomReal</span>[];
        <span class="fu">y</span>=<span class="fu">RandomReal</span>[];
        <span class="fu">total</span>=<span class="fu">total</span><span class="dv">+1</span>;
        <span class="fu">If</span>[<span class="fu">x</span>*<span class="fu">x</span>+<span class="fu">y</span>*<span class="fu">y</span>&lt;=<span class="dv">1</span>,<span class="fu">in</span>=<span class="fu">in</span><span class="dv">+1</span>]
    ];
    <span class="fu">N</span>[<span class="fu">in</span>/<span class="fu">total</span>*<span class="dv">4</span>, <span class="dv">5</span>]
];

(* <span class="fu">Prime</span> model *)
primep[<span class="dt">n_</span>] := <span class="fu">Module</span>[
    {
        (* maximum <span class="fu">range</span> of random <span class="fu">number</span>. *)
        machineid = <span class="dv">61029079751506</span>, 
        is = <span class="dv">0</span>,
        <span class="fu">total</span> = <span class="dv">0</span>
    },
    <span class="fu">For</span>[<span class="fu">k</span> =<span class="dv">1</span>, <span class="fu">k</span> &lt;= <span class="fu">n</span>, <span class="fu">k</span> = <span class="fu">k</span><span class="dv">+1</span>,
        <span class="fu">total</span> = <span class="fu">total</span> + <span class="dv">1</span>;
        <span class="fu">x</span> = <span class="fu">RandomInteger</span>[{<span class="dv">1</span>, machineid}];
        <span class="fu">y</span> = <span class="fu">RandomInteger</span>[{<span class="dv">1</span>, machineid}];
        <span class="fu">If</span>[<span class="fu">GCD</span>[<span class="fu">x</span>,<span class="fu">y</span>]==<span class="dv">1</span>, is = is<span class="dv">+1</span>]
    ];
    <span class="fu">N</span>[<span class="fu">Sqrt</span>[<span class="dv">6</span>/(is/<span class="fu">total</span>)], <span class="dv">5</span>]
];

(* <span class="fu">plot</span> *)
<span class="fu">n</span> = <span class="dv">10</span>;
pis = <span class="fu">Table</span>[<span class="fu">N</span>[<span class="fu">Pi</span>, <span class="dv">5</span>], {<span class="fu">k</span>, <span class="dv">1</span>, <span class="fu">n</span>}];
chuds = <span class="fu">Table</span>[chud[<span class="fu">k</span>], {<span class="fu">k</span>, <span class="dv">1</span>, <span class="fu">n</span>}];
mcs = <span class="fu">Table</span>[mc[<span class="fu">Prime</span>[<span class="dv">2</span>^<span class="fu">k</span>]], {<span class="fu">k</span>, <span class="dv">1</span>, <span class="fu">n</span>}];
primeps = <span class="fu">Table</span>[primep[<span class="fu">Prime</span>[<span class="dv">2</span>^<span class="fu">k</span>]], {<span class="fu">k</span>, <span class="dv">1</span>, <span class="fu">n</span>}];
<span class="fu">Print</span>[pis];
<span class="fu">Print</span>[chuds];
<span class="fu">Print</span>[mcs];
<span class="fu">Print</span>[primeps];
<span class="fu">ListLinePlot</span>[{pis, chuds, mcs, primeps}, 
    <span class="fu">AxesOrigin</span> -&gt; {<span class="dv">0</span>, <span class="dv">0</span>}, 
    <span class="fu">PlotRange</span> -&gt; {<span class="dv">0</span>, <span class="dv">4</span>}
]</code></pre>
<!---------------------------------------links-------------------------->
