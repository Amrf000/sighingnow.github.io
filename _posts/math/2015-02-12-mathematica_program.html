---
title: Mathematica 编程
author: He Tao
date: 2015-02-12
tag: Mathematica
category: Math
layout: post
---

<h2 id="赋值方式">赋值方式</h2>
<p>Mathematica提供了两种类型的赋值方式。</p>
<h3 id="即时赋值">即时赋值</h3>
<p>即时赋值是指在赋值时就对值进行计算，即时赋值用<code>=</code>表示。例如：</p>
<pre><code>var = value</code></pre>
<p>在赋值时就计算出<code>value</code>的值。</p>
<h3 id="延迟赋值">延迟赋值</h3>
<p>延迟赋值是指调用赋值语句时（使用被赋值的变量时）才对值进行计算，并且在每次调用时，其值都会重新计算。延迟赋值用<code>:=</code>表示。例如：</p>
<pre><code>var := value</code></pre>
<p>在调用<code>var</code>是才计算<code>value</code>的值。</p>
<h3 id="清除赋值">清除赋值</h3>
<p>使用如下语法可以做到清除赋值：</p>
<pre><code>x = .
t = .</code></pre>
<p>这样处理以后，<code>x</code>, <code>t</code>都会重新成为一个没有值得符号。</p>
<!--more-->
<h3 id="赋值与计算">赋值与计算</h3>
<p>如果想要计算表达式的值，但又不想给变量赋值，可以使用<code>/.</code>符号。例如：</p>
<pre><code>x^2+2*x+1 /. x-&gt;2
9
?x
Global `x</code></pre>
<p>表明，表达式<code>x^2+2*x+1</code>的值已经计算出来，但<code>x</code>仍未被赋值。</p>
<p><code>/.</code>的详细用法：</p>
<pre><code>expr/.rules
    应用一个规则或规则列表尽可能转换一个表达式 expr 的每个子部分.</code></pre>
<p><code>/.</code>符号也可以被用于表达式的整体替换。</p>
<h3 id="立即赋值与延迟赋值的例子">立即赋值与延迟赋值的例子</h3>
<p>以如下代码为例：</p>
<pre class="mma"><code>a = Expand[x^2]
b := Expand[x^2]
x = u+v
Print[a]
Print[b]</code></pre>
<p>这段程序运行的输出如下所示：</p>
<pre><code>a = (u+v)^2
b = u^2+2uv+v^2</code></pre>
<p>可见，在用<code>u+v</code>替换<code>x</code>之前，<code>a</code>就已经展开了，而<code>b</code>还没有展开。展开<code>b</code>时，已经用<code>(u+v)</code>替换了<code>x</code>，所以实际上是展开<code>(u+v)^2</code>。因此，会看到这样的结果。</p>
<h2 id="循环语句">循环语句</h2>
<p>Mathematica中，循环结构有Do命令，For命令，While，Table 命令三种实现方式，此外，Sum 函数和 Product 函数也具有对指定序列循环求值（和或差）的功能。</p>
<h3 id="sum-和-product">Sum 和 Product</h3>
<p><code>Sum</code> 和 <code>Product</code> 函数都可以通过一组指定的首尾和步长(可选)求出一个序列的和或积。并且支持符号运算。</p>
<p>例如：</p>
<p>求前100个素数的和：</p>
<pre><code>Sum[Prime[k], {k, 1, 100, 1}]</code></pre>
<p>求从1-n的整数的平方和的一般公式：</p>
<pre><code>Sum[k^2, {k, 1, n, 1}]
(* 可以得到结果：n*(n+1)*(2*n+1)/6 *)</code></pre>
<p>求无穷和 1+1/2+1/4+1/8+1/16+…</p>
<pre><code>Sum[1/(2^i), {i, 0, Infinity, 1}]
(* 可以得到结果为 2 *)

(* Infinity 表示正的无穷大 *)</code></pre>
<h3 id="do-命令">Do 命令</h3>
<p>Do命令的用法同Sum和Product函数类似（可以认为Sum和Product是Do命令的特例），给出文档中Do命令的用法：</p>
<ul>
<li><p>Do[expr,{Subscript[i, max]}]</p>
<p>对 expr 计算 imax 次.</p></li>
<li><p>Do[expr,{i,Subscript[i, max]}]</p>
<p>将变量 i 从 1 递增到 Subscript[i, max]（步长为 1），计算 expr.</p></li>
<li><p>Do[expr,{i,Subscript[i, min],Subscript[i, max]}]</p>
<p>从 i=Subscript[i, min] 开始.</p></li>
<li><p>Do[expr,{i,Subscript[i, min],Subscript[i, max],di}]</p>
<p>使用步长 di.</p></li>
<li><p>Do[expr,{i,{Subscript[i, 1],Subscript[i, 2],[Ellipsis]} }]</p>
<p>使用连续的值 Subscript[i, 1]，Subscript[i, 2]，[Ellipsis].</p></li>
<li><p>Do[expr,{i,Subscript[i, min],Subscript[i, max]},{j,Subscript[j, min],Subscript[j, max]},[Ellipsis]]</p>
<p>对每一个 i 循环地根据不同的 j 等，计算 expr.</p></li>
</ul>
<h3 id="while-命令">While 命令</h3>
<p>While命令的用法如下：</p>
<ul>
<li><p>While[test,body]</p>
<p>重复计算 test，然后是 body，直到 test 第一次不能给出 True.</p></li>
</ul>
<h3 id="for-命令">For 命令</h3>
<p>For命令的用法如下：</p>
<ul>
<li><p>For[start,test,incr,body]</p>
<p>执行 start，然后重复计算 body 和 incr，直到 test 不能给出 True.</p></li>
</ul>
<h3 id="table-命令">Table 命令</h3>
<p>Table 命令用于生产表达式的列表。Table 命令的用法如下：</p>
<ul>
<li><p>Table[expr,{Subscript[i, max]}]</p>
<p>产生一个 expr 的 Subscript[i, max] 拷贝的列表.</p></li>
<li><p>Table[expr,{i,Subscript[i, max]}]</p>
<p>产生i 从1到 Subscript[i, max] 的一个 expr 的值的列表.</p></li>
<li><p>Table[expr,{i,Subscript[i, min],Subscript[i, max]}]</p>
<p>以 i=Subscript[i, min] 开始.</p></li>
<li><p>Table[expr,{i,Subscript[i, min],Subscript[i, max],di}]</p>
<p>使用步长 di.</p></li>
<li><p>Table[expr,{i,{Subscript[i, 1],Subscript[i, 2],[Ellipsis]} }]</p>
<p>使用连续值 Subscript[i, 1], Subscript[i, 2], [Ellipsis].</p></li>
<li><p>Table[expr,{i,Subscript[i, min],Subscript[i, max]},{j,Subscript[j, min],Subscript[j, max]},[Ellipsis]]</p>
<p>给出一个嵌套列表. 和 i 相关联的列表是最外的列表.</p></li>
</ul>
<h2 id="分支结构">分支结构</h2>
<p>Mathematica中，分支控制主要有If、Which、Switch 等命令实现。</p>
<h3 id="if命令的用法如下">If命令的用法如下：</h3>
<ul>
<li><p>If[condition,t,f]</p>
<p>如果 condition 计算为 True 给出 t，如果它计算为 False 给出 f.</p></li>
<li><p>If[condition,t,f,u]</p>
<p>如果 condition 计算既不为 True 也不为 False 给出 u.</p></li>
</ul>
<h3 id="which-命令">Which 命令</h3>
<p>Which命令的用法如下：</p>
<ul>
<li><p>Which[test1,value1,test2,value,…</p>
<p>依次计算每个 testi ，返回相应于产生 True 的第一个valuei的值.</p></li>
</ul>
<h3 id="switch-命令">Switch 命令</h3>
<ul>
<li><p>Switch[expr, form1, value1, form2, value2, …]</p>
<p>计算 expr，然后依次和每个 formi 比较，计算并返回相应于找到的第一个匹配的valuei].</p></li>
</ul>
<h2 id="函数与模式">函数与模式</h2>
<ol style="list-style-type: decimal">
<li><code>Cases</code>命令，查找列表中匹配模式的表达式。</li>
</ol>
<pre class="mma"><code>In:= Cases[{f[1], g[2], f[5], g[4]}, f[_]]
Out= {f[1], f[5]}</code></pre>
<p>此处，<code>_</code>(blank)用来代表任意表达式。</p>
<ol start="2" style="list-style-type: decimal">
<li><code>x_</code>(<code>x:_</code>的缩写)，代表一个模式，将其值命名为<code>x</code>:</li>
</ol>
<pre class="mma"><code>In:= Replace[f[100], f[x_] -&gt; x+5]
Out= 105</code></pre>
<p><code>-&gt;</code>用来指定规则。</p>
<ol start="3" style="list-style-type: decimal">
<li><code>./</code>表示匹配模式并全部替代。</li>
</ol>
<pre class="mma"><code>In:= {f[1], g[2], f[4], g[4]} ./ f[x_] -&gt; x+5
Out= {6, g[2], 9, g[4]}</code></pre>
<p>2 4. <code>__</code>(两个blank)代表<strong>任意表达式</strong>。例如：</p>
<pre class="mma"><code>fIn:= Cases[{f[1,2],f[1],g[3]}, f[__]]
Out= {f[1,2],f[1]}</code></pre>
<ol start="5" style="list-style-type: decimal">
<li><code>a|b|c</code>代表<code>a</code>、<code>b</code>或<code>c</code>。例如：</li>
</ol>
<pre class="mma"><code>In:= Cases[{f[1],g[2],f[3],f[5]}, f[1|3]]
Out= {f[1],f[3]}
In:= Cases[{f[1],g[1],f[3],f[5]}, (f|g)[1]]
Out= {f[1],g[1]}</code></pre>
<ol start="6" style="list-style-type: decimal">
<li><code>_h</code>代表任何具有标头<code>h</code>的表达式。例如：<!--没太看明白这个“标头”的含义--></li>
</ol>
<pre class="mma"><code>In:= Cases[{1, 2, 3.5, 6}, _Real]
Out= {1, 2, 6}</code></pre>
<ol start="7" style="list-style-type: decimal">
<li><code>:&gt;</code>是一个延迟规则，类似于规则中的<code>:=</code>。</li>
</ol>
<p>从上面几个例子中可以看出函数式编程中模式匹配的强大威力。</p>
<h2 id="定义数学函数">定义数学函数</h2>
<h3 id="定义普通单变量函数">定义普通单变量函数</h3>
<p>定义函数是实现编程的重要基础性功能。在Mathematica中，可以通过以下方式定义函数。</p>
<p>同样，在函数定义中，也可以使用“即时赋值”和“延迟赋值”这两种赋值方式。</p>
<p>加入需要定义一个单变量函数<code>f</code>，以<code>x</code>为变量，可以写为如下形式：</p>
<pre><code>f[x_] = ...</code></pre>
<p>或者</p>
<pre><code>f[x_] := ...</code></pre>
<h3 id="分段函数">分段函数</h3>
<p>分段函数可以用<code>/;condition</code>来定义。即输入：</p>
<pre><code>f[x_] := expr /; condition</code></pre>
<p>就会使当且仅当条件值为真时，<code>f[x]</code>的值为表达式。</p>
<p><strong>注意</strong>：在此情形下，必须使用<code>:=</code>赋值符号。</p>
<h3 id="定义多变量函数">定义多变量函数</h3>
<p>在Mathematica中，定义多变量函数的方式同定义单变量函数类似：</p>
<pre><code>f[x_, y_] = ...</code></pre>
<p>例如：</p>
<pre><code>f[x_, y_] = x^2 + y^2</code></pre>
<h2 id="数学函数的运算">数学函数的运算</h2>
<p>如果 <code>f</code>,<code>g</code>为具有相同定义域<code>D</code>的函数，那么就可以逐点定义他们的和、差、积、商。</p>
<h2 id="数学函数的复合">数学函数的复合</h2>
<p>如果<code>x</code>在<code>g</code>的定义域内，而<code>g(x)</code>在<code>f</code>的定义域内，那么就可以定义复合函数</p>
<pre><code>f(g(x))</code></pre>
<p>此外，函数的复合还可以用 <code>Composition</code> 命令实现，用法如下：</p>
<pre><code>Composition[f, g, h, ... ] 表示函数 f、g、h、... 的复合. </code></pre>
<p>还有如下两个命令也可以用于函数的复合：</p>
<ul>
<li><p><code>Nest</code> 命令</p>
<pre><code>Nest[f,expr,n] 返回一个将 f 作用于 expr 上 n 次后得到的表达式.</code></pre></li>
<li><p><code>NestList</code> 命令</p>
<pre><code>NestList[f,expr,n] 将 f 作用于 expr 上 0 到 n 次，给出结果列表.</code></pre></li>
</ul>
<p>通过以上几种方式，就可以实现函数的复合。</p>
<h2 id="mathematica编程中的范围结构">Mathematica编程中的范围结构</h2>
<p>Mathematica中，程序的范围结构可以由<code>Module</code>、<code>With</code>、<code>Block</code>这三种方式实现。</p>
<h3 id="module">Module</h3>
<p>在Mathematica中，缺省情况下，所有对象（变量等）都是全局性的。通过模块可以定义局部变量，局部变量只在模块内有定义，在模块外面，同名对象可能就没有定义，或者具有完全不同的值。</p>
<p>通过以下语法定义模块：</p>
<ul>
<li><p>Module[{x,y,…},expr]</p>
<p>指定在 expr 中出现的符号 x、y、… 应被当作局部值.</p></li>
<li><p>Module[{x=x0, y=y0, … expr]</p>
<p>用来定义 x, y, … 的初始值.</p></li>
</ul>
<h3 id="with">With</h3>
<p>With命令的用法如下：</p>
<ul>
<li><p>With[{x=x0, y=y0, …},expr]</p>
<p>指定在 expr 中出现的符号 x、y、… 应当由 x0、y0、… 替换. </p></li>
</ul>
<h3 id="block">Block</h3>
<ul>
<li><p>Block[{x,y,…,expr]</p>
<p>指定用符号 x、y、… 的局部值计算 expr.</p></li>
<li><p>Block[{x=x0,…},expr]</p>
<p>给 x，… 赋初始局部值.</p></li>
</ul>
<h3 id="block-与-module的区别">Block 与 Module的区别</h3>
<ul>
<li><code>Module</code>: 使用词法作用域（局部化名称）</li>
<li><code>Block</code>: 使用动态作用域（局部化值）</li>
<li><code>DynamicModule</code>: 使用文档中的作用域。</li>
</ul>
<p>以下关于<code>Block</code>和<code>Module</code>的区别，引述下面一段Mathematica文档中的陈述和示例：</p>
<blockquote>
<p>块与模块的比较</p>
</blockquote>
<blockquote>
<p>当进行 Mathematica 编程时，应当尽量使它的项相互独立，这样程序就容易理解、维护和扩充.</p>
</blockquote>
<blockquote>
<p>保证程序中不同相相互不影响的一个重要途径是给它的变量一定的“范围”. Mathematica 用模块和块这两种机制来限制变量的范围.</p>
</blockquote>
<blockquote>
<p>在实际编程时，模块远远比块常用，而在相互作用的计算中需要确定范围时，往往是块比较方便.</p>
</blockquote>
<pre><code>Module[vars,body]   词汇（lexical）定界
Block[vars,body]    动态定界</code></pre>
<blockquote>
<p>Mathematica 变量的定界机理.</p>
</blockquote>
<blockquote>
<p>大部分计算机语言使用与 Mathematica 模块类似的词汇定界机理. 一些像LISP等符号计算语言与 Mathematica 块类似的动态定界机理.</p>
</blockquote>
<blockquote>
<p>在使用词汇定界时，变量在一个程序中的一个代码段被作为局部变量. 在动态定界时，在程序执行历史的一部分被作为局部值.</p>
</blockquote>
<blockquote>
<p>在 C 和 Java 等编译语言中， 它们的变量在使用之前就要声明类型，因此在编译前就已经确定了变量的类型；“代码”和“执行历史”之间的区分非常明显. 而 Mathematica 属于动态类型语言，它的符号特性使这个区别不明显，其原因是代码在程序的执行过程中可以动态地生成.</p>
</blockquote>
<blockquote>
<p>Module[vars,body] 的作用是在模块作为 Mathematica 的代码被执行时处理表达式 body 的形式，当任何 vars 明显地出现在代码中时，就被当作局部变量.</p>
</blockquote>
<blockquote>
<p>Block[vars,body] 不注意表达式 body 的形式. 而是，在 body 的全局计算过程中使用 vars 的局部值.</p>
</blockquote>
<blockquote>
<p>通过 i 来定义 m.</p>
</blockquote>
<pre><code>In[1]:= m = i^2

Out[1]=  i^2</code></pre>
<blockquote>
<p>在块内 i+m 的计算过程中，i 用了局部值.</p>
</blockquote>
<pre><code>In[2]:= Block[{i = a}, i + m]

Out[2]=  a + a^2</code></pre>
<blockquote>
<p>这里仅明显出现在 i+m 中的 i 被当作局部变量处理.</p>
</blockquote>
<pre><code>In[3]:= Module[{i = a}, i + m]

Out[3]=  a + i^2</code></pre>
<p>由上面一段文档，可以看出，<code>Module</code> 比 <code>Block</code> 对局部变量的屏蔽程度更高。</p>
<h2 id="使用纯函数">使用纯函数</h2>
<p>如果必须对任何一种无论多小的运算所用的函数显式命名，往往将很不方便. 在 Mathematica 中，可以通过声明内联函数（称作纯函数）来避开这一问题.</p>
<p>纯函数的定义方法如下：</p>
<ul>
<li><p>Function[x,body]</p>
<p>纯函数中的 x 可用任何变量代替</p></li>
<li><p>Function[x1, x2, … , body]</p>
<p>多变量的纯函数</p></li>
<li><p>body <code>&amp;</code></p>
<p>自变量为 # 或 #1、#2、#3 等的纯函数.</p></li>
</ul>
<p>对于纯函数，可以不命名就使用：</p>
<pre><code>Function[{x, y}, x+y][3,4]
7</code></pre>
<p>使用一个<code>&amp;</code>符号标记在末尾为简写符号。参数位置用<code>#1</code>、<code>#2</code>、<code>#3</code>等指定。</p>
<pre><code>g = (#1^#2) &amp;;
g[2, 3]
8</code></pre>
<p>纯函数不要求有单独的定义或名称，例如：</p>
<pre><code>(#1 ^ #2) &amp; [3, 4]
8</code></pre>
<p>如果纯函数只有一个参数，那么可以直接使用<code>#</code>来指定该参数。</p>
<h2 id="将函数应用于多个表达式多个参数">将函数应用于多个表达式/多个参数</h2>
<p>可以使用<code>Map</code>命令来将一个函数应用于多个表达式，例如：</p>
<pre class="mma"><code>In:= Map[f, {a,b,c,d}]
Out= {f[a],f[b],f[c],f[d]}</code></pre>
<p>此外，还可以使用<code>Map</code>命令的简写形式<code>/@</code>：</p>
<pre class="mma"><code>In:= f/@{a,b,c,d}
Out= {f[a],f[b],f[c],f[d]}</code></pre>
<p>与将函数应用于多个表达式类似，还可以将函数应用于多个参数，使用<code>Apply</code>命令或者其简写形式<code>@@</code>：</p>
<pre class="mma"><code>In:= Apply[f, {a,b,c,d}]
Out= f[a,b,c,d]

In:= f@@{ {a,b},{c,d} }
Out= f[{a,b},{c,d}]</code></pre>
<p>使用函数时除了使用<code>[]</code>以外，还可以使用<code>@</code>符号：</p>
<pre class="mma"><code>In:= f@a
Out= f[a]</code></pre>
<h2 id="函数的部分应用">函数的“部分应用”</h2>
<p>WolframAlpha语言具有函数式编程的特性，Mathematica也支持函数的部分应用。如下例：</p>
<pre><code>In:= Nearest[{1, 2, 3, 4, 5}, 2.7]
Out= {3}

In:= f = Nearest[{1, 2, 3, 4, 5}]
Out= NearestFunction[{5,1},&lt;&gt;]

In:= %[2.7]
Out= {3}

In:= f[2.7]
Out= {3}</code></pre>
<h2 id="mathematica的函数与参数占位符">Mathematica的函数与参数占位符</h2>
<p>使用参数占位符，可以定义参数个数不定的函数。</p>
<p>占位符用法表如下：</p>
<table>
<thead>
<tr class="header">
<th align="left">占位符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>_</code></td>
<td align="left">单一表达式</td>
</tr>
<tr class="even">
<td align="left"><code>x_</code></td>
<td align="left">名为 x 的表达式</td>
</tr>
<tr class="odd">
<td align="left"><code>__</code></td>
<td align="left">一个或多个表达式序列</td>
</tr>
<tr class="even">
<td align="left"><code>x__</code></td>
<td align="left">名为 x 的表达式列</td>
</tr>
<tr class="odd">
<td align="left"><code>x__ h</code></td>
<td align="left">头部为 h 的表达式列</td>
</tr>
<tr class="even">
<td align="left"><code>___</code></td>
<td align="left">零个或多个表达式序列</td>
</tr>
<tr class="odd">
<td align="left"><code>x___</code></td>
<td align="left">名为 x 的零个或多个表达式序列</td>
</tr>
<tr class="even">
<td align="left"><code>x___ h</code></td>
<td align="left">头部为 h 的零个或多个表达式序列</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>: 使用三空位<code>___</code>来表示0个或多个表达式序列时，某些情况下很容易导致<code>___</code>反复与零元素进行匹配，导致死循环。因此，应当尽量避免使用三空位<code>___</code>。</p>
<h2 id="mathematica程序的控制流">Mathematica程序的控制流</h2>
<p>引自<a href="http://www.wolfram.com/language/fast-introduction-for-programmers/procedures/">Wolfram语言快速入门</a>中的一句话：</p>
<blockquote>
<p>在 Wolfram 语言中通常只需要小剂量的过程式编程.</p>
</blockquote>
<blockquote>
<p>（如果你的大型程序中充满了 If、Do、Return 等，那你的程序可能需要改进.）</p>
</blockquote>
<p>Mathematica中，通过<code>Return</code>、<code>Throw</code>、<code>Catch</code>等命令来实现对程序跳转和返回值等的控制。</p>
<h3 id="return-命令">Return 命令</h3>
<p><code>Return</code> 命令的用法：</p>
<ul>
<li><p>Return[expr]</p>
<p>从函数中返回 expr 的值.</p></li>
<li><p>Return[]</p>
<p>返回 Null 值.</p></li>
</ul>
<p>关于<code>Return</code>命令的用法，需要<strong>注意</strong>: <code>Return</code> 仅退出调用它的最内层结构。</p>
<h3 id="throw和catch">Throw和Catch</h3>
<p><code>Sow/Reap</code>和<code>Throw/Catch</code>是过程式编程中传递数据和控制的有效方式。<code>Throw</code>和<code>Catch</code>命令可以比Return 更明确地实现程序的控制流。命令的具体用法：</p>
<p><code>Throw</code>命令：</p>
<ul>
<li><p>Throw[value]</p>
<p>停止计算并将 value 作为最接近 Catch 的返回值.</p></li>
<li><p>Throw[value,tag]</p>
<p>仅由 Catch[expr,form] 返回，其中 form 是匹配 tag 的模式.</p></li>
</ul>
<p><code>Catch</code>命令：</p>
<ul>
<li><p>Catch[expr]</p>
<p>返回在运行 expr 时产生的第一个 Throw 的参数.</p></li>
<li><p>Catch[expr,form]</p>
<p>返回 form 匹配 tag 的第一个 Throw[value,tag] 中的 value.</p></li>
<li><p>Catch[expr,form,f]</p>
<p>返回 f[value,tag]. </p></li>
</ul>
<h2 id="timeconstrained-和-pause-命令">TimeConstrained 和 Pause 命令</h2>
<p>TimeConstrained 命令用来实现定时停止计算。</p>
<p>Puase 命令用来实现暂停。</p>
<p>TimeConstrained 的用法</p>
<ul>
<li><p>TimeConstrained[expr,t]</p>
<p>计算 expr，在 t 秒后停止计算.</p></li>
<li><p>TimeConstrained[expr,t,failexpr]</p>
<p>如果没有达到时间限制，返回 failexpr.</p></li>
</ul>
<p>Puase 的用法：</p>
<ul>
<li><p>Pause[n]</p>
<p>至少暂停 n 秒.</p></li>
</ul>
<p>TimeConstrained的一个显著用途在于限制迭代时间。使得相关的计算能够在限定之间内给出某个不够精确的解。</p>
<p>关于Puase命令，应当<strong>注意</strong>：</p>
<ul>
<li><p>Pause 仅在向下到至少<code>$TimeUnit</code>秒的间隔时是准确的. <code>$TimeUnit</code>的值可以通过在Mathematica的交互式命令行输入<code>$TimeUnit</code>查看。</p>
<pre><code>$TimeUnit: 给出您计算机系统上记录的以秒计的最小时间间隔.</code></pre></li>
<li><p>在执行Pause的过程中，过去的时间在SessionTime 和 AbsoluteTiming中统计，而不在TimeUsed或Timing中统计.</p></li>
</ul>
<p>具体举例：</p>
<pre><code>$TimeUnit
1/1000

Timing[Pause[1]]
{0., Null}
AbsoluteTiming[Puase[1]]
{1.000066, Null}</code></pre>
<h2 id="fullform-命令">FullForm 命令</h2>
<p>FullForm 命令用来查看变量的具体形式，包括类型、值等等。</p>
<p>例如：</p>
<pre><code>CharacterRange[&quot;a&quot;, &quot;c&quot;]
{a, b, c}
FullForm[%]
List[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre>
