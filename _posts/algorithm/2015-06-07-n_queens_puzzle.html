---
title: N皇后问题
author: He Tao
date: 2015-06-06
tag: Algorithm
category: Algorithm
layout: post
---

<p>N皇后问题是一个经典的问题，在一个N*N的棋盘上放置N个皇后，每行一个并使其不能互相攻击（同一行、同一列、同一斜线上的皇后都会自动攻击）。N皇后问题互不相同的解的个数可以用<a href="http://oeis.org/A000170">OEIS A000170</a>序列来表示，如果将旋转和对称的解归为一种，那么独立解的个数符合序列<a href="http://oeis.org/A002562">OEIS A002562</a>。</p>
<h2 id="普通递归求解">普通递归求解</h2>
<p>N皇后问题的普通解法是通过枚举N的全排列，并判断是否符合条件来得到解的方案数。可以通过一些剪枝技巧来优化运算，提升效率。</p>
<h2 id="位运算求解">位运算求解</h2>
<p>使用位运算可以显著提升运算效率。这是目前公认N皇后的最高效算法：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 试探算法从最右边的列开始。</span>
<span class="dt">void</span> nqueens(<span class="dt">long</span> row, <span class="dt">long</span> ld, <span class="dt">long</span> rd) {
    <span class="kw">if</span>(row != upperlim) {
        <span class="co">// row，ld，rd进行“或”运算，求得所有可以放置皇后的列,对应位为0，</span>
        <span class="co">// 然后再取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列</span>
        <span class="co">// 改为1</span>
        <span class="co">// 也就是求取当前哪些列可以放置皇后</span>
        <span class="dt">long</span> pos = upperlim &amp; ~(row | ld | rd);
        <span class="kw">while</span>(pos) {   <span class="co">// 0 -- 皇后没有地方可放，回溯</span>

            <span class="co">// 拷贝pos最右边为1的bit，其余bit置0</span>
            <span class="co">// 也就是取得可以放皇后的最右边的列</span>
            <span class="dt">long</span> p = pos &amp; -pos; <span class="co">// pos &amp; (~pos+1);</span>

            <span class="co">// 将pos最右边为1的bit清零</span>
            <span class="co">// 也就是为获取下一次的最右可用列使用做准备，</span>
            <span class="co">// 程序将来会回溯到这个位置继续试探</span>
            pos -= p;

            <span class="co">// row + p，将当前列置1，表示记录这次皇后放置的列。</span>
            <span class="co">// (ld + p) &lt;&lt; 1，标记当前皇后左边相邻的列不允许下一个皇后放置。</span>
            <span class="co">// (ld + p) &gt;&gt; 1，标记当前皇后右边相邻的列不允许下一个皇后放置。</span>
            <span class="co">// 此处的移位操作实际上是记录对角线上的限制，只是因为问题都化归</span>
            <span class="co">// 到一行网格上来解决，所以表示为列的限制就可以了。显然，随着移位</span>
            <span class="co">// 在每次选择列之前进行，原来N×N网格中某个已放置的皇后针对其对角线</span>
            <span class="co">// 上产生的限制都被记录下来了</span>
            nqueens(row + p, (ld + p) &lt;&lt; <span class="dv">1</span>, (rd + p) &gt;&gt; <span class="dv">1</span>);
        }
    }
    <span class="kw">else</span> {
        <span class="co">// row的所有位都为1，即找到了一个成功的布局，回溯</span>
        sum++;
    }
}</code></pre>
<ul>
<li>初始化: <code>upperlim = (1&lt;&lt;n)-1; sum = 0;</code></li>
<li>调用参数：<code>nqueens(0, 0, 0);</code></li>
<li>结果：<code>sum</code></li>
</ul>
<p>分析：这是一个递归函数，程序一行一行地寻找可以放皇后的地方。函数带三个参数<code>row</code>、<code>ld</code>和<code>rd</code>，分别表示在纵列和两个对角线方向的限制条件下这一行的哪些地方不能放。位于该行上的冲突位置就用<code>row</code>、<code>ld</code>和<code>rd</code>中的<code>1</code>来表示。把它们三个并起来，得到该行所有的禁位，取反后就得到所有可以放的位置（用pos来表示）。<code>p = pos &amp; (~pos + 1)</code>其结果是取出最右边的那个<code>1</code>。这样，<code>p</code>就表示该行的某个可以放子的位置，把它从<code>pos</code>中移除并递归调用<code>nqueens</code>过程。</p>
<p>注意递归调用时三个参数的变化，每个参数都加上了一个禁位，但两个对角线方向的禁位对下一行的影响需要平移一位。最后，如果递归到某个时候发现<code>row=upperlim</code>了，说明<code>n</code>个皇后全放进去了，找到的解的个数加<code>1</code>。如下图所示：</p>
<p><img src="{{site.url}}/resource/n_queens_puzzle/pic_1.gif" alt="示意图" /> <img src="{{site.url}}/resource/n_queens_puzzle/pic_2.gif" alt="示意图" /></p>
<p><code>upperlime = (1 &lt;&lt; n) - 1</code>: 生成了<code>n</code>个<code>1</code>组成的二进制数。</p>
<p><code>(ld | p) &lt;&lt; 1</code>是因为由<code>ld</code>造成的占位在下一行要右移一下; <code>(rd | p) &gt;&gt; 1</code>是因为由<code>rd</code>造成的占位在下一行要左移一下。</p>
<p><code>ld rd row</code>还要和<code>upperlime</code>与运算 一下，这样做的结果就是从最低位数起取<code>n</code>个数为有效位置，原因是在上一次的运算中<code>ld</code>发生了右移，如果不<code>and</code>的话，就会误把<code>n</code>以外的位置当做有效位。</p>
<p>在进行到某一层的搜索时，<code>pos</code>中存储了所有的可放位置，为了求出所有解，必须遍历所有可放的位置，而每走过一个点必须要删掉它，否则就成死循环。</p>
<p>巧妙之处在于：以前我们需要在一个N*N正方形的网格中挪动皇后来进行试探回溯，每走一步都要观察和记录一个格子前后左右对角线上格子的信息；采用bit位进行信息存储的话，就可以只在一行格子也就是（1行×N列）个格子中进行试探回溯即可，对角线上的限制被化归为列上的限制。</p>
<p>程序中主要需要下面三个bit数组，每位对应网格的一列，在C中就是取一个整形数的某部分连续位即可。<code>row</code>用来记录当前哪些列上的位置不可用，也就是哪些列被皇后占用，对应为<code>1</code>。<code>ld</code>，<code>rd</code>同样也是记录当前哪些列位置不可用，但是不表示被皇后占用，而是表示会被已有皇后在对角线上吃掉的位置。这三个位数组进行“或”操作后就是表示当前还有哪些位置可以放置新的皇后，对应<code>0</code>的位置可放新的皇后。</p>
<p><strong>所有下一个位置的试探过程都是通过位操作来实现的</strong>。</p>
<h2 id="完整实现">完整实现</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**</span>
 * N Queens Problem
<span class="er"> * 试探-回溯算法，递归实现</span>
 */
<span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;ctime&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="co">// sum用来记录皇后放置成功的不同布局数；upperlim用来标记所有列都已经放置好了皇后。</span>
<span class="dt">long</span> sum = <span class="dv">0</span>, upperlim = <span class="dv">1</span>;

<span class="dt">void</span> nqueens(<span class="dt">int</span> row, <span class="dt">int</span> ld, <span class="dt">int</span> rd) {
    <span class="dt">int</span> pos, p;
    <span class="kw">if</span>(row != upperlim) {
        pos = upperlim &amp; (~(row | ld | rd ));
        <span class="kw">while</span>(pos){
            p = pos &amp; (~pos + <span class="dv">1</span>);
            pos = pos - p;
            nqueens(row | p, (ld | p) &lt;&lt; <span class="dv">1</span>, (rd | p) &gt;&gt; <span class="dv">1</span>);
        }
    }
    <span class="kw">else</span> {
        ++sum;
    }
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[])
{
    time_t tm;
    <span class="dt">int</span> n = <span class="dv">16</span>;

    <span class="kw">if</span> (argc != <span class="dv">1</span>)
        n = atoi(argv[<span class="dv">1</span>]);
    tm = time(<span class="dv">0</span>);

    <span class="co">// 因为整型数的限制，最大只能32位，</span>
    <span class="co">// 如果想处理N大于32的皇后问题，需要</span>
    <span class="co">// 用bitset数据结构进行存储</span>
    <span class="kw">if</span> ((n &lt; <span class="dv">1</span>) || (n &gt; <span class="dv">32</span>)) {
        exit(<span class="dv">-1</span>); <span class="co">// 只能计算1-32之间</span>
    }

    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> 皇后</span><span class="ch">\n</span><span class="st">&quot;</span><span class="co">,</span> n);
    <span class="co">// N个皇后只需N位存储，N列中某列有皇后则对应bit置1。</span>
    upperlim = (upperlim &lt;&lt; n) - <span class="dv">1</span>;
    nqueens(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);
    printf(<span class="st">&quot;共有</span><span class="ch">%ld</span><span class="st">种排列, 计算时间</span><span class="ch">%d</span><span class="st">秒 </span><span class="ch">\n</span><span class="st">&quot;</span><span class="co">,</span> sum, (<span class="dt">int</span>) (time(<span class="dv">0</span>) - tm));
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="方案构造">方案构造</h2>
<p>除了求解解的个数以外，求解一个摆放方案也是一个极具挑战性的问题。对于N皇后问题，有如下结论：</p>
<p>一、当<code>n mod 6 != 2 &amp;&amp; n mod 6 != 3</code>时：</p>
<pre><code>[2,4,6,8,...,n],[1,3,5,7,...,n-1]  (n为偶数)
[2,4,6,8,...,n-1],[1,3,5,7,...,n]  (n为奇数)</code></pre>
<p>二、当<code>n mod 6 == 2 或 n mod 6 == 3</code>时</p>
<p>设变量<code>k</code>,当<code>n</code>为偶数,<code>k=n/2</code>; 当<code>n</code>为奇数,<code>k=(n-1)/2</code>:</p>
<pre><code>(k为偶数,n为偶数)
[k,k+2,k+4,...,n],[2,4,...,k-2],[k+3,k+5,...,n-1],[1,3,5,...,k+1]
(k为偶数,n为奇数)
[k,k+2,k+4,...,n-1],[2,4,...,k-2],[k+3,k+5,...,n-2],[1,3,5,...,k+1],[n]
(k为奇数,n为偶数)
[k,k+2,k+4,...,n-1],[1,3,5,...,k-2],[k+3,...,n],[2,4,...,k+1]
(k为奇数,n为奇数)
[k,k+2,k+4,...,n-2],[1,3,5,...,k-2],[k+3,...,n-1],[2,4,...,k+1],[n ]</code></pre>
<p>上式中，方括号<code>[]</code>仅仅用来表示解的子序列特征。</p>
<p>例题：<a href="http://poj.org/problem?id=3239">POJ 3239: Solution to the n Queens Puzzle</a></p>
<p>按照上述结论，容易得到题解：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;iostream&gt;</span>
<span class="ot">#include &lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">void</span> queens_puzzle(<span class="dt">int</span> n) { <span class="co">// n&gt;=8</span>
    <span class="kw">if</span>(n%<span class="dv">6</span>!=<span class="dv">2</span> &amp;&amp; n%<span class="dv">6</span>!=<span class="dv">3</span>) {
        printf(<span class="st">&quot;2&quot;</span>);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">4</span>;i&lt;=n;i+=<span class="dv">2</span>)
            printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
        <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i+=<span class="dv">2</span>)
            printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
    <span class="kw">else</span> {
        <span class="dt">int</span> k=n/<span class="dv">2</span>;
        <span class="kw">if</span>(n%<span class="dv">2</span>==<span class="dv">0</span> &amp;&amp; k%<span class="dv">2</span>==<span class="dv">0</span>) {
            printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,k);
            <span class="kw">for</span>(<span class="dt">int</span> i=k<span class="dv">+2</span>;i&lt;=n;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;=k<span class="dv">-2</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=k<span class="dv">+3</span>;i&lt;=n<span class="dv">-1</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=k<span class="dv">+1</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
        }
        <span class="kw">else</span> <span class="kw">if</span>(n%<span class="dv">2</span>==<span class="dv">1</span> &amp;&amp; k%<span class="dv">2</span>==<span class="dv">0</span>) {
            printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,k);
            <span class="kw">for</span>(<span class="dt">int</span> i=k<span class="dv">+2</span>;i&lt;=n<span class="dv">-1</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;=k<span class="dv">-2</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=k<span class="dv">+3</span>;i&lt;=n<span class="dv">-2</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=k<span class="dv">+1</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,n);
        }
        <span class="kw">else</span> <span class="kw">if</span>(n%<span class="dv">2</span>==<span class="dv">0</span> &amp;&amp; k%<span class="dv">2</span>==<span class="dv">1</span>) {
            printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,k);
            <span class="kw">for</span>(<span class="dt">int</span> i=k<span class="dv">+2</span>;i&lt;=n<span class="dv">-1</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=k<span class="dv">-2</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=k<span class="dv">+3</span>;i&lt;=n;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;=k<span class="dv">+1</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
        }
        <span class="kw">else</span> {
            printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,k);
            <span class="kw">for</span>(<span class="dt">int</span> i=k<span class="dv">+2</span>;i&lt;=n<span class="dv">-2</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=k<span class="dv">-2</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=k<span class="dv">+3</span>;i&lt;=n<span class="dv">-1</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;i&lt;=k<span class="dv">+1</span>;i+=<span class="dv">2</span>)
                printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,i);
            printf(<span class="st">&quot; </span><span class="ch">%d</span><span class="st">&quot;</span>,n);
        }
        printf(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>);
    }
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
    <span class="dt">int</span> n;
    <span class="kw">while</span>(~scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>,&amp;n)) {
        <span class="kw">if</span>(!n) <span class="kw">break</span>;
        queens_puzzle(n);
    }
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="参考">参考</h2>
<ol style="list-style-type: decimal">
<li><a href="http://en.wikipedia.org/wiki/Eight_queens_puzzle">Wikipedia: Eight Queens Puzzle</a></li>
<li><a href="http://mathworld.wolfram.com/QueensProblem.html">Queens Problem</a></li>
<li><a href="http://blog.csdn.net/kai_wei_zhang/article/details/8033194">位运算解决八皇后问题</a></li>
<li><a href="http://www.cnblogs.com/Missa/archive/2012/10/19/2730344.html">N皇后问题公式解</a></li>
</ol>
<!-------------------------------links---------------------->
