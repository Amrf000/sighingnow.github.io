---
title: 寻找第K大的数
author: He Tao
date: 2015-02-09
tag: Algorithm
category: Algorithm
layout: post
---

<h2 id="一概述">一、概述</h2>
<p>朴素的寻找第k大元可以排序，再找到第k个，时间复杂度为O(n * log(n))，但由于只需要第k大，因此这样会造成很大的时间上浪费。维护一个k大的堆的时间复杂度为O(n * log(k)),有所改进，但时间复杂度仍不够优，且实现复杂。而基于分治思想的算法可以在O(n)的时间内找到第k大的数。</p>
<h2 id="二原理">二、原理</h2>
<!--more-->
<p>利用分治法寻找第k大的数的原理与快速排序类似，每次选取一个基准元素，利用与快速排序相同的操作，找到基准元素在最终的数列中的位置，如果等于k，就直接return，如果大于，在第k大的元素一定在右半部分，否则一定在左半部分。接着递归进行上述过程。由此，便可以有效地避免不必要的比较和排序操作，降低算法的时间复杂度。</p>
<h2 id="三具体实现">三、具体实现</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> k_find(<span class="dt">int</span> num[], <span class="dt">int</span> l, <span class="dt">int</span> r, <span class="dt">int</span> k)
{
    <span class="dt">int</span> i = l, j = r, m = (l+r)&gt;&gt;<span class="dv">1</span>; <span class="co">// binary improved.</span>
    <span class="dt">int</span> x = num[m];
    <span class="kw">while</span> (i != j) {
        <span class="kw">while</span> (j &gt; m &amp;&amp; num[j] &gt; x) {
            j--;
        }
        num[m] = num[j]; m = j;
        <span class="kw">while</span> (i &lt; m &amp;&amp; num[i] &lt; x) {
            i++;
        }
        num[m] = num[i]; m = i;
    }
    num[i] = x;
    <span class="kw">if</span> (i &lt; k) {
        <span class="kw">return</span> k_find(i<span class="dv">+1</span>, r, k);
    } <span class="kw">else</span> <span class="kw">if</span> (i &gt; k) {
        <span class="kw">return</span> k_find(l, i<span class="dv">-1</span>, k);
    } <span class="kw">else</span> {
        <span class="kw">return</span> num[i];
    }
}</code></pre>
<h2 id="四算法复杂度分析">四、算法复杂度分析</h2>
<p>基于分治的查找第K大的数的算法期望时间度为 O(n), 其中，n 为元素的个数。由于无额外空间占用，因此，空间复杂度为 O(n)。</p>
<h2 id="五扩展">五、扩展</h2>
<h3 id="多次查询">多次查询</h3>
<p>对于查找序列中的第K大数的问题，如果需要多次查询，那么先排序在查找或者划分树的算法更为合适。</p>
<h3 id="多个序列">多个序列</h3>
<p><a href="https://leetcode.com/">LeetCode OJ</a>上有这样一道题目：</p>
<blockquote>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
</blockquote>
<p>题目链接：<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">004. Median of Two Sorted Arrays</a></p>
<p>拿到这个题目，不难想到可以在O(m+n)的时间内归并这两个有序数组，然后二分在O(log(m+n))的时间复杂度内找出中位数，但这显然不符合题目的复杂度要求。这便要求我们设计出更加高效的算法。</p>
<p>将寻找中位数扩展至寻找两个有序序列的第<code>K</code>大，又该如何做呢？中位数是第(m+n)/2小的数，因此，可以认为这两个问题等价。</p>
<p>首先假设数组A和B的元素个数都大于<code>k/2</code>，我们比较<code>A[k/2-1]</code>和<code>B[k/2-1]</code>两个元素，这两个元素分别表示A的第<code>k/2</code>小的元素和B的第<code>k/2</code>小的元素。这两个元素比较共有三种情况：<code>&gt;</code>、<code>&lt;</code>和<code>=</code>。如果<code>A[k/2-1]&lt;B[k/2-1]</code>，这表示<code>A[0]</code>到<code>A[k/2-1]</code>的元素都在A和B合并之后的前<code>k</code>小的元素中。换句话说，<code>A[k/2-1]</code>不可能大于两数组合并之后的第k小值，<strong>所以我们可以将其抛弃</strong>。</p>
<p>证明也很简单，可以采用反证法。</p>
<p>假设<code>A[k/2-1]</code>大于合并之后的第<code>k</code>小值，我们不妨假定其为第<code>(k+1)</code>小值。由于<code>A[k/2-1]</code>小于<code>B[k/2-1]</code>，所以<code>B[k/2-1]</code>至少是第<code>(k+2)</code>小值。但实际上，在A中至多存在<code>k/2-1</code>个元素小于<code>A[k/2-1]</code>，B中也至多存在<code>k/2-1</code>个元素小于<code>A[k/2-1]</code>，所以小于<code>A[k/2-1]</code>的元素个数至多有<code>k/2+k/2-2</code>，小于<code>k</code>，这与<code>A[k/2-1]</code>是第<code>(k+1)</code>的数矛盾。</p>
<p>当<code>A[k/2-1]&gt;B[k/2-1]</code>时存在类似的结论。</p>
<p>当<code>A[k/2-1]=B[k/2-1]</code>时，我们已经找到了第<code>k</code>小的数，也即这个相等的元素，我们将其记为<code>m</code>。由于在A和B中分别有<code>k/2-1</code>个元素小于<code>m</code>，所以<code>m</code>即是第<code>k</code>小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k/2，然后利用k-k/2获得另一个数。)</p>
<p>通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件：</p>
<ul>
<li>如果<code>A</code>或者<code>B</code>为空，则直接返回<code>B[k-1]</code>或者<code>A[k-1]</code>；</li>
<li>如果<code>k</code>为<code>1</code>，我们只需要返回<code>A[0]</code>和<code>B[0]</code>中的较小值；</li>
<li>如果<code>A[k/2-1]=B[k/2-1]</code>，返回其中一个。</li>
</ul>
<p>给出这一算法的Python实现：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> findMedianSortedArrays(nums1, nums2):

    <span class="kw">def</span> findKth(a, m, b, n, k):
        <span class="kw">if</span> m &gt; n:
            <span class="kw">return</span> findKth(b, n, a, m, k)
        <span class="kw">if</span> m == <span class="dv">0</span>:
            <span class="kw">return</span> b[k<span class="dv">-1</span>]
        <span class="kw">if</span> k == <span class="dv">1</span>:
            <span class="kw">return</span> <span class="dt">min</span>(a[<span class="dv">0</span>], b[<span class="dv">0</span>])
        pa = <span class="dt">min</span>(k//<span class="dv">2</span>, m)
        pb = k - pa
        <span class="kw">if</span> a[pa<span class="dv">-1</span>] &lt; b[pb<span class="dv">-1</span>]:
            <span class="kw">return</span> findKth(a[pa:], m-pa, b, n, k-pa)
        <span class="kw">elif</span> (a[pa<span class="dv">-1</span>] &gt; b[pb<span class="dv">-1</span>]):
            <span class="kw">return</span> findKth(a, m, b[pb:], n-pb, k-pb)
        <span class="kw">else</span>:
            <span class="kw">return</span> a[pa - <span class="dv">1</span>];

    m, n = <span class="dt">len</span>(nums1), <span class="dt">len</span>(nums2)
    <span class="kw">if</span> (m+n) % <span class="dv">2</span> == <span class="dv">0</span>:
        <span class="kw">return</span> (findKth(nums1, m, nums2, n, (m+n)//<span class="dv">2</span>) + 
                findKth(nums1, m, nums2, n, (m+n)//<span class="dv">2+1</span>)) / <span class="fl">2.0</span>
    <span class="kw">else</span>:
        <span class="kw">return</span> findKth(nums1, m, nums2, n, (m+n)//<span class="dv">2+1</span>)</code></pre>
<h3 id="寻找前k个数">寻找前k个数</h3>
<p>上面提到的算法仅仅要求找到第k个数，那么，如果变换一下问题，要求找到前k个数，又该怎么做呢？</p>
<ol style="list-style-type: decimal">
<li>如果不要求前k个数有序，那么复杂度等同于找到第k个数，因为在找到第k个数的时候，前面的书都比第k个数小。</li>
<li>如果要求前k个数有序，那么在找到之后进行一次排序即可。复杂度O(n*log(k))。</li>
</ol>
<h2 id="参考">参考</h2>
<ol style="list-style-type: decimal">
<li><a href="http://articles.leetcode.com/2011/03/median-of-two-sorted-arrays.html">Median of Two Sorted Arrays</a></li>
<li><a href="http://blog.csdn.net/yutianzuijin/article/details/11499917/">leetcode之 median of two sorted arrays</a></li>
<li><a href="http://blog.csdn.net/zxzxy1988/article/details/8587244">Leetcode 4 Median of Two Sorted Arrays</a></li>
<li><a href="http://people.csail.mit.edu/rivest/BlumFloydPrattRivestTarjan-TimeBoundsForSelection.pdf">Time Bounds for Selection</a></li>
</ol>
