---
title: 背包问题总结
author: He Tao
date: 2015-02-11
tags: Algorithm
category: Algorithm
layout: post
---

<p>背包问题是动态规划思想和方法的经典应用问题，本文将从0-1背包，完全背包和混合背包三个角度来分析简单背包问题的求解方法。</p>
<h2 id="背包问题">背包问题</h2>
<p>背包问题本质上是规划型问题，问题的核心在于在满足约束条件下，找到一种选择方案，使得目标值达到最优。通过动态规划的方法，可以将此类问题限制在多项式复杂度的时间内求解。</p>
<!--more-->
<h2 id="背包">0-1背包</h2>
<h3 id="背包问题的描述">0-1背包问题的描述</h3>
<p>有N件物品和一个总容量为V的背包，第<code>i</code>件物品的费用是<code>c[i]</code>，价值是<code>w[i]</code>。求解将哪些物品装入背包可以使得装入的物品的价值总和最大。</p>
<h3 id="背包问题的动态转移">0-1背包问题的动态转移</h3>
<p>动态转移方程：</p>
<p><span class="math">\[ f[i][v] = max\{f[i-1][v], f[i-1][v-c[i]]+w[i]\} \]</span></p>
<p>解释；对于每一个状态，在决策是否装入第<code>i</code>件时，选取装入与不装入该件物品的价值和的最大值。如果放入第i件物品，那么前<code>i</code>件物品最多只能占用<code>v-c[i]</code>的体积，则价值和为<code>f[i-1][w-c[i]]</code>，如果不装入第<code>i</code>件物品，那么价值和仍为前<code>i-1</code>件物品的价值和。</p>
<h3 id="时间和空间复杂度分析">时间和空间复杂度分析</h3>
<p>该算法时间复杂度为O(V*N)，如果只需要求解价值总和的最大值，由于只需要根据价值进行DP，空间复杂度可以优化到O(N)。</p>
<p>代码表述如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i) {
    <span class="kw">for</span>(<span class="dt">int</span> j = v; j &gt;= c[i]; j--) {
        f[j] = max(f[j], (f[j-c[i]] + w[i]));
        
        <span class="co">/** </span>不优化空间的写法
         * f[i][j] = max(f[i<span class="dv">-1</span>][j], (f[i<span class="dv">-1</span>][j-c[i]] + w[i]));
         */
    }
}</code></pre>
<h3 id="回溯法推导0-1背包问题的最优方案">回溯法推导0-1背包问题的最优方案</h3>
<p>可以通过回溯的方法求解到底放入了那些背包，在这个求解过程中，不能进行空间的优化，因此，空间占用为O(V*N)。具体代码表述如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**</span>
<span class="er"> * sum 值为之前DP求出的最大价值。</span>
<span class="er"> * used 数组用来标记每件物品是否装入。</span>
<span class="er"> * 如果第 i 件物品装入了，则 used[i] = true；</span>
<span class="er"> * 否则，used[i] = false。</span>
 */
<span class="dt">bool</span> used[n] = {<span class="kw">false</span>};
<span class="kw">for</span>(i = n; i &gt;= <span class="dv">0</span>; --i) {
    <span class="kw">if</span>(f[i][sum] &gt; f[i<span class="dv">-1</span>][sum]) {
        used[i] = <span class="kw">true</span>;
        sum -= w[i];
    }
}</code></pre>
<h3 id="另一种获取方案的方法">另一种获取方案的方法</h3>
<p>可以使用一个二维数组<code>flag</code>在更新<code>f</code>时对更新的trace进行记录，然后回溯，便可以得到方案：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> flag[n<span class="dv">+1</span>][v<span class="dv">+1</span>] = {{<span class="dv">0</span>}};

<span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i) {
    <span class="kw">for</span>(<span class="dt">int</span> j = v; j &gt;= c[i]; j--) {
        <span class="kw">if</span>(f[j] &lt; f[j-c[i]]+w[i]) {
            f[j] = f[j-c[i]] + w[i]);
            flag[i][j] = <span class="dv">1</span>;
        }
    }
}

<span class="co">/**</span>
 * 顺序输出物品编号
 */
<span class="dt">void</span> output() {
    <span class="dt">int</span> i = N, j = V;
    <span class="kw">while</span>(i) {
        <span class="kw">if</span>(flag[i][j] == <span class="dv">1</span>) {
            cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span><span class="co">;</span>
            j -= w[i];
        }
        i--;
    }
    cout &lt;&lt; endl;
}

<span class="co">/**</span>
 * 逆序输出物品编号
 */
<span class="dt">void</span> output_reverse() {
    <span class="kw">if</span>(i == <span class="dv">0</span> || j == <span class="dv">0</span>) {
        <span class="kw">return</span>;
    }
    <span class="kw">if</span>(flag[i][j] == <span class="dv">1</span>) {
        output_reverse(i<span class="dv">-1</span>, j-w[i]);
        cout &lt;&lt; i &lt;&lt; <span class="st">&quot; &quot;</span><span class="co">;</span>
    }
}</code></pre>
<h2 id="完全背包">完全背包</h2>
<h3 id="完全背包问题的描述">完全背包问题的描述</h3>
<p>有N种物品和一个容量为V的背包，每种物品有无限件可用。第i件物品的费用为<code>c[i]</code>，价值是<code>w[i]</code>。求解将哪些物品装入背包可以使得装入的物品的价值总和最大，并且物品总费用不能超过背包容量。</p>
<h3 id="完全背包问题的状态转移">完全背包问题的状态转移</h3>
<p>显然，完全背包问题可以转换为0-1背包问题，通过总体积来限制背包个数即可。不难得出以下的状态转移方程：</p>
<p><span class="math">\[ f[i][v] = max\{f[i-1][v-k \times c[i]] + k \times w[i]\} \]</span></p>
<p>其中，</p>
<p><span class="math">\[ 0 \leq k \times c[i] \leq v \]</span></p>
<p>分析得知，此状态转移求解每个状态的时间已经不是常数了。分析完全背包问题的特点，可以作出优化。分析思路：如果两件物品 <code>i,j</code> 满足 <code>c[i] &lt;= c[j]</code> 且 <code>w[i] &gt;= w[j]</code> , 则将物品j去掉，不用考虑。优化的正确性在于任何情况下都可以用物美价廉的i替换j，至少不会比替换前的方案更差。但此优化在最坏情形下并不能改善问题的复杂度规模，因为在最坏情况下任何一件物品都不能忽略。</p>
<p>考虑到每种物品都有无限件可以选，因此，在选择第i件物品时，只要根据一个绝无已经选入第i种物品的子结果<code>f[i-1][v-[i]]</code>即可。在具体实现上，只要改变V的递推顺序就行。</p>
<p>代码表述如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i) {
    <span class="kw">for</span>(<span class="dt">int</span> j = c[i]; j &lt;= v; ++j) {
        f[j] = max(f[j], f[j-c[i]]+w[i]);    
    }
}</code></pre>
<h3 id="算法复杂度分析">算法复杂度分析</h3>
<p>优化后的时间复杂度为O(N*V)，空间复杂度为O(V)。</p>
<h2 id="混合背包">混合背包</h2>
<h3 id="混合背包问题的描述">混合背包问题的描述</h3>
<p>有N种物品和一个容量为V的背包，第i种物品最多有<code>n[i]</code>件可用，每件费用为<code>c[i]</code>，价值为<code>w[i]</code>。求解选择方案使得物品价值总和最大，且总重量不超过背包容量，每件物品的数量也不超过其限制。</p>
<h3 id="混合背包的朴素求解">混合背包的朴素求解</h3>
<p>同混合背包类似，完全背包问题也可以建模为0-1背包模型，但无法在常数时间内求解每个状态，其时间复杂度会达到O(n^3)。</p>
<h3 id="混合背包的二进制拆分求解">混合背包的二进制拆分求解</h3>
<p>二进制拆分实际上是对朴素求解算法的优化。通过二进制拆分可以减少状态数。其原理基于每一个正整数都可以写成数个2的自然数次幂之和，并且，每两个幂的次数都不相同。此优化方案可以将时间复杂度优化到O(n^2*log(n))。</p>
<p>代码描述如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i) {
    <span class="dt">int</span> s[mi][<span class="dv">2</span>], k = <span class="dv">1</span>, t = <span class="dv">0</span>;
    <span class="kw">while</span>(<span class="kw">true</span>) {
        <span class="kw">if</span>(m[i] &lt;= k) {
            s[t][<span class="dv">0</span>] = m[i] * c[i], s[t++][<span class="dv">1</span>] = m[i] * w[i];
            <span class="kw">break</span>;
        }
        <span class="kw">else</span> {
            s[t][<span class="dv">0</span>] = k * c[i], s[t++][<span class="dv">1</span>] = k * w[i];
        }
        m[i] = m[i] - k;
        k = k * <span class="dv">2</span>;
    }
    <span class="kw">while</span>(t--) {
        <span class="kw">for</span>(j = v; j &gt;= s[t][<span class="dv">0</span>]; j--) {
            f[j] = max(f[j], (f[j-s[t][<span class="dv">0</span>]] + s[t][<span class="dv">1</span>]));
        }
    }
}</code></pre>
<h3 id="混合背包的单调队列优化">混合背包的单调队列优化</h3>
<p>该算法的思想是根据当前体积模当前物品体积的余数进行分组，每一组的状态都可以有前面的任意一组转换而来。问题可以转化为固定长度区间求最值问题。采用单调队列，可以将时间复杂度优化到O(N*V)。</p>
<p>代码表述如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">/**</span>
<span class="er"> * a, b 均为辅助队列，其中，b 是一个单调队列。</span>
 */
<span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i) {
    
    <span class="co">// 优化最多可用的物品件数</span>
    <span class="kw">if</span>(!n[i] || v/c[i] &lt; n[i]) {
        n[i] = v / c[i];   
    }
    
    <span class="kw">for</span>(<span class="dt">int</span> d = <span class="dv">0</span>; d &lt; c[i]; ++d) {
        <span class="dt">int</span> l = <span class="dv">1</span>, r = <span class="dv">0</span>; <span class="co">// 初始化队列参数，清空队列。</span>
        <span class="kw">for</span>(<span class="dt">int</span> j = <span class="dv">0</span>; j &lt;= (v-d)/c[i]; ++j) {
            <span class="co">// j 对应的体积为 j*c[i]+d。</span>
            <span class="dt">int</span> x = j, y = f[j*c[i]+d] - j*w[i]; <span class="co">// 退化</span>
            <span class="co">// 插入队列</span>
            <span class="kw">while</span>(l &lt;= r &amp;&amp; b[r] &lt;= y) {
                r--;
            }
            a[++r] = x;
            b[r] = y;
            <span class="co">// 如果队首元素已经失效，删除失效点。</span>
            <span class="kw">if</span>(a[l] &lt; j - n[i]) {
                l++;
            }
            <span class="co">// 取得队头，进行更新。</span>
            f[j*c[i]+d] = b[l] + j*w[i];
        }
    }    
}</code></pre>
<h2 id="参考">参考</h2>
<ol style="list-style-type: decimal">
<li><a href="http://wenku.baidu.com/view/4d68b68fbceb19e8b8f6bacd.html?re=view">背包问题九讲</a></li>
<li><a href="http://wenku.baidu.com/view/be91d48202d276a200292ea0.html?re=view">浅谈几类背包问题，徐持衡，2009年信息学奥林匹克中国国家集训队论文</a></li>
<li><a href="http://blog.csdn.net/flyinghearts/article/details/5898183" title="flyinghearts的专栏">多重背包O(N*V)算法详解(使用单调队列)</a></li>
<li><a href="http://blog.csdn.net/insistgogo/article/details/8579597">背包问题九讲笔记</a></li>
</ol>
