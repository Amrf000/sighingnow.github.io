---
title: Polya定理及应用
author: He Tao
date: 2015-06-05
tag: Algorithm
category: Algorithm
layout: post
---

<h2 id="概念及定理">概念及定理</h2>
<p>首先是群的概念：</p>
<p>设<span class="math">\(G\)</span>是一个集合，<span class="math">\(*\)</span>是<span class="math">\(G\)</span>上的二元运算，如果<span class="math">\((G,*)\)</span>满足下面的条件：</p>
<ol style="list-style-type: decimal">
<li>封闭性：对于任何<span class="math">\(a,b \subset G\)</span>有<span class="math">\(a*b \subset G\)</span>;</li>
<li>结合律：对任何<span class="math">\(a,b,c\subset G\)</span>有<span class="math">\((a*b)*c=a*(b*c)\)</span>;</li>
<li>单位元：存在<span class="math">\(e\subset G\)</span>,使得对所有的<span class="math">\(a\subset G\)</span>,都有<span class="math">\(a*e=e*a=a\)</span>;</li>
<li>逆元：对于每个元素<span class="math">\(a\subset G\)</span>,存在<span class="math">\(x\subset G\)</span>,使得<span class="math">\(a*x=x*a=e\)</span>,这个时候记<span class="math">\(x\)</span>为<span class="math">\(a^{-1}\)</span>，称为<span class="math">\(a\)</span>的逆元，那么则称<span class="math">\((G,*)\)</span>为一个群。</li>
</ol>
<p>例：<span class="math">\(G=\{0,1,2,3,4....n-1\}\)</span>，那么它在<span class="math">\(\text{mod n}\)</span>加法下是一个群。</p>
<p>群元素的个数有限，称为有限群，且其中元素的个数称为阶，记为<span class="math">\(|G|\)</span>,群元素的个数无限，称为无限群。</p>
<p>若对于群元素中的任意两个元素<span class="math">\(a,b\)</span>都有<span class="math">\(ab=ba\)</span>那么称<span class="math">\(G\)</span>为交换群，简称<em>Abel</em>群。</p>
<p>置换：设<span class="math">\(X\)</span>为一个有限集，<span class="math">\(\pi\)</span>是<span class="math">\(X\)</span>到<span class="math">\(X\)</span>的一个一一变换，那么称<span class="math">\(\pi\)</span>是<span class="math">\(X\)</span>上的一个置换。</p>
<p>例：设<span class="math">\(X=\{1,2,3,4....n\}\)</span>,设<span class="math">\(\pi\)</span>是<span class="math">\(X\)</span>的一个变换，满足<span class="math">\(\pi: 1\to a_1,2\to a_2,\dots n\to a_n\)</span>,其中<span class="math">\(a_1,a_2\dots a_n\)</span>是X的一个排列，则称<span class="math">\(\pi\)</span>是<span class="math">\(X\)</span>上的一个置换。可将<span class="math">\(\pi\)</span>记为:</p>
<p><span class="math">\[ \begin{array}{|c|c|c|c|c|}\hline
 1 &amp;  2 &amp;  3 &amp;  \dots &amp;  n \\ \hline
 a_1 &amp;  a_2 &amp;  a_3 &amp;  \dots &amp;  a_n \\ \hline
\end{array} \]</span></p>
<p>同一置换用这样的表示法有<span class="math">\(n!\)</span>种，但其对应的关系不变。 假设循环<span class="math">\(\pi\)</span>只这样一个置换，满足<span class="math">\(\pi: a_1\to a_2,a_2\to a_3,\dots a_k\to a_1\)</span>,但是对于其他元素保持不变，即：<span class="math">\(a\to a\)</span>,可将π记为</p>
<p><span class="math">\[ \begin{array}{|c|c|c|c|c|}\hline
 a_1 &amp;  a_2 &amp;  a_3 &amp;  \dots &amp;  a_k \\ \hline
 a_2 &amp;  a_3 &amp;  a_4 &amp;  \dots &amp;  a_1 \\ \hline
\end{array} \]</span></p>
<p>称为<span class="math">\(k\)</span>阶循环，<span class="math">\(K\)</span>为循环长度。每个置换都可以写成若干个互不相交的循环的乘积，且表示是唯一的.如</p>
<p><span class="math">\[
\begin{array}{|c|c|c|c|c|c|} \hline
 1 &amp;  2 &amp;  3 &amp;  4 &amp;  5 &amp;  6 \\ \hline
 2 &amp;  4 &amp;  5 &amp;  1 &amp;  3 &amp;  6 \\ \hline
\end{array} \]</span></p>
<p>则可以表示为<span class="math">\((124)(35)(6)\)</span>,置换的循环节数是上面的循环个数，上面的例题的循环节数为<span class="math">\(3\)</span>.</p>
<p>定义：设<span class="math">\(G\)</span>是有限集<span class="math">\(X\)</span>上的置换群，点<span class="math">\(a,b\subset X\)</span>称为“等价”的，当且仅当，存在<span class="math">\(\pi \subset G\)</span>使得<span class="math">\(\pi(a)=b\)</span>，记为<span class="math">\(a~b\)</span>，这种等价条件下，<span class="math">\(X\)</span>的元素形成的等价类称为<span class="math">\(G\)</span>的轨道，它是集<span class="math">\(X\)</span>的一个子集，<span class="math">\(G\)</span>的任意两个不同的轨道之交是空集，所以置换群<span class="math">\(G\)</span>的轨道全体是集合<span class="math">\(X\)</span>的一个划分，构成若干个等价类，等价类的个数记为<span class="math">\(L\)</span>。</p>
<p><span class="math">\(Z_k\)</span> (<span class="math">\(K\)</span>不动置换类)：设<span class="math">\(G\)</span>是<span class="math">\(1\dots n\)</span>的置换群。若<span class="math">\(K\)</span>是<span class="math">\(1\dots n\)</span>中某个元素，<span class="math">\(G\)</span>中使<span class="math">\(K\)</span>保持不变的置换的全体，记以<span class="math">\(Z_k\)</span>，叫做<span class="math">\(G\)</span>中使<span class="math">\(K\)</span>保持不动的置换类，简称<span class="math">\(K\)</span>不动置换类。</p>
<p><span class="math">\(E_k\)</span>(等价类)：设<span class="math">\(G\)</span>是<span class="math">\(1\dots n\)</span>的置换群。若<span class="math">\(K\)</span>是<span class="math">\(1\dots n\)</span>中某个元素，<span class="math">\(K\)</span>在<span class="math">\(G\)</span>作用下的轨迹，记作<span class="math">\(E_k\)</span>。即<span class="math">\(K\)</span>在<span class="math">\(G\)</span>的作用下所能变化成的所有元素的集合。这个时候有：<span class="math">\(|E_k|*|Z_k|=|G|\)</span>成立<span class="math">\((k=1,2,.....n)\)</span>。</p>
<p><span class="math">\(C(\pi)\)</span>：对于一个置换<span class="math">\(\pi \subset G\)</span>,及<span class="math">\(a\subset X\)</span>，若<span class="math">\(\pi(a)=a\)</span>，则称<span class="math">\(a\)</span>为<span class="math">\(\pi\)</span>的不动点。<span class="math">\(\pi\)</span>的不动点的全体记为<span class="math">\(C(\pi)\)</span>。例如<span class="math">\(\pi=(123)(3)(45)(6)(7), X=\{1,2,3,4,5,6,7\}\)</span>;那么<span class="math">\(C(\pi)=\{3,6,7\}\)</span>共<span class="math">\(3\)</span>个元素。</p>
<p><strong>Burnside引理</strong>：</p>
<p><span class="math">\[L = \frac{1}{|G|}*(Z_1+Z_2+Z_3+Z_4+\dots+Z_k)\]</span> <span class="math">\[L = \frac{L1}{|G|}*(C(\pi_1)+C(\pi_2)+C(\pi_3)+\dots+C(\pi_n))\]</span> (其中<span class="math">\(k\subset X,\pi \subset G\)</span>)。</p>
<p><strong>Polya定理</strong>：</p>
<p>设<span class="math">\(G=\{\pi_1，\pi_2，\pi_3, \dots, \pi_n\}\)</span>是<span class="math">\(X=\{a_1，a_2，a_3, \dots, a_n\}\)</span>上一个置换群，用<span class="math">\(m\)</span>中颜色对<span class="math">\(X\)</span>中的元素进行涂色，那么不同的涂色方案数为： <span class="math">\[\frac{1}{|G|}*(m^C(\pi_1)+m^C(\pi_2)+m^C(\pi_3)+\dots+m^C(\pi_k))\]</span>其中<span class="math">\(C(\pi_k)\)</span>为置换 <span class="math">\(\pi_k\)</span> 的循环节的个数。</p>
<h2 id="polya定理求循环节个数">polya定理求循环节个数</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">const</span> <span class="dt">int</span> MAXN=<span class="dv">1001</span>;
<span class="dt">int</span> n, perm[MAXN], visit[MAXN]; <span class="co">//sum求循环节个数, Perm用来存储置换,即一个排列</span>
<span class="dt">int</span> gcd(<span class="dt">int</span> n, <span class="dt">int</span> m) {
    <span class="kw">return</span> m==<span class="dv">0</span>?n:gcd(m,n%m);
}
<span class="dt">void</span> Polya() {
    <span class="dt">int</span> pos,sum=<span class="dv">0</span>;
    memset(visit, <span class="bn">0x00</span>, <span class="kw">sizeof</span>(visit));
    <span class="kw">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>; i&lt;n; i++) {
        <span class="kw">if</span>(!visit[i]) {
            sum++; pos=i;
            <span class="kw">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;!visit[perm[pos]];j++) {
                pos=perm[pos];
                visit[pos]=<span class="dv">1</span>;
            }
        }
    }
    <span class="kw">return</span> sum;
}</code></pre>
<h2 id="考虑旋转和翻转">考虑旋转和翻转</h2>
<p>1.旋转置换.</p>
<p>我们假设依次顺时针旋转<span class="math">\(1~n\)</span>个,则循环个数为<span class="math">\(gcd(i,n)\)</span>;</p>
<p>2.翻转置换</p>
<p>当<span class="math">\(n\)</span>为偶数时,分两种情况,一种是中心轴在两个对称对象上,则循环个数为<span class="math">\(n/2+1\)</span>,这样的置换有<span class="math">\(n/2\)</span>个。另一种是对称轴两边分别有<span class="math">\(n/2\)</span>个对象,则循环个数为<span class="math">\(n/2\)</span>，这样的置换也有<span class="math">\(n/2\)</span>个。</p>
<p>当<span class="math">\(n\)</span>为奇数时,对称轴就只能在一个对象上,则循环个数为<span class="math">\(n/2+1\)</span>;</p>
<h2 id="例题poj-2409">例题：POJ 2409</h2>
<p>题目链接：<a href="http://poj.org/problem?id=2409">POJ 2409: http://poj.org/problem?id=2409</a></p>
<blockquote>
<p>A bracelet is a ring-like sequence of s beads each of which can have one of c distinct colors. The ring is closed, i.e. has no beginning or end, and has no direction. Assume an unlimited supply of beads of each color. For different values of s and c, calculate the number of different bracelets that can be made.</p>
</blockquote>
<p>理解：给定颜色种数和环上的珠子总数，问有多少种染色方案（通过旋转和翻转相同的算同一种）。可见，是简单的考虑旋转和翻转的Polya计数模型。题解：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="kw">inline</span> <span class="dt">long</span> <span class="dt">long</span> gcd(<span class="dt">long</span> <span class="dt">long</span> a, <span class="dt">long</span> <span class="dt">long</span> b) {
    <span class="kw">return</span> b==<span class="dv">0</span>?a:gcd(b, a%b);
}

<span class="dt">long</span> <span class="dt">long</span> llpow(<span class="dt">long</span> <span class="dt">long</span> a, <span class="dt">long</span> <span class="dt">long</span> b) {
    <span class="kw">return</span> b==<span class="dv">0</span>?<span class="dv">1</span>:llpow(a, b<span class="dv">-1</span>)*a;
}

<span class="dt">long</span> <span class="dt">long</span> polya(<span class="dt">long</span> <span class="dt">long</span> n, <span class="dt">long</span> <span class="dt">long</span> m) {
    <span class="dt">long</span> <span class="dt">long</span> sum = <span class="dv">0</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= m; ++i) {
        sum += llpow(n, gcd(m, i));
    }
    <span class="kw">if</span>(m &amp; <span class="dv">1</span>) {
        sum += m*llpow(n, (m&gt;&gt;<span class="dv">1</span>)<span class="dv">+1</span>);
    }
    <span class="kw">else</span> {
        sum += (m&gt;&gt;<span class="dv">1</span>)*llpow(n, (m&gt;&gt;<span class="dv">1</span>)<span class="dv">+1</span>) + (m&gt;&gt;<span class="dv">1</span>)*llpow(n, m&gt;&gt;<span class="dv">1</span>);
    }
    <span class="kw">return</span> sum/<span class="dv">2</span>/m; <span class="co">// 去掉翻转和旋转的重复</span>
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
    <span class="dt">long</span> <span class="dt">long</span> n, m;
    <span class="kw">while</span>(scanf(<span class="st">&quot;</span><span class="ch">%lld%lld</span><span class="st">&quot;</span>, &amp;n, &amp;m) != EOF &amp;&amp; m+n &gt; <span class="dv">0</span>) {
        printf(<span class="st">&quot;</span><span class="ch">%lld\n</span><span class="st">&quot;</span>, polya(n, m));
    }

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<h2 id="例题poj-2154">例题：POJ 2154</h2>
<p>题目链接：<a href="http://poj.org/problem?id=2154">POJ 2154: http://poj.org/problem?id=2154</a></p>
<p>题目大意：将正n边形的n个顶点用n种颜色染色，问有多少种方案（答案mod p，且可由旋转互相得到的算一种）。</p>
<p>分析：顺时针旋转i格的置换中，循环的个数为<span class="math">\(gcd(i,n)\)</span>，每个循环的长度为<span class="math">\(n/gcd(i,n)\)</span>。如果枚举旋转的格数<span class="math">\(i\)</span>，复杂度显然较高。因此，考虑不枚举<span class="math">\(i\)</span>，反过来枚举<span class="math">\(L\)</span>。由于<span class="math">\(L|N\)</span>,枚举了<span class="math">\(L\)</span>，再计算有多少个<span class="math">\(i\)</span>使得<span class="math">\(0&lt;=i&lt;=n-1\)</span>并且<span class="math">\(L=gcd(i, n)\)</span>。即<span class="math">\(gcd(i,n)=n/L\)</span>。</p>
<p>不妨设<span class="math">\(a=n/L=gcd(i, n)\)</span>,设<span class="math">\(i=a*t\)</span>则当且仅当<span class="math">\(gcd(L,t)=1\)</span>时，有： <span class="math">\[Gcd(i,n)=gcd(a*L,a*t)=a\]</span> 因为<span class="math">\(0&lt;=i&lt;n\)</span>,所以<span class="math">\(0&lt;=t&lt;n/a=L\)</span>,所以满足这个条件的<span class="math">\(t\)</span>的个数为<span class="math">\(Euler(L)\)</span>.</p>
<p>欧拉函数：</p>
<p><span class="math">\[\phi(x)=x(1-\frac{1}{p_1})(1-\frac{1}{p_2})(1-\frac{1}{p_3})\dots(1-\frac{1}{p_k})\]</span></p>
<p>其中<span class="math">\(p_1, p_2, p_3, \dots, p_k\)</span>为<span class="math">\(x\)</span>的所有质因数，<span class="math">\(x\)</span>是不为<span class="math">\(0\)</span>的整数。<strong>表示不超过<span class="math">\(n\)</span>且与<span class="math">\(n\)</span>互素的正整数的个数</strong>。</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include&lt;iostream&gt;</span>
<span class="ot">#include&lt;cstring&gt;</span>
<span class="ot">#include&lt;cstdio&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

<span class="dt">const</span> <span class="dt">int</span> maxn = <span class="dv">36000</span>;
<span class="dt">int</span> n, mod, ans, prim[<span class="dv">35000</span>];
<span class="dt">bool</span> flag[maxn + <span class="dv">20</span>];

<span class="dt">void</span> get_prim() {
    memset(flag, <span class="bn">0x00</span>, <span class="kw">sizeof</span> (flag));
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>; i &lt;= <span class="dv">1000</span>; i++) {
        <span class="kw">if</span>(!flag[i]) {
            <span class="kw">for</span>(<span class="dt">int</span> j = i * i; j &lt;= maxn; j += i) {
                flag[j] = <span class="kw">true</span>;
            }
        }
    }
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">2</span>, k = <span class="dv">0</span>; i &lt;= maxn; i++) {
        <span class="kw">if</span>(!flag[i]) {
            prim[k++] = i;
        }
    }
}

<span class="dt">int</span> eular(<span class="dt">int</span> n) { <span class="co">// phi function.</span>
    <span class="dt">int</span> i = <span class="dv">0</span>, ans = <span class="dv">1</span>;
    <span class="kw">for</span>(i = <span class="dv">0</span>; prim[i] * prim[i] &lt;= n; i++) {
        <span class="kw">if</span>(n % prim[i] != <span class="dv">0</span>) {
            <span class="kw">continue</span>;
        }
        ans *= prim[i] - <span class="dv">1</span>; n /= prim[i];
        <span class="kw">while</span>(n % prim[i] == <span class="dv">0</span>) {
            ans *= prim[i]; n /= prim[i];
        }
    }
    <span class="kw">if</span>(n &gt; <span class="dv">1</span>) {
        ans *= n - <span class="dv">1</span>;
    }
    <span class="kw">return</span> ans % mod;
}

<span class="dt">int</span> pow_mod(<span class="dt">int</span> c, <span class="dt">int</span> k, <span class="dt">int</span> mod) {
    <span class="dt">int</span> ans = <span class="dv">1</span>;
    c = c % mod;
    <span class="kw">while</span>(k) {
        <span class="kw">if</span>(k &amp; <span class="dv">1</span>) {
            ans = (c * ans) % mod;
        }
        k &gt;&gt;= <span class="dv">1</span>;
        c = (c * c) % mod;
    }
    <span class="kw">return</span> ans;
}

<span class="dt">int</span> main() {
    get_prim();
    <span class="dt">int</span> i, T;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;T);
    <span class="kw">while</span>(T-- &amp;&amp; scanf(<span class="st">&quot;</span><span class="ch">%d%d</span><span class="st">&quot;</span>, &amp;n, &amp;mod)) {
        ans = <span class="dv">0</span>;
        <span class="kw">for</span>(i = <span class="dv">1</span>; i * i &lt;= n; i++) {
            <span class="kw">if</span> (i * i == n) { <span class="co">//枚举循环长度l，找出相应的i的个数：gcd(i,n)=n/l.</span>
                ans = (ans + pow_mod(n, i - <span class="dv">1</span>, mod) * eular(i)) % mod;
            }
            <span class="kw">else</span> <span class="kw">if</span>(n % i == <span class="dv">0</span>) { <span class="co">//有长度为l的循环，就会有长度为n/l的循环。</span>
                ans = (ans + pow_mod(n, n / i - <span class="dv">1</span>, mod) * eular(i) +
                        eular(n / i) * pow_mod(n, i - <span class="dv">1</span>, mod)) % mod;
            }
        }
        printf(<span class="st">&quot;</span><span class="ch">%d\n</span><span class="st">&quot;</span>, ans);
    }
}</code></pre>
<h2 id="参考">参考</h2>
<ol style="list-style-type: decimal">
<li><a href="http://blog.sina.com.cn/s/blog_6f71bea30100opru.html">polya 计数法，burnside定理</a></li>
</ol>
<!--------------------------------links------------------------>
