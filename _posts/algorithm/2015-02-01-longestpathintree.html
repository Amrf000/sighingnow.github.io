---
title: 树的最长路径
author: He Tao
date: 2015-02-01
tag: Algorithm
category: Algorithm
layout: post
---

<h2 id="一概述">一、概述</h2>
<p>树的最长路问题是一类求解树上两点之间最长距离的问题。针对此问题，有这样两类算法：DFS求解和树形DP。本文将以 <a href="http://hihocoder.com/problemset/problem/1050">HihoCoder 1050 : 树中的最长路</a> 一题为例，详细阐述这两种解法。</p>
<!--more-->
<h2 id="二树形dp">二、树形DP</h2>
<p>树形DP的基本思路为由子节点的情况推出父节点的情况，针对树的最长路径这一问题，分别记录每个节点的子节点的最大深度和次大深度，父节点的最大深度等于所有子节点的最大深度和次大深度的最大值加1，父节点的次大深度等于所有子节点的最大深度和次大深度的次大值加1，最后，每个节点对应的最长路径值为该节点的<code>最大深度-次大深度+1</code>,由此可得到树的最长路径长度。伪代码描述如下：</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">初始值：
    depth_0[leaf node] = depth_1[leaf node] = <span class="dv">1</span>
递推：
    depth_0[parent] = max({depth_0[{sons}], depth_1[{sons}]})
    depth_1[parent] = max({depth_0[{sons}], depth_1[{sons}]} - depth_0[parent])
求解：
    length[i] = depth_0[i] + depth_1[i] - <span class="dv">1</span>
    longest = max({length[i]})</code></pre>
<p>由此，得到结果。</p>
<h2 id="三dfs求解">三、DFS求解</h2>
<p>此题通过DFS求解的算法正确性基于以下性质：</p>
<p>以树上的任意一点为根节点，距离根节点最远的点一定是树的最长路径的一个端点。</p>
<p>证明：假设 s-t这条路径为树的最长路径，分以下两种情况证明： 1. 设u为s-t路径上的一点，结论显然成立，否则设搜到的最远点为T则<code>dis(u,T) &gt;dis(u,s)</code>且<code>dis(u,T)&gt;dis(u,t)</code>，则最长路不是s-t了，与假设矛盾。 2. 设u不为s-t路径上的点，首先明确，假如u走到了s-t路径上的一点，那么接下来的路径肯定都在s-t上了，而且终点为s或t，在1中已经证明过了。 所以现在又有两种情况了： 1：u走到了s-t路径上的某点，假设为X，最后肯定走到某个端点，假设是t ，则路径总长度为<code>dis(u,X)+dis(X,t)</code> 2：u走到最远点的路径u-T与s-t无交点，则<code>dis(u-T)&gt;dis(u,X)+dis(X,t)</code>显然，如果这个式子成立， 则<code>dis(u,T)+dis(s,X)+dis(u,X)&gt;dis(s,X)+dis(X,t)=dis(s,t)</code>最长路不是s-t矛盾。</p>
<p>由此上性质，得到如下解法：从任意一点对树DFS，找出深度最大的点，该点即为树的最长路径的一个端点。再从该点出发，对树进行一次DFS，此时得到的深度最大的点，该点即为树的最长路径的另一个端点，此时改点的深度值即为树的最长路径的长度。</p>
<h2 id="四代码实现">四、代码实现</h2>
<p><a href="http://hihocoder.com/problemset/problem/1050">HihoCoder 1050</a></p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;cstdio&gt;</span>
<span class="ot">#include &lt;vector&gt;</span>
<span class="ot">#include &lt;cstring&gt;</span>
<span class="ot">#include &lt;queue&gt;</span>
<span class="kw">using</span> <span class="kw">namespace</span> std;

vector&lt;<span class="dt">int</span>&gt; e[<span class="dv">100100</span>];
<span class="dt">bool</span> flag[<span class="dv">100100</span>];
<span class="dt">int</span> depth[<span class="dv">100100</span>], ans, n;

<span class="dt">int</span> bfs(<span class="dt">int</span> start) {
    memset(flag, <span class="bn">0x00</span>, <span class="kw">sizeof</span>(flag));
    memset(depth, <span class="bn">0x00</span>, <span class="kw">sizeof</span>(depth));
    queue&lt;<span class="dt">int</span>&gt; Q;
    Q.push(start);
    flag[start] = <span class="kw">true</span>;
    <span class="kw">while</span>(!Q.empty()) { 
        <span class="dt">int</span> u = Q.front();
        Q.pop();
        <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; e[u].size(); ++i) {
            <span class="kw">if</span>(!flag[e[u][i]]) {
                depth[e[u][i]] = depth[u]<span class="dv">+1</span>;
                flag[e[u][i]] = <span class="kw">true</span>;
                Q.push(e[u][i]);
            }
        }
    }
    <span class="dt">int</span> point = <span class="dv">-1</span>;
    ans = <span class="dv">-1</span>;
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= n; ++i) {
        <span class="kw">if</span>(depth[i] &gt; ans) {
            ans = depth[i];
            point = i;
        }
    }
    <span class="kw">return</span> point; <span class="co">// 返回距离最远的点的编号</span>
}

<span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
    <span class="dt">int</span> x, y;
    scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;n);
    <span class="kw">for</span>(<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; n; ++i) {
        scanf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st"> </span><span class="ch">%d</span><span class="st">&quot;</span>, &amp;x, &amp;y);
        e[x].push_back(y);
        e[y].push_back(x);
    }
    bfs(bfs(<span class="dv">1</span>));
    printf(<span class="st">&quot;</span><span class="ch">%d</span><span class="st">&quot;</span>, ans);

    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
