---
title: 约数个数加倍
author: He Tao
date: 2015-04-26
tag: Algorithm
category: Algorithm
layout: post
---

<p>最近在<a href="https://projecteuler.net">Project Euler</a>上看到一道很有意思的题目，题目大意是找到一个最小的正整数，这个正整数有 <span class="math">\(2^{500500}\)</span> 个约数。将原题摘引如下：</p>
<blockquote>
<p>The number of divisors of 120 is 16.</p>
</blockquote>
<blockquote>
<p>In fact 120 is the smallest number having 16 divisors.</p>
</blockquote>
<blockquote>
<p>Find the smallest number with 2<sup>500500</sup> divisors.</p>
</blockquote>
<blockquote>
<p>Give your answer modulo 500500507.</p>
</blockquote>
<!--more-->
<p>题目链接：<a href="https://projecteuler.net/problem=500" title="Problem 500">Problem 500. Problem 500!!!</a></p>
<p>第一眼看到这个题目，毫无头绪。一番Google之后，找到了如下一个题解：</p>
<p>引自<a href="https://news.ycombinator.com/item?id=8977550" class="uri">https://news.ycombinator.com/item?id=8977550</a>的关于此题的解答：</p>
<blockquote>
<p>So at this point, we think about doubling factor count and the ways we can do it. Out options are: &lt;1&gt;. Multiply by a prime that we have never used so far. &lt;2&gt;. Multiply by an existing prime k + 1 times, where k is the number of times it has been used. We repeat this 500500 times, using rule &lt;1&gt; and &lt;2&gt; (which can be generalized to one rule) and the result is the final answer.</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th align="center">factor count</th>
<th align="left">n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">2</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="center">4</td>
<td align="left">2<em>3 &lt;1&gt; | | 8 | 2</em>3<em>2</em>2 &lt;2&gt;</td>
</tr>
<tr class="odd">
<td align="center">16</td>
<td align="left">2<em>3</em>2<em>2</em>5 &lt;1&gt;</td>
</tr>
<tr class="even">
<td align="center">32</td>
<td align="left">2<em>3</em>2<em>2</em>5<em>7 &lt;1&gt; | | 64 | 2</em>3<em>2</em>2<em>5</em>7<em>3</em>3 &lt;2&gt;</td>
</tr>
<tr class="odd">
<td align="center">128</td>
<td align="left">2<em>3</em>2<em>2</em>5<em>7</em>3<em>3</em>11 &lt;1&gt;</td>
</tr>
</tbody>
</table>
<blockquote>
<p>For 16 factors the number works out to be 120 (just like the example!). For numbers shown in the questions, sieving the prime takes some time, I also found it helpful to use a binary heap for speeding up finding the next smallest factors.</p>
</blockquote>
<p>这个解法的核心在于使约数个数加倍的规则。借助<a href="http://www.wolframalpha.com/">WolframAlpha</a>，我们求得第500500个质数的值为7376507。因此，只需要先将前500500个质数（这个值可以更少一点）压入优先队列，每次按照上面讲到的规则出队、入队、在O(n)的时间内求得结果。我们知道，初始化质数表的时间复杂度，而筛法的时间复杂度是O(n(lg(lgn)))的(埃拉托斯特尼筛法(sieve of Eratosthenes))。在这个过程中需要维护一个堆，复杂度为O(n(lg n))。因此，这个题目的时间复杂度为O(n(lg n))。</p>
<p>从这个题的求解来看，真心可以体会到<strong>算法和数据结构改变世界</strong>!</p>
<p>下面给出这一算法的Python实现。</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#! /usr/bin/env python</span>
<span class="co"># -*- coding: utf-8 -*-</span>

<span class="ch">from</span> math <span class="ch">import</span> sqrt
<span class="ch">from</span> heapq <span class="ch">import</span> heappush, heappop

<span class="kw">class</span> comb:
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, n, c, nc):
        <span class="ot">self</span>.n = n
        <span class="ot">self</span>.c = c
        <span class="ot">self</span>.nc = nc
    <span class="kw">def</span> <span class="ot">__cmp__</span>(<span class="ot">self</span>, other):
        <span class="kw">return</span> <span class="ot">self</span>.nc - other.nc
    <span class="kw">def</span> <span class="ot">__lt__</span>(<span class="ot">self</span>, other):
        <span class="kw">return</span> <span class="ot">self</span>.nc &lt; other.nc
    <span class="kw">def</span> <span class="ot">__gt__</span>(<span class="ot">self</span>, other):
        <span class="kw">return</span> <span class="ot">self</span>.nc &gt; other.nc
    <span class="kw">def</span> <span class="ot">__eq__</span>(<span class="ot">self</span>, other):
        <span class="kw">return</span> <span class="ot">self</span>.nc == other.nc
    <span class="kw">def</span> <span class="ot">__str__</span>(<span class="ot">self</span>):
        <span class="kw">return</span> <span class="st">&#39;(</span><span class="ot">%d</span><span class="st">,</span><span class="ot">%d</span><span class="st">,</span><span class="ot">%d</span><span class="st">)&#39;</span>%(<span class="ot">self</span>.n, <span class="ot">self</span>.c, <span class="ot">self</span>.nc)

<span class="kw">def</span> nextprime():
    n, bound = <span class="dv">5</span>, <span class="dv">7376507</span>  <span class="co"># bound is the 500500th prime.</span>
    <span class="kw">yield</span> <span class="dv">2</span>
    <span class="kw">yield</span> <span class="dv">3</span>
    <span class="kw">while</span> n &lt; bound:
        i, r = <span class="dv">2</span>, <span class="dt">int</span>(sqrt(n))
        <span class="kw">while</span> i &lt;= r:
            <span class="kw">if</span> n % i == <span class="dv">0</span>:
                <span class="kw">break</span>
            i += <span class="dv">1</span>
        <span class="kw">if</span> i &gt; r:
            <span class="kw">yield</span> n
        n += <span class="dv">1</span>

<span class="kw">def</span> solve500():
    n, mod, bound, mult, p = <span class="dv">1</span>, <span class="dv">500500507</span>, <span class="dv">500500</span>, <span class="dv">1</span>, <span class="dv">0</span>
    heap, prime = [], nextprime()

    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">1</span>, <span class="dv">500500</span>):
        p = <span class="dt">next</span>(prime)
        heappush(heap, comb(p, <span class="dv">1</span>, p))

    <span class="kw">while</span> n &lt;= bound:
        h, n = heappop(heap), n<span class="dv">+1</span>
        mult = (mult*h.nc) % mod
        heappush(heap, comb(h.n, <span class="dv">2</span>*h.c, h.nc*h.nc))

    <span class="kw">return</span> mult

<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&#39;__main__&#39;</span>:
    <span class="dt">print</span>(solve500())

<span class="co"># vim: set sw=4, ts=4</span></code></pre>
<p>答案(answer): 35407281</p>
<p>此外，在网站<a href="http://oeis.org/wiki/Number_of_divisors_function#Formulae_for_the_number_of_divisors_function">oeis.org/wiki</a>上还有其他的一些关于如何计算一个数的约数个数的公式和资料。</p>
