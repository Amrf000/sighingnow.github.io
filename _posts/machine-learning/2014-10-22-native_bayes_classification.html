---
title: Native Bayes Classification
author: He Tao
date: 2014-10-22
tag: [机器学习]
category: 机器学习
layout: post
---

<h2 id="一概述">一、概述</h2>
<p>朴素贝叶斯分类基于贝叶斯定理，属于有监督的学习过程。在选取特征值恰当的情况下，朴素贝叶斯分类算法有很好的准确率。</p>
<h2 id="二定义">二、定义</h2>
<!--more-->
<p>1、设<span class="math">\[x = \{a_1, a_2, \dots, a_m\}\]</span>为一个待分类项，而每个a为x的一个特征属性。</p>
<p>2、有类别集合<span class="math">\[C = \{y_1, y_2, \dots, y_n\}\]</span></p>
<p>3、计算<span class="math">\[P(y_1|x), P(y_2|x), \dots, P(y_n|x)\]</span></p>
<p>4、如果<span class="math">\[P(y_k|n) = max\{P(y_1|x), P(y_2|x), \dots,P(y_n|x)\}\]</span>则<span class="math">\[x\in y_k\]</span></p>
<p>那么现在的关键就是如何计算第3步中的各个条件概率。我们可以这么做：</p>
<ol style="list-style-type: decimal">
<li>找到一个已知分类的待分类项集合，这个集合叫做训练样本集。</li>
<li>统计得到在各类别下各个特征属性的条件概率估计。即 <span class="math">\[P(a_1|y_1),P(a_2|y_1),\dots,P(a_m|y_1),\dots,P(a_m|y_n)\]</span></li>
<li>如果各个特征属性是条件独立的，则根据贝叶斯定理有如下推导： <span class="math">\[P(y_i|x) = \frac{P(x|y_i)P(p_i)}{P(x)}\]</span> 因为分母对于所有类别为常数，因为我们只要将分子最大化皆可。又因为各特征属性是条件独立的，所以有： <span class="math">\[P(x|y_i)P(y_i) = P(a_1|y_i)P(a_2|y_i) \dots P(a_m|y_i) = P(y_i) \\prod_{j=1}^m P(a_j|y_i) \]</span></li>
</ol>
<h2 id="三基本实现步骤">三、基本实现步骤</h2>
<ol style="list-style-type: decimal">
<li>整理数据， 对一些连续值字段离散化。</li>
<li>通过已知数据统计计算<span class="math">\(P(y_i)\)</span>，<span class="math">\(P(a_j|y_i)\)</span>。</li>
<li>对待分类数据进行分类</li>
</ol>
<h2 id="四优化">四、优化</h2>
<ol style="list-style-type: decimal">
<li>通过相关性检验和无关检验，选取恰当的特征项作为朴素贝叶斯学习的特征值。</li>
<li>采用更合理的连续数据离散化方法和更合理的噪声去除方法，均有助于提高朴素贝叶斯分类算法的精确度和适应性。</li>
<li>通过对已经数据惊醒分类，检验结果，校正误差。</li>
</ol>
<p>五、练习实现：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">#! /usr/bin/env python3</span>
<span class="co"># -*- encoding: utf-8 -*-</span>
<span class="co">&#39;&#39;&#39;</span>
<span class="co">Using Native Bayes method to classify.</span>
<span class="co">Learn data: adult.data</span>
<span class="co">Test data: adult.test</span>
<span class="co">Ans: error: 0.221792</span>
<span class="co">properties = [&#39;age&#39;,</span>
<span class="co">              &#39;type_employer&#39;,</span>
<span class="co">              &#39;fnlwgt&#39;,</span>
<span class="co">              &#39;education&#39;,</span>
<span class="co">              &#39;euucation_num&#39;,</span>
<span class="co">              &#39;marital&#39;,</span>
<span class="co">              &#39;occupation&#39;,</span>
<span class="co">              &#39;relationship&#39;,</span>
<span class="co">              &#39;race&#39;,</span>
<span class="co">              &#39;capital_gain&#39;,</span>
<span class="co">              &#39;capital_loss&#39;,</span>
<span class="co">              &#39;hr_per_week&#39;,</span>
<span class="co">              &#39;country&#39;]</span>
<span class="co">&#39;&#39;&#39;</span>
<span class="ch">import</span> sqlite3

frequency = ([{} <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, <span class="dv">16</span>)], [{} <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, <span class="dv">16</span>)])
probability = ([{} <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, <span class="dv">16</span>)], [{} <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, <span class="dv">16</span>)])
feature = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">11</span>, <span class="dv">12</span>] <span class="co"># properties used to test classify.</span>
cnt = [<span class="dv">0</span>, <span class="dv">0</span>]
total = [<span class="fl">0.0</span>, <span class="fl">0.0</span>]

conn = sqlite3.<span class="ot">connect</span>(<span class="st">&#39;adult.db&#39;</span>)
point = conn.cursor()

<span class="kw">def</span> main():
    learn()
    test()
    conn.close()

<span class="kw">def</span> test():
    sql = <span class="st">&#39;select * from test_data&#39;</span>
    correct = <span class="dv">0</span>
    cnt0 = <span class="dv">0</span>
    cnt1 = <span class="dv">0</span>
    wrong = <span class="dv">0</span>
    for row in point.execute(sql):
        if row[<span class="dv">15</span>] == <span class="dv">1</span>:
            cnt1 += <span class="dv">1</span>
        else:
            cnt0 += <span class="dv">1</span>
        if classify(row) == row[<span class="dv">15</span>]:
            correct += <span class="dv">1</span>
        else:
            wrong += <span class="dv">1</span>
    print(<span class="st">&#39;correct: </span><span class="ot">%d</span><span class="st">, wrong: </span><span class="ot">%d</span><span class="st">, total: </span><span class="ot">%d</span><span class="st">&#39;</span> %(correct, wrong, correct+wrong))
    print(<span class="st">&#39;correct rate: </span><span class="ot">%f</span><span class="st">&#39;</span> %(correct/(correct+wrong)))
    print(<span class="st">&#39;correct rate: </span><span class="ot">%f</span><span class="st">&#39;</span> %(wrong/(correct+wrong)))
    
<span class="kw">def</span> classify(data):
    data = <span class="dt">list</span>(data)
    p = [<span class="fl">0.0</span>, <span class="fl">0.0</span>]
    data[<span class="dv">3</span>] = <span class="dt">int</span>(data[<span class="dv">3</span>]/<span class="dv">50000</span>)
    nodata = <span class="dv">0</span>
    for i in [<span class="dv">0</span>, <span class="dv">1</span>]:
        for j in feature:
            ans = <span class="fl">1.0</span>
            rate = probability[i][j].get(data[j])
            if rate == <span class="ot">None</span>: <span class="co"># imcomplete data.</span>
                rate = <span class="fl">1.0</span>
                nodata += <span class="dv">1</span>
            ans *= rate
        p[i] = ans * total[i]
    if p[<span class="dv">0</span>] &gt; p[<span class="dv">1</span>]:
        return <span class="dv">0</span>
    else:
        return <span class="dv">1</span>

<span class="kw">def</span> learn():
    sql = <span class="st">&#39;select * from adult&#39;</span>
            
    for row in point.execute(sql):
        row = <span class="dt">list</span>(row) <span class="co"># transfer from tuple to list</span>
        type = row[<span class="dv">15</span>]
        cnt[<span class="dt">type</span>] += <span class="dv">1</span>
        row[<span class="dv">3</span>] = <span class="dt">int</span>(row[<span class="dv">3</span>]/<span class="dv">50000</span>)
        for i in <span class="dt">range</span>(<span class="dv">1</span>, <span class="dv">15</span>):
            if frequency[<span class="dt">type</span>][i].get(row[i]):
                frequency[<span class="dt">type</span>][i][row[i]] += <span class="dv">1</span>
            else:
                frequency[<span class="dt">type</span>][i][row[i]] = <span class="dv">1</span>
    
    total[<span class="dv">0</span>] = cnt[<span class="dv">0</span>] / (cnt[<span class="dv">0</span>]+cnt[<span class="dv">1</span>])
    total[<span class="dv">1</span>] = cnt[<span class="dv">1</span>] / (cnt[<span class="dv">0</span>]+cnt[<span class="dv">1</span>])
    for <span class="dt">type</span> in <span class="dt">range</span>(<span class="dv">0</span>, <span class="dv">2</span>):
        for i in <span class="dt">range</span>(<span class="dv">1</span>, <span class="dv">16</span>):
            for (u, v) in frequency[<span class="dt">type</span>][i].items():
                probability[<span class="dt">type</span>][i][u] = v / cnt[<span class="dt">type</span>]
            
<span class="kw">if</span> <span class="ot">__name__</span> == <span class="st">&#39;__main__&#39;</span>:
    main() </code></pre>
<p>测试用数据来自<a href="http://archive.ics.uci.edu/ml/datasets/Adult">UCI Machine Learning Repository</a>。</p>
<h2 id="实现的不足之处">实现的不足之处</h2>
<ol style="list-style-type: decimal">
<li>未能形成模块化，应该封装成可重用的接口。</li>
<li>预处理不够仔细。</li>
</ol>
