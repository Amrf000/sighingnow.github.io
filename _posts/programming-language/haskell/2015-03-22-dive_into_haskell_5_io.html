---
title: Dive Into Haskell(5) 输入与输出(IO)
author: He Tao
date: 2015-03-22
tag: [Haskell]
category: 编程语言
layout: post
---

<p>Haskell拥有惰性求值和一切皆函数的设计，在Haskell中，函数仅仅负责根据提供的参数返回特定的结果，并且，函数的结果不受外部环境的影响，仅仅与参数有关。但IO却拥有副作用，IO环境的变化使得函数的运行状态不可预测，这对程序的流程造成了严重的潜在影响。在Haskell中，使用了一套<strong>Monadic I/O</strong>的模型来弱化和解除程序对IO操作的依赖，其基本思想是控制构造具有IO操作的程序和限制IO运算对函数的影响。</p>
<!--more-->
<h2 id="stdio的io操作">stdio的IO操作</h2>
<p>Haskell提供类型<code>IO a</code>，其成员称为<strong>类型a</strong>的<strong>I/O动作</strong>。这种类型提供了一种在Haskell之上书写涉及到IO的有副作用的程序(按顺序执行IO操作)，并且不破坏Haskell的函数模型。以下函数用于标准IO(stdin/stdout)的输入与输出：</p>
<table>
<thead>
<tr class="header">
<th align="center">Function</th>
<th align="left">Type</th>
<th align="center">Action</th>
<th align="left">Usage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">getChar</td>
<td align="left">:: IO Char</td>
<td align="center">I</td>
<td align="left">从stdin读入一个字符</td>
</tr>
<tr class="even">
<td align="center">getContents</td>
<td align="left">:: IO String</td>
<td align="center">I</td>
<td align="left">从stdin读入多行字符串</td>
</tr>
<tr class="odd">
<td align="center">getLine</td>
<td align="left">:: IO String</td>
<td align="center">I</td>
<td align="left">从stdin读入一行字符串</td>
</tr>
<tr class="even">
<td align="center">putChar</td>
<td align="left">:: Char -&gt; IO ()</td>
<td align="center">O</td>
<td align="left">向stdout输出一个字符</td>
</tr>
<tr class="odd">
<td align="center">putStr</td>
<td align="left">:: String -&gt; IO ()</td>
<td align="center">O</td>
<td align="left">向stdout输出一个字符串</td>
</tr>
<tr class="even">
<td align="center">putStrLn</td>
<td align="left">:: String -&gt; IO ()</td>
<td align="center">O</td>
<td align="left">向stdout输出一个字符串，再输出一个换行符</td>
</tr>
<tr class="odd">
<td align="center">print</td>
<td align="left">:: Show a =&gt; a -&gt; IO ()</td>
<td align="center">O</td>
<td align="left">向stdout输出任何<code>Show</code>类型的参数</td>
</tr>
</tbody>
</table>
<p>从这些IO函数的类型中可以看出，对于输入，函数返回一个<code>IO a</code>类型的值，对于输出，返回值的类型为<code>IO ()</code>，其中<code>()</code>表示空元组，这仅仅意味着这个IO操作的完成。那么，又如何从IO操作的返回值中得到对应类型的内容呢？Haskell提供了一个操作符<code>&lt;-</code>用于从<code>IO a</code>中得到<code>a</code>类型的值。如下例：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> getLine       <span class="co">-- 用 &lt;- 获取IO操作的值</span>
    b <span class="ot">&lt;-</span> print a       <span class="co">-- 将输出操作的返回值的内容绑定到 b</span>
    print b            <span class="co">-- 输出操作的值为 IO()</span></code></pre>
<p>用GHC编译上述代码，运行，输入</p>
<pre><code>hello</code></pre>
<p>会得到输入：</p>
<pre><code>&quot;hello&quot;
()</code></pre>
<p>IO Action可以在任何地方创建、赋值、传递。任何表达式都可以返回一个IO Action，但只有从另一个IO动作中（或main中）才能执行。举个例子：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">func ::</span> <span class="dt">IO</span> ()
func <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> a <span class="fu">=</span> putStr <span class="st">&quot;12345&quot;</span>
    return ()
main <span class="fu">=</span> <span class="kw">do</span>
    func</code></pre>
<p>执行这一段代码不会获得任何输出，因为这仅仅将一个IO Action（此处为<code>putStr &quot;12345&quot;</code>）绑定到变量<code>a</code>而已，并没有执行。在<code>return ()</code>语句之前加上一句：</p>
<pre><code>a</code></pre>
<p>再编译运行，会得到如下输出：</p>
<pre><code>12345</code></pre>
<p>那么，上述代码中的<code>return ()</code>又是干嘛的呢？<code>return ()</code>的意思是构造了一个IO Action，其值为<code>()</code>。再看这样一段代码：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">func ::</span> <span class="dt">IO</span> <span class="dt">String</span>
func <span class="fu">=</span> <span class="kw">do</span>
    return <span class="st">&quot;1234567&quot;</span>

main <span class="fu">=</span> <span class="kw">do</span>
    str <span class="ot">&lt;-</span> func
    print str</code></pre>
<p>编译，运行，可以看到如下输出：</p>
<pre><code>&quot;1234567&quot;</code></pre>
<p>在Haskell中，<code>return</code>记号可以用来构造一个IO Action，并且，与C、Java、Python等语言不同，<code>return</code>不会终止函数的运行，<code>return</code>语句仅仅是构造了一个IO Action而已。在上例中，<code>return</code>构造的<code>IO String</code>类型的值与<code>getLine</code>函数的<code>IO String</code>类型的返回值具有一样的特征（例如都可以用<code>&lt;-</code>记号来取得IO Action的值）。</p>
<h2 id="组合io">组合IO</h2>
<p>我们注意到在前面的程序里用到了<code>do</code>记号(notation)，<code>do</code>几号用于组合IO，将多个IO操作顺序执行。<code>do</code>隐藏了函数式的细节，从而使得一系列IO操作像命令式程序那样执行，同时将IO操作独立出来，以函数式的方式封装，避免IO操作影响其他的“纯函数”的执行。</p>
<p>应当注意到，组合IO块必须返回一个IO Action，可以用<code>return</code>来构造一个IO Action。haskell会将组合IO块的最后一条语句作为返回值。例如：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">func ::</span> <span class="dt">IO</span> <span class="dt">String</span>
    getLine
    getLine
    getLine</code></pre>
<p>这一组合IO块的值便是最后一个<code>getLine</code>语句的值。同样，也可以通过绑定获取这一<code>IO String</code>类型的值中的<code>String</code>。</p>
<h2 id="文件io">文件IO</h2>
<p>Haskell中，与文件操作有关的函数定义在<code>System.IO</code>包中，使用时需要先导入：</p>
<pre><code>import System.IO</code></pre>
<p>打开与关闭文件：</p>
<pre><code>openBinaryFile
openBinaryTempFile
openBinaryTempFileWithDefaultPermissions
openFile
openTempFile
openTempFileWithDefaultPermissions</code></pre>
<p>这些函数的参数都是相同的：</p>
<pre><code>:: FilePath -&gt; IOMode -&gt; IO Handle</code></pre>
<p>其中，<code>IOMode</code>有以下几种值：</p>
<pre><code>ReadMode | WriteMode | AppendMode | ReadWriteMode</code></pre>
<p><code>AppendMode</code>与<code>ReadWriteMode</code>这两种模式的区别在于<code>AppendMode</code>的起始位置是文件结尾处，而<code>ReadWriteMode</code>的起始位置是文件开头。</p>
<p>值得<strong>注意</strong>的是，以<code>ReadMode</code>打开一个文件时，程序在编译阶段便会检查文件是否存在，如果不存在，那么程序不能通过编译。而以<code>WriteMode</code>、<code>AppendMode</code>和<code>ReadWriteMode</code>模式打开文件是，如果文件不存在，那么回自动根据<code>FilePath</code>来创建一个文件。</p>
<p>如果对以<code>ReadMode</code>打开的文件进行写操作，或者对以<code>WriteMode</code>打开的文件进行都操作，在编译阶段便会产生错误。</p>
<p>打开文件的函数如<code>openFile</code>会返回一个<code>IO Handle</code>，可以同<code>&lt;-</code>来获得这个<code>IO Handle</code>的值。如：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    fh <span class="fu">=</span> openFile <span class="st">&quot;output.txt&quot;</span> <span class="dt">WriteMode</span>
    s <span class="ot">&lt;-</span> hPutStr fh <span class="st">&quot;output content&quot;</span>
    print s
    hClose fh</code></pre>
<p>在<code>System.IO</code>中，普通的对<code>stdio</code>的操作的函数都有对应的操作文件的版本，具体构成为将原函数的首字母变成大写，再在前面加上一个<code>h</code>字符。这些函数都有一个额外的参数：<code>IO Handle</code>。</p>
<p>在完成文件操作后，要使用<code>hClose</code>函数来关闭文件(文件句柄)。</p>
<p>与C/C++、Java、Python等语言的文件操作类似，Haskell中也有<code>hTell</code>和<code>hSeek</code>函数，用来获得当前文件操作所在的位置（精确位置）和移动文件操作的位置。<code>hSeek</code>函数的定义如下：</p>
<pre><code>hSeek :: Handle -&gt; SeekMode -&gt; Integer -&gt; IO ()</code></pre>
<p>三个参数的含义分别为文件句柄、偏移模式和偏移量。返回值为一个<code>IO ()</code>类型的值。<code>SeekMode</code>又有三种：</p>
<pre><code>AbsoluteSeek | RelativeSeek | SeekFromEnd</code></pre>
<p>三种模式的含义分别为：</p>
<ul>
<li><code>AbsoluteSeek</code>: 通过指定精确位置的的方式来偏移操作位置；</li>
<li><code>RelativeSeek</code>: 以当前位置为原点，偏移一个相对位置，正数表示向前偏移，而负数表示向后偏移；</li>
<li><code>SeekFromEnd</code>: 从文件末尾向前偏移指定的字节数。例如<code>hSeek handle SeekFromEnd 0</code>的含义便是将操作位置设为文件末尾。</li>
</ul>
<p>例如</p>
<pre><code>stdin, stdout, stderr</code></pre>
<p>这样的IO文件是无法偏移的，Haskell中提供了<code>hIsSeekable</code>函数来判断文件是否支持偏移。</p>
<p>为了避免每次操作文件时都指定<code>IO handle</code>，可以将这些与文件IO相关的函数柯里化（部分函数），以此来实现更灵活、更简洁的IO操作。</p>
<h2 id="删除与重命名文件">删除与重命名文件</h2>
<p>在包<code>System.Directory</code>中定义了删除和重命名文件的函数：</p>
<ul>
<li><code>removeFile</code>: <code>:: FilePath -&gt; IO ()</code>，</li>
<li><code>renameFile</code>: <code>:: FilePath -&gt; FilePath -&gt; IO ()</code>，两个<code>FilePath</code>分别为旧、新文件名，</li>
<li><code>removeDirectory</code>: 删除目录，</li>
<li><code>renameDirectory</code>: 重命名目录，</li>
<li><code>removeDirectoryRecursive</code>: 递归地删除目录。</li>
</ul>
