---
title: Dive Into Haskell(3) 函数
author: He Tao
date: 2015-02-20
tags: [Haskell]
category: 编程语言
layout: post
---

<p>在Haskell中，一切皆函数。</p>
<h2 id="定义一个函数">定义一个函数</h2>
<p>haskell中，可以通过如下方式定义一个简单的函数：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">doubleMe x <span class="fu">=</span> x <span class="fu">+</span> x</code></pre>
<p>这样的做法其实是实现了一个绑定(binding)。更广泛的函数定义的方法：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">func1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="co">{- function body. -}</span>

<span class="ot">func2 ::</span> <span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="co">{- function body. -}</span>

<span class="ot">func3 ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="co">{- function body. -}</span>

<span class="ot">func4 ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a<span class="ot">-&gt;</span>a <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="co">{- function body. -}</span></code></pre>
<!--more-->
<p>从上面四个例子中可以看出haskell定义函数的几种语法。前两种语法类似，函数名后面前几个类型都为参数类型，最后一个类型为返回值类型。后两种语法类似，使用了类型类来标识参数的类型，同样，最后一个类型为返回值类型，前几个为参数类型。</p>
<h2 id="函数的调用">函数的调用</h2>
<p>上面定义的几个函数，可以通过如下语法调用：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">doubleMe <span class="dv">1</span>
func1 <span class="dv">1</span>
func2 <span class="dv">1</span> <span class="dv">2</span>
func3 <span class="dv">1</span>
func4 <span class="dv">1</span> <span class="dv">2</span></code></pre>
<p>如果函数有两个参数，那么可以通过中缀函数的方式调用，注意使用中缀函数语法是要在函数名左右两侧各加一个```符号。如下例：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dv">1</span> <span class="ot">`func2`</span> <span class="dv">2</span>
<span class="dv">1</span> <span class="ot">`func4`</span> <span class="dv">2</span></code></pre>
<p>Haskell的库函数中，可以用中缀函数语法调用的函数还有<code>div</code>, <code>mod</code>等。使用中缀函数的好处在于可以让参数之间的运算关系更加清楚。</p>
<h2 id="函数中的模式匹配">函数中的模式匹配</h2>
<p>定义函数时，可以为不同的模式分别定义函数体本身。函数匹配可以匹配一切数据类型。如下例：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">func ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
func <span class="dv">1</span> <span class="fu">=</span> <span class="st">&quot;number 1&quot;</span>
func <span class="dv">2</span> <span class="fu">=</span> <span class="st">&quot;number 2&quot;</span></code></pre>
<p>这样，当函数参数为<code>1</code>时，函数返回<code>&quot;number 1&quot;</code>，当函数参数为<code>2</code>时，函数返回<code>&quot;number 2&quot;</code>。如果参数与任何一个模式都不能匹配，那么程序将会出现运行时错误。错误内容为：</p>
<pre><code>Non-exhaustive patterns in function func</code></pre>
<p>因此，一种解决方法是在函数定义的最后加上一个默认的模式。例如，在上例函数的最后加入：</p>
<pre><code>func x: &quot;number is not in all patterns.&quot;</code></pre>
<p>这样，对于任何不再模式中的参数(既不等于1又不等于2的数)，参数值都将会被<code>x</code>捕获，执行模式<code>x</code>所对应的函数体。</p>
<p>注意：如果将模式<code>x</code>（默认模式）放在最前面，编译时将产生如下Warning:</p>
<pre><code>Pattern match(es) are overlapped</code></pre>
<p>函数运行时，无论参数是什么，都将运行对应于默认模式(<code>x</code>)对应的函数体。</p>
<p>又如下例定义阶乘函数的方法：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fact ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
fact <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
fact n <span class="fu">=</span> n <span class="fu">*</span> fact (n<span class="fu">-</span><span class="dv">1</span>)</code></pre>
<p>与其他编程语法相比，代码简洁明了。</p>
<h2 id="list与模式匹配">List与模式匹配</h2>
<p>对于List也可以使用<code>[]</code>或<code>:</code>进行模式匹配。例如<code>[1, 2, 3]</code>或<code>1:2:3:[]</code>将匹配元素为1、2、3的列表。</p>
<p>形如<code>x:xs</code>的模式将匹配长度大于等于<code>1</code>的List。并把List的头部绑定到<code>x</code>，其他部分绑定到<code>xs</code>。由此类推，<code>x:y:z:xs</code>将匹配元素个数大于等于<code>3</code>的List。</p>
<p>此外，<code>as</code>模式也常用语List的模式匹配中。例如：</p>
<pre><code>func all@(x, xs)</code></pre>
<p>语句中，<code>x</code>将匹配List的第一项，<code>xs</code>将匹配List的其他项，<strong><code>all</code>的函数是整个List</strong>。可以方便地通过<code>all</code>来操作参数的整个List。</p>
<h2 id="哨兵guards">哨兵(Guards)</h2>
<p>Haskell中与函数有关的另一个重要概念是哨兵(Guards)。模式匹配可以用来匹配参数的值或结构，而哨兵则用来匹配和检验参数的性质（如大小、正负等）。</p>
<p>Guards的应用举例：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">func1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
func1 number
    <span class="fu">|</span> number <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;number is equal to 0.&quot;</span>
    <span class="fu">|</span> number <span class="fu">&gt;</span> <span class="dv">0</span>  <span class="fu">=</span> <span class="st">&quot;number is a positive.&quot;</span>
    <span class="fu">|</span> number <span class="fu">&lt;</span> <span class="dv">0</span>  <span class="fu">=</span> <span class="st">&quot;number is a negative.&quot;</span>

<span class="ot">func2 ::</span> <span class="dt">Int</span><span class="ot">-&gt;</span><span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
func2 a b
    <span class="fu">|</span> a <span class="fu">&gt;</span> b  <span class="fu">=</span> <span class="st">&quot;a ia greater than b.&quot;</span>
    <span class="fu">|</span> a <span class="fu">==</span> b <span class="fu">=</span> <span class="st">&quot;a is equal to b.&quot;</span>
    <span class="fu">|</span> a <span class="fu">&lt;</span> b  <span class="fu">=</span> <span class="st">&quot;a is less than b.&quot;</span></code></pre>
<p>一般而言，排在最后的哨兵是<code>otherwise</code>，它能捕获一切条件。如：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">func1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
func1 number
    <span class="fu">|</span> number <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;number is equal to 0.&quot;</span>
    <span class="fu">|</span> otherwise   <span class="fu">=</span> <span class="st">&quot;number is not equal to 0.&quot;</span></code></pre>
<p>但需要注意，如果把<code>otherwise</code>放在第一个哨兵的位置，那么所有条件都会被<code>otherwise</code>捕获，只会执行<code>otherwise</code>对应的程序。</p>
<p><strong>注意</strong>:<code>|</code>符号前面至少要有一个空格的缩进，否则会有编译错误。</p>
<p>所有的哨兵也可以写在一行，但代码可读性不好，这一用法仅仅用于展示较短的函数。例如：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{- 返回两个可比较类型数据中的较大值。 -}</span>
<span class="co">{- 注意，haskell中函数名中可以有&quot;&#39;&quot;(单引号)。</span>
<span class="co"> - 此处这样用是为了与标准库中的 max 函数分开。</span>
<span class="co"> - -}</span>
<span class="ot">max&#39; ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a  
max&#39; a b <span class="fu">|</span> a <span class="fu">&gt;</span> b <span class="fu">=</span> a <span class="fu">|</span> otherwise <span class="fu">=</span> b</code></pre>
<h2 id="where-关键字">where 关键字</h2>
<p><code>where</code>关键字用于在一个作用域中实现绑定。<code>where</code>关键字既可以绑定名字，也可以定义函数。<code>where</code>关键字定义的名字只对本函数可见，不会污染其他函数的命名空间。</p>
<p><code>where</code>关键字用在函数的底部，在函数的最后来定义绑定。</p>
<h2 id="let-关键字">let 关键字</h2>
<p><code>let</code>绑定与<code>where</code>绑定类似，<code>let</code>绑定是一个表达式，允许在任何位置定义函数的局部变量。并且对不同的Guard可见性不同。</p>
<p><code>let</code>定义局部绑定的用法为：</p>
<pre><code>let [bindings] in [expressions]</code></pre>
<p><code>let</code>定义的绑定仅仅对<code>in</code>部分可见。在函数中，可以直接用</p>
<pre><code>let ...</code></pre>
<p>语句来定义局部变量和局部函数。</p>
<h2 id="case-语句">case 语句</h2>
<p>模式匹配也可以用<code>case</code>语句来实现，具体用法为：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">case</span> expression <span class="kw">of</span> pattern <span class="ot">-&gt;</span> result
                   pattern <span class="ot">-&gt;</span> result
                   <span class="fu">...</span></code></pre>
<p>函数参数的模式匹配只能在函数定义时使用，而<code>case</code>语句既可以用于函数定义时的参数匹配，也可以用在函数内部的表达式中。</p>
<h2 id="haskell-中的递归recursive">Haskell 中的递归(Recursive)</h2>
<p>使用递归函数求解的一个经典例子为求Fibonacci数列。Haskell中实现如下：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fibonacci ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
fibonacci n
    <span class="fu">|</span> n<span class="fu">==</span><span class="dv">0</span>      <span class="fu">=</span> <span class="dv">0</span>
    <span class="fu">|</span> n<span class="fu">==</span><span class="dv">1</span>      <span class="fu">=</span> <span class="dv">1</span>
    <span class="fu">|</span> otherwise <span class="fu">=</span> (fibonacci (n<span class="fu">-</span><span class="dv">1</span>))<span class="fu">+</span>(fibonacci (n<span class="fu">-</span><span class="dv">1</span>))</code></pre>
<p>函数式编程的一个特点是将对列表的遍历实现为对子列表的递归。例如使用递归的方法来求一个List的最大值：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">max&#39; ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
max&#39; []            <span class="fu">=</span> (error <span class="st">&quot;abcde&quot;</span>)
max&#39; [x]           <span class="fu">=</span> x
max&#39; (x<span class="fu">:</span>xs)
    <span class="fu">|</span> x <span class="fu">&gt;=</span> maxTail <span class="fu">=</span> x
    <span class="fu">|</span> otherwise    <span class="fu">=</span> maxTail
    <span class="kw">where</span> maxTail  <span class="fu">=</span> max&#39; xs</code></pre>
<p>用递归和函数式编程的思想实现快速排序算法：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">qsort ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
qsort []  <span class="fu">=</span> []
qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> qsort(filter (<span class="fu">&lt;</span> x) xs) <span class="fu">++</span> [x] <span class="fu">++</span> qsort(filter (<span class="fu">&gt;=</span>x) xs)</code></pre>
<p>用其他一些具有函数式编程特性的语法来实现快速排序同样很方便，比如Python：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> qsort(a):
<span class="kw">if</span> a == []:
    <span class="kw">return</span> []
<span class="kw">return</span> qsort(<span class="dt">list</span>(<span class="dt">filter</span>(<span class="kw">lambda</span> e:e&lt;a[<span class="dv">0</span>], a[<span class="dv">1</span>:]))) \
        + [a[<span class="dv">0</span>]] \
        + qsort(<span class="dt">list</span>(<span class="dt">filter</span>(<span class="kw">lambda</span> e:e&gt;=a[<span class="dv">0</span>], a[<span class="dv">1</span>:])))</code></pre>
<p>由此不难看出列表推导(List Comprehension)和递归(Recursive)的威力。</p>
<p>在使用递归来求解问题的时候，一定要注意边界条件，例如上例中的List为空的情形。</p>
