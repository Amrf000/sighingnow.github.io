---
title: Python Decorator
author: He Tao
date: 2015-02-01
tag: Python
category: 编程语言
layout: post
---

<p>Decorator, 装饰器。Decorator的用途在于允许在函数和类中嵌入或者修改代码。</p>
<h2 id="classmethod-and-staticmethod">classmethod and staticmethod</h2>
<pre><code>staticmethod(function)</code></pre>
<p>这将返回一个function的静态方法。把类的一个方法的声明为静态方法，具体用法如下:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> C:
    <span class="ot">@staticmethod</span>
    <span class="kw">def</span> f(arg1, arg2, ...): ...</code></pre>
<p>或者</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> C:
    <span class="kw">def</span> f(arg1, arg2, ...): ...
    f = <span class="dt">staticmethod</span>(f)</code></pre>
<!--more-->
<p>类的静态方法既可以被类调用也可以被类的实例调用，例如:</p>
<pre><code>C.f(...)</code></pre>
<p>或者:</p>
<pre><code>C(...).f(...)</code></pre>
<p><strong>注意</strong>，staticmethod 并不将类自身或其示例接收为隐含的第一个参数，在这一点上staticmethod 和 classmethod 存在区别。</p>
<pre><code>classmethod(function)</code></pre>
<p>这将返回function的一个类方法。具体用法如下：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> C:
    <span class="ot">@classmethod</span>
    <span class="kw">def</span> f(cls, arg1, arg2, ...): ...</code></pre>
<p>或者：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> C:
    <span class="kw">def</span> f(cls, arg1, arg2, ...): ...
    f = <span class="dt">classmethod</span>(f)</code></pre>
<p>类的classmethod既可以被类调用也可以被类的实例调用，例如:</p>
<pre><code>C.f(...)</code></pre>
<p>或者:</p>
<pre><code>C(...).f(...)</code></pre>
<p><strong>注意</strong>，classmethod 像将类的示例函数一样，将类自身接收为隐含的第一个参数。</p>
<h2 id="python-decorators-for-functions-and-methods">Python Decorators for Functions and Methods</h2>
<h3 id="函数decorator">函数decorator</h3>
<p>一个函数decorators用于函数定义，它位于在函数定义之前的一行。例如：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@decoFunc</span>
<span class="kw">def</span> aFunc():
    <span class="dt">print</span>(<span class="st">&#39;a Func is called&#39;</span>)</code></pre>
<p>当编译器经过这段代码时，<code>aFunc()</code>被编译然后将结果函数对象传递给<code>decoFunc</code>代码，后者创建一个类函数对象并取代原来的<code>aFunc()</code>。根据这一说法，那么：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@A</span>
<span class="ot">@B</span>
<span class="ot">@C</span>
<span class="kw">def</span> func(arg1, arg2, ...): ...</code></pre>
<p>等价于</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> func(arg1, arg2, ...): ...
func = A(B(C(func)))</code></pre>
<p>例如：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> decFunc(f):
    <span class="kw">def</span> inner(f):
        <span class="kw">return</span> <span class="dv">100</span>
    <span class="kw">return</span> inner

<span class="ot">@decFunc</span>
<span class="kw">def</span> aFunc(x):
    <span class="dt">print</span>(<span class="st">&#39;value x is </span><span class="ot">%d</span><span class="st">&#39;</span>%(x))
    <span class="dt">print</span>(<span class="st">&#39;aFunc called&#39;</span>)

<span class="dt">print</span>(aFunc(<span class="dv">10</span>))</code></pre>
<p>程序的输出结果为</p>
<pre><code>100</code></pre>
<p>并没有输出</p>
<pre><code>aFunc called</code></pre>
<p>也就是说，在装饰器函数中，函数<code>aFunc</code>的行为被改变了。</p>
<h3 id="类decorator">类decorator</h3>
<p>与函数decorator类似，也可以将类作为decorator，只要实现<code>__call__</code>方法即可。</p>
<p>一个类如果实现了<code>__call__</code>方法，那么这个类的对象便是可调用的。例如：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> decCls():
    <span class="kw">def</span> <span class="ot">__call__</span>():
        <span class="dt">print</span>(<span class="st">&#39;__call__ of decCls called.&#39;</span>)

decCls()()</code></pre>
<p>运行，输出：</p>
<pre><code>__call__ of decCls called.</code></pre>
<p>下来举一个将类作为decorator的例子：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> decCls():
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>, f):
        <span class="ot">self</span>.f = f
    <span class="kw">def</span> <span class="ot">__call__</span>(<span class="ot">self</span>, x):
        <span class="dt">print</span>(<span class="st">&#39;decorator called&#39;</span>)
        <span class="kw">return</span> <span class="dv">10000</span>

<span class="ot">@decCls</span>
<span class="kw">def</span> aFunc(x):
    <span class="dt">print</span>(<span class="st">&#39;value x is </span><span class="ot">%d</span><span class="st">&#39;</span>%(x))
    <span class="dt">print</span>(<span class="st">&#39;aFunc called&#39;</span>)

<span class="dt">print</span>(aFunc(<span class="dv">10</span>))</code></pre>
<p>此处就相当于</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> aFunc(x):
    <span class="dt">print</span>(<span class="st">&#39;value x is </span><span class="ot">%d</span><span class="st">&#39;</span>%(x))
    <span class="dt">print</span>(<span class="st">&#39;aFunc called&#39;</span>)
aFunc = decCls(aFunc)</code></pre>
<p>那么在调用<code>aFunc</code>的时候，其实是在调用<code>decCls(aFunc)</code>，也就是运行的是</p>
<pre><code>decCls(aFunc)(10)</code></pre>
<p>最后相当于调用的是装饰器类<code>decCls</code>的<code>__call__</code>方法。</p>
<h2 id="decorator的用途">decorator的用途</h2>
<p>decorator的一个很大的用途在于可以“掌控”一个函数的运行。看下面这段代码：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> fn_decorator(fn):
    <span class="kw">def</span> wrapper(*args):
        <span class="dt">print</span>(<span class="st">&#39;call wrapper&#39;</span>)
        <span class="kw">return</span> fn(*args)
    <span class="kw">return</span> wrapper

<span class="ot">@fn_decorator</span>
<span class="kw">def</span> fn(...):
    <span class="co"># ...</span></code></pre>
<p>在这儿，调用<code>fn</code>时其实是在调用<code>wrapper</code>，因此，<code>wrapper</code>是可以控制<code>fn</code>是否运行的。</p>
<h2 id="decorator带参数">Decorator带参数</h2>
<p>之前的Decorator都是没有参数的，那么，有参数的Decorator又是如何工作的呢？</p>
<p>如果是单个带参数的Decorator，那么：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@dec</span>(param)
<span class="kw">def</span> aFunc():
    <span class="co">#...</span></code></pre>
<p>等价于</p>
<pre><code>def aFunc():
aFunc = dec(param)(aFunc)</code></pre>
<p>如果是多重Decorator，并且带参数，那么有：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@dec_a</span>(params1)
<span class="ot">@dec_b</span>(params2)
<span class="ot">@dec_c</span>(params3)
<span class="kw">def</span> method(args):
    <span class="kw">pass</span></code></pre>
<p>等价于</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> method(args):
    <span class="kw">pass</span>
method = dec_a(params1)(dec_b(params2)(dec_c(params)(method))) </code></pre>
<p>可见，Decorator还是很灵活很强大的。</p>
<h2 id="应用举例">应用举例</h2>
<p>定义一个装饰器(Decorator)来测量函数的执行时间：</p>
<pre class="sourceCode python"><code class="sourceCode python">
<span class="ch">import</span> time

<span class="kw">def</span> fn_timer(f):
    <span class="kw">def</span> wrapper(*args):
        t0 = time.time()
        ans = f(*args)
        t1 = time.time()
        <span class="dt">print</span>(<span class="st">&#39;f start at </span><span class="ot">%f</span><span class="st">, end at </span><span class="ot">%f</span><span class="st">, running </span><span class="ot">%f</span><span class="st">&#39;</span>%(t0,t1,t1-t0))
        <span class="kw">return</span> ans
    <span class="kw">return</span> wrapper</code></pre>
<p>使用这个装饰器的例子：</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ot">@fn_timer</span>
<span class="kw">def</span> sum_fn(n):
    ans = <span class="dv">0</span>
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, n):
        ans += i
    <span class="kw">return</span> ans

<span class="dt">print</span>(sum_fn(<span class="dv">10000000</span>))</code></pre>
<p>这样，便可以在不改变<code>sum_fn</code>的接口和内部实现的前提下实现新的功能。</p>
<h2 id="参考">参考</h2>
<ol style="list-style-type: decimal">
<li><a href="https://www.python.org/dev/peps/pep-0318/">PEP 318</a></li>
</ol>
