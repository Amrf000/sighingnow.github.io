---
title: Rust-Book Learn Rust
author: He Tao
date: 2015-06-05
tags: Rust
category: 编程语言
layout: post
---

<h2 id="guessing-game">Guessing Game</h2>
<p>Our program will generate a random integer between one and a hundred. It will then prompt us to enter a guess. Upon entering our guess, it will tell us if we’re too low or too high. Once we guess correctly, it will congratulate us.</p>
<h3 id="set-up">Set Up</h3>
<p>创建项目：</p>
<pre><code>cargo new guessing_game --bin</code></pre>
<p><code>--bin</code>表示创建二进制可执行程序(binary)而不是程序库(library)。</p>
<p>项目目录结构(<code>cargo build</code>之后)：</p>
<pre><code>│  .gitignore
│  a.txt
│  Cargo.lock
│  Cargo.toml
│  
├─src
│      main.rs
│      
└─target
    └─debug
        │  guessing_game.exe
        │  
        ├─.fingerprint
        │  └─guessing_game-375af41f7208f0f5
        │          bin-guessing_game
        │          dep-bin-guessing_game
        │          
        ├─build
        ├─deps
        ├─examples
        └─native</code></pre>
<h3 id="processing-a-guess">Processing a Guess</h3>
<p>代码(src/main.rs)：</p>
<pre><code>use std::io;
fn main() {
    println!(&quot;Guess the number!&quot;);
    println!(&quot;Please input your guess.&quot;);
    let mut guess = String::new();
    io::stdin().read_line(&amp;mut guess)
        .ok()
        .expect(&quot;Failed to read line&quot;);
    println!(&quot;You guessed: {}&quot;, guess);
}</code></pre>
<p>代码解释：</p>
<p><code>use std::io</code>: 使用标准输入输出库(IO library)。</p>
<p><code>let</code>：let语句用户变量绑定(variable bindings)。默认是<code>immutable</code>，如果想要<code>mutable</code>类型需要手动指明。</p>
<p><code>String</code>: A String is a growable, UTF-8 encoded bit of text.</p>
<p><code>::new</code>: static method. create a new, empty String.</p>
<p><code>std::io::stdin()</code>: returns a handle to the standard input for your terminal. 返回一个指向标准输入的句柄。</p>
<p><code>.read_line(&amp;mut line)</code>: <code>read_line</code>是<code>stdin()</code>获得的IO句柄对象的一个方法，可以接受一个可变的String的<strong>引用(Reference)</strong>作为参数。</p>
<p><code>.ok().expect()</code>: <code>read_line()</code>返回一个<code>io::Result</code>, <code>Result</code>的目的在于编码错误信息(encode error handing information)。<code>io::Result</code> has an <code>ok()</code> method, which says ‘we want to assume this value is a successful one. If not, just throw away the error information’. The <code>ok()</code> method returns a value which has another method defined on it: <code>expect()</code>. The <code>expect()</code> method takes a value it’s called on, and if it isn’t a successful one, <code>panic!</code>s with a message you passed it. A <code>panic!</code> like this will cause our program to crash, displaying the message. 这应该是Rust的异常机制的体现，不应为局部的一个错误而直接导致整个程序的Crash。如果去掉<code>.ok().expect()</code>，编译时会产生一个Waring: unused value must be used.这是因为：Rust is trying to tell you that you haven’t handled a possible error.</p>
<p><code>println!(&quot;{}&quot;, line);</code>: <code>{}</code>是一个占位符，类似于格式化输出<code>printf</code>中的格式化参数。如果需要输出多个参数，写成<code>println!(&quot;{}, {}&quot;, arg1, arg2)</code>即可。</p>
<h3 id="generating-a-secret-number">Generating a secret number</h3>
<p>Rust标准库中并没有生成随机数的函数，因此，需要依赖第三方库来实现这一功能。为了解决依赖问题，需要修改<code>Cargo.toml</code>文件。</p>
<pre><code>[dependencies]
rand=&quot;0.3.0&quot;</code></pre>
<p>然后，<code>Cargo build</code>, Cargo会自动去下载依赖。如果这个库依赖其他第三方库，Cargo也会在下载或者构建这个库的时候解决这些依赖。</p>
<p><code>Crates.io</code>: Crates.io is where people in the Rust ecosystem(生态环境) post their open source Rust projects for others to use.</p>
<p><code>Cargo.lock</code>: 这个文件用于锁定当前的可用的外部依赖的版本，以防止随着外部依赖的自动更新而引入错误(we’ll stay at x.x.x until we explicitly upgrade)。Cargo升级命令：<code>cargo update</code>。</p>
<p>生成随机数的代码：</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate rand;
<span class="kw">use</span> std::io;
<span class="kw">use</span> rand::Rng;

<span class="kw">fn</span> main() {
    <span class="kw">let</span> num = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
    <span class="ot">println!</span>(<span class="st">&quot;random number: {}&quot;</span>, num);
}</code></pre>
<p>代码解释：</p>
<p><code>extern crate rand;</code>: we can use extern crate to let Rust know we’ll be making use of it.</p>
<p><code>rand::thread_rng()</code>: We use the rand::thread_rng() function to get a copy of the random number generator, which is local to the particular thread of execution we’re in.</p>
<h3 id="comparing-guesses">Comparing guesses</h3>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Too small!&quot;</span>),
    Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Too big!&quot;</span>),
    Ordering::Equal   =&gt; <span class="ot">println!</span>(<span class="st">&quot;You win!&quot;</span>),
}</code></pre>
<p><code>match</code>: 模式匹配，与Haskell很像。</p>
<p><code>Ordering</code>：枚举(<code>enum</code>)类型。</p>
<h3 id="looping">Looping</h3>
<p>示例语法：</p>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {
    <span class="co">// ...</span>
    <span class="kw">break</span>; <span class="co">// jump out of loop.</span>
}</code></pre>
<pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> guess: <span class="kw">u32</span> = <span class="kw">match</span> guess.trim().parse() {
    <span class="kw">Ok</span>(num) =&gt; num,
    <span class="kw">Err</span>(_) =&gt; <span class="kw">continue</span>,
};</code></pre>
<p>解释：</p>
<p><code>Ok</code> is a success, and <code>Err</code> is a failure.</p>
<p>We don’t care what kind of error it is, so we just use <code>_</code> instead of a name. 很像是Haskell中的匿名哨兵。</p>
<h2 id="dining-philosophers">Dining Philosophers</h2>
<p>著名的哲学家进餐问题的模拟。</p>
<p>使用线程、泛型Vector、map, collect。有很类似于Java 8的并行流(Parallel Stream)里的概念。</p>
<h2 id="rust-inside-other-languages">Rust Inside Other Languages</h2>
<p>FFI编程接口，与Ruby, Python, NodeJS等语言通过动态链接库进行交互。</p>
<p>例如，在多线程方面可以克服这些语言的全局解释器锁(Global Interpreter Lock)对并发的限制。</p>
<!---------------------------------links------------------------------>
