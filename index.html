<!DOCTYPE HTML>

<html lang="en">
  
<head>
  <meta charset="utf-8">
  
  <title>DHDave</title>
  <meta name="author" content="DHDave">
  
  <meta name="description" content="DHDave&#39;s Personal Page.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="DHDave"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <meta http-equiv="Content-Language" content="en"/>
  

  <link href="/img/favicon.png" rel="icon">
  
    <link rel="apple-touch-icon" href="/img/apple-icon.png">
    <link rel="apple-touch-icon-precomposed" href="/img/apple-icon.png">
    

  <link rel="alternate" href="/atom.xml" title="DHDave" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <style type="text/css">
  /* Tim Pietrusky advanced checkbox hack (Android <= 4.1.2) */
body{ -webkit-animation: bugfix infinite 1s; }
@-webkit-keyframes bugfix { from {padding:0;} to {padding:0;} }

  

  
    article .post-content-index .entry{max-height: 550px; overflow:hidden;}
  
</style>

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'null', 'auto');
  ga('send', 'pageview');
 
</script>




  
    
      <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400|Playball' rel='stylesheet' type='text/css'>
    
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.11.1.min.js"></script>

  



</head>


<body>
  <header id="header" class="inner"><div class="padding">
	<div class="alignleft logo">
	  <h1><a href="/">DHDave</a></h1>
	</div>
	<nav id="main-nav" class="alignright">
		<input type="checkbox" id="toggle" />
		<label for="toggle" class="toggle" data-open="Main Menu" data-close="Close Menu" onclick><i class="fa fa-bars"></i></label>
	  <ul class="menu">
	    
	      <li><a href="/">Home</a></li>
	    
	      <li><a href="/archives">Archives</a></li>
	    
	    
	  </ul>
	</nav>
	<div class="clearfix"></div>
</div>
</header>
  <div id="page-heading-wrap">
  	<div class="inner">
      <div class="padding">
    		
          <h2>DHDave&#39;s Personal Page</h2>
        
      </div>
  	</div>
  </div>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper" class="padding">
  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/03/17/algorithm/backpack/">背包问题总结</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-03-17T15:11:51.000Z">2015-03-17</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/03/17/algorithm/backpack/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>背包问题是动态规划思想和方法的经典应用问题，本文将从0-1背包，完全背包和混合背包三个角度来分析简单背包问题的求解方法。</p>
<h2 id="背包问题">背包问题</h2><p>背包问题本质上是规划型问题，问题的核心在于在满足约束条件下，找到一种选择方案，使得目标值达到最优。通过动态规划的方法，可以将此类问题限制在多项式复杂度的时间内求解。</p>
<h2 id="0-1背包">0-1背包</h2><h3 id="0-1背包问题的描述">0-1背包问题的描述</h3><p>有N件物品和一个总容量为V的背包，第<code>i</code>件物品的费用是<code>c[i]</code>，价值是<code>w[i]</code>。求解将哪些物品装入背包可以使得装入的物品的价值总和最大。</p>
<h3 id="0-1背包问题的动态转移">0-1背包问题的动态转移</h3><p>动态转移方程：</p>
<p>$$ f[i][v] = max{f[i-1][v], f[i-1][v-c[i]]+w[i]} $$</p>
<p>解释；对于每一个状态，在决策是否装入第<code>i</code>件时，选取装入与不装入该件物品的价值和的最大值。如果放入第i件物品，那么前<code>i</code>件物品最多只能占用<code>v-c[i]</code>的体积，则价值和为<code>f[i-1][w-c[i]]</code>，如果不装入第<code>i</code>件物品，那么价值和仍为前<code>i-1</code>件物品的价值和。</p>
<h3 id="时间和空间复杂度分析">时间和空间复杂度分析</h3><p>该算法时间复杂度为O(V*N)，如果只需要求解价值总和的最大值，由于只需要根据价值进行DP，空间复杂度可以优化到O(N)。</p>
<p>代码表述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = v; j &gt;= c[i]; j--) &#123;</span><br><span class="line">truetruef[j] = max(f[j], (f[j-c[i]] + w[i]));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/** 不优化空间的写法</span><br><span class="line">         * f[i][j] = max(f[i-1][j], (f[i-1][j-c[i]] + w[i]));</span><br><span class="line">         */</span></span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回溯法推导0-1背包问题的最优方案">回溯法推导0-1背包问题的最优方案</h3><p>可以通过回溯的方法求解到底放入了那些背包，在这个求解过程中，不能进行空间的优化，因此，空间占用为O(V*N)。具体代码表述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * sum 值为之前DP求出的最大价值。</span><br><span class="line"> * used 数组用来标记每件物品是否装入。</span><br><span class="line"> * 如果第 i 件物品装入了，则 used[i] = true；</span><br><span class="line"> * 否则，used[i] = false。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">bool</span> used[n] = &#123;<span class="keyword">false</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(f[i][sum] &gt; f[i-<span class="number">1</span>][sum]) &#123;</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line">        sum -= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包">完全背包</h2><h3 id="完全背包问题的描述">完全背包问题的描述</h3><p>有N种物品和一个容量为V的背包，每种物品有无限件可用。第i件物品的费用为<code>c[i]</code>，价值是<code>w[i]</code>。求解将哪些物品装入背包可以使得装入的物品的价值总和最大，并且物品总费用不能超过背包容量。</p>
<h3 id="完全背包问题的状态转移">完全背包问题的状态转移</h3><p>显然，完全背包问题可以转换为0-1背包问题，通过总体积来限制背包个数即可。不难得出以下的状态转移方程：</p>
<p>$$ f[i][v] = max{f[i-1][v-k \times c[i]] + k \times w[i]} $$</p>
<p>其中，</p>
<p>$$ 0 \leq k \times c[i] \leq v $$</p>
<p>分析得知，此状态转移求解每个状态的时间已经不是常数了。分析完全背包问题的特点，可以作出优化。分析思路：如果两件物品 <code>i,j</code> 满足 <code>c[i] &lt;= c[j]</code> 且 <code>w[i] &gt;= w[j]</code> , 则将物品j去掉，不用考虑。优化的正确性在于任何情况下都可以用物美价廉的i替换j，至少不会比替换前的方案更差。但此优化在最坏情形下并不能改善问题的复杂度规模，因为在最坏情况下任何一件物品都不能忽略。</p>
<p>考虑到每种物品都有无限件可以选，因此，在选择第i件物品时，只要根据一个绝无已经选入第i种物品的子结果<code>f[i-1][v-[i]]</code>即可。在具体实现上，只要改变V的递推顺序就行。</p>
<p>代码表述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = c[i]; j &lt;= v; ++j) &#123;</span><br><span class="line">        f[j] = max(f[j], f[j-c[i]]+w[i]);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法复杂度分析">算法复杂度分析</h3><p>优化后的时间复杂度为O(N*V)，空间复杂度为O(V)。</p>
<h2 id="混合背包">混合背包</h2><h3 id="混合背包问题的描述">混合背包问题的描述</h3><p>有N种物品和一个容量为V的背包，第i种物品最多有<code>n[i]</code>件可用，每件费用为<code>c[i]</code>，价值为<code>w[i]</code>。求解选择方案使得物品价值总和最大，且总重量不超过背包容量，每件物品的数量也不超过其限制。</p>
<h3 id="混合背包的朴素求解">混合背包的朴素求解</h3><p>同混合背包类似，完全背包问题也可以建模为0-1背包模型，但无法在常数时间内求解每个状态，其时间复杂度会达到O(n^3)。</p>
<h3 id="混合背包的二进制拆分求解">混合背包的二进制拆分求解</h3><p>二进制拆分实际上是对朴素求解算法的优化。通过二进制拆分可以减少状态数。其原理基于每一个正整数都可以写成数个2的自然数次幂之和，并且，每两个幂的次数都不相同。此优化方案可以将时间复杂度优化到O(n^2*log(n))。</p>
<p>代码描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">true<span class="keyword">int</span> s[mi][<span class="number">2</span>], k = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">true<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">truetrue<span class="keyword">if</span>(m[i] &lt;= k) &#123;</span><br><span class="line">truetruetrues[t][<span class="number">0</span>] = m[i] * c[i], s[t++][<span class="number">1</span>] = m[i] * w[i];</span><br><span class="line">truetruetrue<span class="keyword">break</span>;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="keyword">else</span> &#123;</span><br><span class="line">    		s[t][<span class="number">0</span>] = k * c[i], s[t++][<span class="number">1</span>] = k * w[i];</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetruem[i] = m[i] - k;</span><br><span class="line">truetruek = k * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">truetrue<span class="keyword">for</span>(j = v; j &gt;= s[t][<span class="number">0</span>]; j--) &#123;</span><br><span class="line">truetruetruef[j] = max(f[j], (f[j-s[t][<span class="number">0</span>]] + s[t][<span class="number">1</span>]));</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="混合背包的单调队列优化">混合背包的单调队列优化</h3><p>该算法的思想是根据当前体积模当前物品体积的余数进行分组，每一组的状态都可以有前面的任意一组转换而来。问题可以转化为固定长度区间求最值问题。采用单调队列，可以将时间复杂度优化到O(N*V)。</p>
<p>代码表述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * a, b 均为辅助队列，其中，b 是一个单调队列。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优化最多可用的物品件数</span></span><br><span class="line">    <span class="keyword">if</span>(!n[i] || v/c[i] &lt; n[i]) &#123;</span><br><span class="line">        n[i] = v / c[i];   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; c[i]; ++d) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; <span class="comment">// 初始化队列参数，清空队列。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (v-d)/c[i]; ++j) &#123;</span><br><span class="line">            <span class="comment">// j 对应的体积为 j*c[i]+d。</span></span><br><span class="line">            <span class="keyword">int</span> x = j, y = f[j*c[i]+d] - j*w[i]; <span class="comment">// 退化</span></span><br><span class="line">            <span class="comment">// 插入队列</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r &amp;&amp; b[r] &lt;= y) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[++r] = x;</span><br><span class="line">            b[r] = y;</span><br><span class="line">            <span class="comment">// 如果队首元素已经失效，删除失效点。</span></span><br><span class="line">            <span class="keyword">if</span>(a[l] &lt; j - n[i]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取得队头，进行更新。</span></span><br><span class="line">            f[j*c[i]+d] = b[l] + j*w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2><ol>
<li>《背包问题九讲》</li>
<li>《浅谈几类背包问题》，徐持衡，2009年信息学奥林匹克中国国家集训队论文 </li>
<li><a href="http://blog.csdn.net/flyinghearts/article/details/5898183" title="flyinghearts的专栏" target="_blank" rel="external">多重背包O(N*V)算法详解(使用单调队列)</a></li>
</ol>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/03/17/algorithm/backpack/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/28/programming language/haskell/dive_into_haskell_4_higher_order_function/">Dive Into Haskell(4) 高阶函数</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-27T16:00:00.000Z">2015-02-28</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/28/programming language/haskell/dive_into_haskell_4_higher_order_function/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="返回函数的函数">返回函数的函数</h2><p>以求最大值的函数<code>max&#39;</code>为例，</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">max'</span> :: (<span class="type">Ord</span> a) =&gt; a-&gt;a -&gt; a</span><br><span class="line"><span class="title">max'</span> x y</span><br><span class="line">    | x &gt;= y = x</span><br><span class="line">    | x &lt; y  = y</span><br></pre></td></tr></table></figure>
<p>调用该函数时可以这样做：</p>
<pre><code><span class="built_in">max</span>' <span class="number">1</span> <span class="number">2</span>
</code></pre><p>也可以这样做：</p>
<pre><code><span class="list">(<span class="keyword"><span class="built_in">max</span></span>' <span class="number">1</span>)</span> <span class="number">2</span>
</code></pre><p>原因是这个函数的定义也可以看成是</p>
<pre><code><span class="label">max' ::</span> (Ord <span class="literal">a</span>) =&gt; <span class="literal">a</span> -&gt; (<span class="literal">a</span>-&gt;<span class="literal">a</span>)
</code></pre><p>即一个参数为<code>(Ord a)</code>类型，返回函数<code>(Ord a) =&gt; (a-&gt;a)</code>的函数。这样的函数就是一个高阶函数。</p>
<h2 id="高阶函数的部分应用">高阶函数的部分应用</h2><p>在Haskell中，所有的多个参数的函数都叫做科里函数(Curried functions)。高阶函数的一个好处是<strong>部分应用</strong>。即可以通过传递给函数一部分参数来构造一个新的函数。如：</p>
<pre><code><span class="keyword">let</span> <span class="keyword">max</span><span class="string">'1  = max'</span> <span class="number">1</span>
</code></pre><p>便构造了一个一元函数，该一元函数的作用是返回一个数与<code>1</code>中的较大值。使用该新函数时，只需要这样调用就好：</p>
<pre><code><span class="built_in">max</span>'<span class="number">1</span> <span class="number">3</span>
</code></pre><p>这样便求出了<code>1</code>和<code>3</code>两个数中的较大者。</p>
<p>对于中缀函数，还可以通过截断(section)的方法进行部分应用。例如，</p>
<pre><code><span class="keyword">let</span> <span class="keyword">max</span><span class="string">'2 = (`max'</span><span class="string">` 2)
{- 注意，此处的括号用于指定优先级，不能省略。 -}</span>
</code></pre><p>调用时：</p>
<pre><code><span class="built_in">max</span>'<span class="number">2</span> <span class="number">3</span>
</code></pre><p>便求出了<code>2</code>和<code>3</code>中的较大者。</p>
<p>通过中缀函数进行应用的另一个例子：</p>
<pre><code><span class="keyword">let</span> <span class="variable">sumWith2 =</span> (+ <span class="number">2</span>)
</code></pre><p>或者：</p>
<pre><code><span class="label">sumWith2 ::</span> (Integral <span class="literal">a</span>) =&gt; <span class="literal">a</span> -&gt; <span class="literal">a</span>
sumWith2 = (+ <span class="number">2</span>)
</code></pre><p>这样便定义了一个求一个数与<code>2</code>的和的函数。</p>
<h2 id="函数用作参数—map_与_filter">函数用作参数—map 与 filter</h2><p>Haskell中，也可以将一个函数用作参数。例如标准库中的<code>map</code>和<code>filter</code>函数。</p>
<pre><code>map :: <span class="function"><span class="params">(a -&gt; b)</span> -&gt;</span> [a]<span class="function"> -&gt;</span> [b]
filter :: <span class="function"><span class="params">(a -&gt; Bool)</span> -&gt;</span> [a]<span class="function"> -&gt;</span> [a]
</code></pre><p>通过上文提到的函数的部分应用，实现这两个函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">map</span> _ [] = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = (f x) : (map f xs)</span><br><span class="line"></span><br><span class="line"><span class="title">filter</span> :: (a-&gt;<span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter</span> _ [] = []</span><br><span class="line"><span class="title">filter</span> f (x:xs)</span><br><span class="line">    <span class="comment">&#123;- The list has only one item. -&#125;</span></span><br><span class="line">    | f x       = x : (filter p xs) <span class="comment">&#123;- x if (f x) == True else None -&#125;</span></span><br><span class="line">    | otherwise = (filter f xs)</span><br></pre></td></tr></table></figure>
<p>再回顾之前提到的快速排序函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">qsort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">qsort</span> []  = []</span><br><span class="line"><span class="title">qsort</span> (x:xs) = qsort(filter (&lt; x) xs) ++ [x] ++ qsort(filter (&gt;=x) xs)</span><br></pre></td></tr></table></figure>
<p>此处用<code>filter</code>函数来从List选择元素，而<code>(&lt; x)</code>是二元函数的中缀形式的局部应用。</p>
<h2 id="Lambda表达式">Lambda表达式</h2><p>Lambda表达式就是匿名函数。有时，我们需要传给高阶函数一个函数，而这函数我们只会用这一次，这就弄个特定功能的 Lambda。</p>
<p>编写Lambda，就写个<code>\\</code>，后面是空格隔开的参数。然后是<code>-&gt;</code>然后是函数体。一般来说，lambda都括在括号里。例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;- 对List中的值逐项求平方。 -&#125;</span></span><br><span class="line"><span class="title">map</span> (\a -&gt; a*a) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;- 多个参数的lambda</span><br><span class="line"> - 注意多个参数不能用"()"括起来，否则会出错。</span><br><span class="line"> - -&#125;</span></span><br><span class="line">(\a b -&gt; a+b) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;- Lambda中使用模式匹配</span><br><span class="line"> - 注意，lambda中不能为参数设置多个模式。</span><br><span class="line"> - -&#125;</span></span><br><span class="line"><span class="title">map</span> (\(a, b) -&gt; a+b) [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>
<p>通常lambda 都是括在括号中，否则，后面的整个语句都将作为lambda的函数体。</p>
<p>由于有科里化，以下两种表达形式等价：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum'</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">sum'</span> x y z = x+y+z</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum'</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">sum'</span> \x -&gt; \y -&gt; \z -&gt; x+y+z</span><br></pre></td></tr></table></figure>
<h2 id="List折叠(Fold)">List折叠(Fold)</h2><h3 id="fold">fold</h3><p>有关函数式编程的另一个应用是列表折叠。主要有以下两组函数：</p>
<ul>
<li>foldl, foldr</li>
<li>foldl1, foldr1</li>
</ul>
<p>foldl和foldr类似，函数的定义为：</p>
<pre><code>foldl <span class="symbol">:</span><span class="symbol">:</span> (b-&gt;a-&gt;b) -&gt; b -&gt; [a] -&gt; b
foldr <span class="symbol">:</span><span class="symbol">:</span> (b-&gt;a-&gt;b) -&gt; b -&gt; [a] -&gt; b
</code></pre><p>以b为初值，对整个列表进行函数<code>(b-&gt;a-&gt;b)</code>的迭代，方向前者向左，后者向右。</p>
<p>foldl1和foldr1类似，函数定义为：</p>
<pre><code><span class="label">foldl1 ::</span> (<span class="literal">a</span>-&gt;<span class="literal">a</span>-&gt;<span class="literal">a</span>) -&gt; [<span class="literal">a</span>] -&gt; <span class="literal">a</span>
<span class="label">foldr1 ::</span> (<span class="literal">a</span>-&gt;<span class="literal">a</span>-&gt;<span class="literal">a</span>) -&gt; [<span class="literal">a</span>] -&gt; <span class="literal">a</span>
</code></pre><p>这两个函数以List的第一个元素为初值，对后面的所有元素进行迭代。方向前者向左，后者向右。</p>
<h3 id="scan">scan</h3><p>scan积累了fold函数执行过程中产生的左右变量，并返回一个包含这些结果的List。</p>
<pre><code><span class="label">scanl ::</span> (b-&gt;<span class="literal">a</span>-&gt;b)-&gt;b-&gt;[<span class="literal">a</span>]-&gt;[b]
<span class="label">scanr ::</span> (b-&gt;<span class="literal">a</span>-&gt;b)-&gt;b-&gt;[<span class="literal">a</span>]-&gt;[b]

<span class="label">scanl1 ::</span> (<span class="literal">a</span>-&gt;<span class="literal">a</span>-&gt;<span class="literal">a</span>)-&gt;[<span class="literal">a</span>]-&gt;[<span class="literal">a</span>]
<span class="label">scanlr ::</span> (<span class="literal">a</span>-&gt;<span class="literal">a</span>-&gt;<span class="literal">a</span>)-&gt;[<span class="literal">a</span>]-&gt;[<span class="literal">a</span>]
</code></pre><h2 id="\$_的函数调用">\$ 的函数调用</h2><p><code>$</code>函数又称为函数应用符(Function Application Operator)。作用是改变函数调用的优先级。通常，普通的函数调用有最高的优先级（左结合），而<code>$</code>函数调用的优先级最低（右结合）。例如：<code>sqrt 5+5</code>的值为<code>7.236</code>，等于<code>(sqrt 5)+5</code>，然而，<code>sqrt $ 5+5</code>的值为<code>3.162</code>，等于<code>sqrt (5+5)</code>。</p>
<p><code>$</code>函数调用还可以把数据转换成函数。示例：</p>
<pre><code><span class="function"><span class="title">map</span> <span class="params">($ <span class="number">1</span>)</span> [<span class="params">(<span class="number">1</span>+)</span>, <span class="params">(<span class="number">1</span>*)</span>, <span class="params">(<span class="number">1</span>^)</span>, <span class="params">(^<span class="number">1</span>)</span>]</span>
</code></pre><h2 id="函数组合">函数组合</h2><p>函数组合(Function composition)也是Haskell中的一个重要特性。函数组合的运算符为<code>.</code>，定义如下：</p>
<pre><code><span class="function"><span class="params">(.)</span> :: <span class="params">(b-&gt;c)</span>-&gt;</span><span class="function"><span class="params">(a-&gt;b)</span>-&gt;</span>a-&gt;c
</code></pre><p>也就是：</p>
<pre><code>(f .<span class="keyword">g</span>) = \x -&gt; <span class="literal">f</span>(<span class="keyword">g</span> x)
</code></pre><p>point free style 更强调函数的组合方式而非数据的传递方式。这种程序逻辑更加简洁明了。可以通过这种方式将一系列函数组合在一起从而形成一个复杂的函数。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/28/programming language/haskell/dive_into_haskell_4_higher_order_function/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/26/algorithm/max_flow/">最大流算法</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-25T16:00:00.000Z">2015-02-26</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/26/algorithm/max_flow/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="定理">定理</h2><ol>
<li>增广路定理</li>
</ol>
<p>对于流 <i>f</i>，若残留网络<i>G<sub>f</sub></i>不存在增广路，则 <i>f</i> 为流网络 <i>G</i> 的最大流。</p>
<ol>
<li>最大流最小割定理</li>
</ol>
<p>定义流网络G的切割(cut)，为流网络的点集V的一个划分[S, T]，且源点source在S中，汇点sink在T中。从S到T的边称为割边。切割的流量即从S到T的边的流量之和。</p>
<p>在网络 <i>G</i> 中 [<i>S</i>, <i>T</i> ] 为最小的切割，<i>f</i> 为最大流，则有 | <i>S</i> | = | <i>f</i> |。</p>
<h2 id="枚举算法">枚举算法</h2><p>以最小割最大流定理为基础，可以通过求解最小割的方法来求解最大流。具体思路是枚举个点在S中还是在G中，算出所有情况流量的最小值，即为流网络的最大流量。不难分析出枚举算法的时间复杂度为O(2<sup>|V|</sup>|E|)。</p>
<p>枚举算法具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Enumeration algorithm.</span><br><span class="line"> * source = 0, sink = n-1.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">// enumerate all cut (S set).</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> state = <span class="number">0</span>; state &lt;= (<span class="number">1</span>&lt;&lt;(n-<span class="number">2</span>)); ++state) &#123; </span><br><span class="line">        <span class="keyword">int</span> s = (state&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>, tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n-<span class="number">1</span>; ++u) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; n; ++v) &#123;</span><br><span class="line">                <span class="keyword">if</span>((state&gt;&gt;u)&amp;<span class="number">1</span> == <span class="number">1</span> &amp;&amp; (state&gt;&gt;v)&amp;<span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp += c[i][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flow = flow &gt; tmp ? flow : tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增广路算法">增广路算法</h2><p>根据增广路定理，不难想到，不断在残余网络中寻找增广路进行增广，直到找不到增广路为止。即可求解出源点和汇点之间的最大流量。可以通过以下几种方式来寻找增广路。</p>
<h3 id="深度优先搜索">深度优先搜索</h3><p>只要残余网络中还存在增广路，那么对网络流图每进行一次DFS遍历，便可以找到一条从源点到汇点的增广路。若为整数网络，则找到的增广路的流量至少为1，因此，算法复杂度为O(|E|c)(c为最大流量)。</p>
<p>算法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == sink) &#123;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[x]) &#123; <span class="comment">// 有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, flow = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[x][i] &amp;&amp; (flow = dfs(x, low&lt;?c[x][i]))) &#123;</span><br><span class="line">            c[x][i] -= flow;</span><br><span class="line">            c[i][x] += flow;</span><br><span class="line">            <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span>(tmp = dfs(s, <span class="number">0x7fffffff</span>)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        flow += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用深度优先策略寻找增广路时，可以使用当前弧优化。即记录每个节点当前已经枚举到了哪个节点，下一次搜索时从当前节点开始搜索。</p>
<p>实现时，只需要用一个额外的数组记录当前弧(current arc)即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == sink) &#123;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vis[x]) &#123; <span class="comment">// 有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ii = <span class="number">0</span>, i = cur[x], flow = <span class="number">0</span>; ii &lt; n; ++ii, i = (i+<span class="number">1</span>==n?<span class="number">0</span>:i+<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[x][i] &amp;&amp; (flow = dfs(x, low&lt;?c[x][i]))) &#123;</span><br><span class="line">            cur[x] = i;</span><br><span class="line">            c[x][i] -= flow;</span><br><span class="line">            c[i][x] += flow;</span><br><span class="line">            <span class="keyword">return</span> flow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索">广度优先搜索</h3><p>采用广度优先搜索的策略来寻找增广路径，不难证明最多只需要O(|V||E|)次增广，每次寻找增广路径的复杂度为O(|E|)。因此，算法总复杂度为O(|V||E|<sup>2</sup>)。这便是求解最大流问题的Edmond-Karp算法。</p>
<p>实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, l, r, flow(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis)) ; vis [source]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));low[s]=<span class="number">2147483647</span>;</span><br><span class="line">        q[<span class="number">0</span>]=source; l=<span class="number">0</span>; r=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">            u=q[l++];</span><br><span class="line">            <span class="keyword">for</span>(v=<span class="number">1</span>; v&lt;=n; v++) &#123; </span><br><span class="line">                <span class="keyword">if</span>(!vis[v] &amp;&amp; c[u][v]&gt;f[u][v]) &#123;</span><br><span class="line">                    vis [v]=<span class="number">1</span>; pre[v]=u; q[r++]=v;</span><br><span class="line">                    low[v]=c[u][v]−f[u][v]; </span><br><span class="line">                    <span class="keyword">if</span>(low[v]&gt;low[u]) &#123; </span><br><span class="line">                        low[v]=low[u];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (low[sink]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            u=t;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                f[pre[u]][u]+=low[sink]; </span><br><span class="line">                f[u][pre[u]]−=low[sink]; </span><br><span class="line">                u=pre[u];</span><br><span class="line">            &#125; <span class="keyword">while</span>(u!=s);</span><br><span class="line">            ﬂow+=low[sink];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(low[sink]&gt;<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ﬂow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标号法(SAP)">标号法(SAP)</h3><p>SAP, Shorest Argument Path，最短增广路算法。</p>
<p>与EK算法相比，SAP算法引入了距离标号，用一个<code>dis</code>数组来表示每个节点距汇点的最短距离。距离标号<code>dis</code>数组满足以下两个条件：</p>
<ol>
<li><code>dis[sink] = 0</code></li>
<li>对于残留网络中的一条弧(u, v) 有 <code>dis[u] &lt;= dis[v] + 1</code>。</li>
</ol>
<p>对于残留网络中的一条弧(u, v)满足<code>dis[u]=dis[v]+1</code>,则称弧(u, v) 为允许弧。由允许弧组成的一条从源点到汇点的路径称为允许路径。不难分析出允许路径是残留网络中的一条最短增广路。应用标号算法每次增广只需要O(V)的时间。因此，SAP算法的时间复杂度为O(V<sup>2</sup>*E)</p>
<h4 id="SAP算法的优化">SAP算法的优化</h4><p>最短增广路算法还有两个重要且有效的优化。</p>
<h6 id="Gap优化">Gap优化</h6><p>注意到对残留网络中<code>dis[u]</code>值得修改只会让<code>dis[u]</code>的值越变越大，因此，对于每个节点，<code>dis</code>值是单调变化的。假如现在有<code>dis[u]=k+1</code>而没有一个点使得<code>dis[v]=k</code>，那么意味着出现了断层，也就是说无法再找到一条增广路径。</p>
<p>使用一个<code>gap</code>数组记录<code>dis</code>数组中每个值由多少个。一旦出现某个<code>gap[k]=0</code>，则算法结束。</p>
<h6 id="当前弧优化">当前弧优化</h6><p>由于<code>dis</code>数组的单调性，在查找允许弧时只需要从上一次找到的允许弧开始找即可。</p>
<p>最后，给出SAP最短增广路算法的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sap</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = pre[start] = start, maxflow = <span class="number">0</span>, aug = -<span class="number">1</span>;</span><br><span class="line">    gap[<span class="number">0</span>] = cnt;</span><br><span class="line">    <span class="keyword">while</span>(dis[start] &lt; cnt) &#123;</span><br><span class="line">        <span class="keyword">bool</span> find = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = cur[u]; v &lt;= cnt; ++v) &#123; <span class="comment">// 当前弧优化</span></span><br><span class="line">            <span class="keyword">if</span>(maze[u][v] &amp;&amp; dis[u] == dis[v]+<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(aug == -<span class="number">1</span> || aug &gt; maze[u][v]) &#123;</span><br><span class="line">                    aug = maze[u][v];</span><br><span class="line">                &#125;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">                u = cur[u] = v; <span class="comment">// 记录当前弧</span></span><br><span class="line">                <span class="keyword">if</span>(v == end) &#123;</span><br><span class="line">                    maxflow += aug;</span><br><span class="line">                    <span class="keyword">for</span>(u = pre[u]; v != start; v=u,u=pre[u]) &#123;</span><br><span class="line">                        maze[u][v] -= aug;</span><br><span class="line">                        maze[v][u] += aug;</span><br><span class="line">                    &#125;</span><br><span class="line">                    aug = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                find = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(find == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mindis = cnt-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= cnt; v++) &#123; <span class="comment">// 更新 dis</span></span><br><span class="line">                <span class="keyword">if</span>(maze[u][v] &amp;&amp; mindis &gt; dis[v]) &#123;</span><br><span class="line">                    cur[u] = v;</span><br><span class="line">                    mindis = dis[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((--gap[dis[u]])==<span class="number">0</span>) &#123; <span class="comment">// gap 优化</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            gap[dis[u]=mindis+<span class="number">1</span>]++;</span><br><span class="line"></span><br><span class="line">            u = pre[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="预流推进算法">预流推进算法</h2><h2 id="Dinic算法和层次图">Dinic算法和层次图</h2><h2 id="最小费用最大流">最小费用最大流</h2><p>关于费用流的求解，只需要把EK算法中寻找增广路的过程换成用SPFA求解最短路（权值）的过程即可。</p>
<h2 id="最大费用最大流">最大费用最大流</h2><p>将每条边的费用取相反数，再求解最小费用最大流，求得的费用的相反数为最大费用，求得的最大流量为最大流。</p>
<h2 id="网络流模型解决二分图匹配问题">网络流模型解决二分图匹配问题</h2><h3 id="最大流与最大二分图匹配">最大流与最大二分图匹配</h3><p>不难想到，通过限制每个点的流量不超过 1 即可以保证每个点最多只使用一次。实现时，增加一个源点和汇点。从源点到左边集合中每个点连边，从右边集合中每个点向汇点连边，容量都为1。这样，求得的从源点到汇点的最大流量便是原图的最大二分匹配。</p>
<h3 id="费用流与最优（最大权/最小权）二分图匹配">费用流与最优（最大权/最小权）二分图匹配</h3><p>原图中每条边的容量为1。增加一个源点和一个汇点，从源点向左边集合中每个点连边，容量为1，权值为0，从右边集合中每个点向汇点连边，容量为1，权值为0。然后，求解从源点到汇点的最大费用最大流即可得到最大权二分图匹配，求解最小费用最大流即可得到最小权二分图匹配。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/26/algorithm/max_flow/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/25/algorithm/gcd/">最大公约数算法</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-24T16:00:00.000Z">2015-02-25</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/25/algorithm/gcd/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>关于最大公约数的求解，主要有欧几里得算法和Stein算法两种方法。</p>
<h2 id="欧几里得算法">欧几里得算法</h2><p>欧几里得算法的原理为：</p>
<p>若</p>
<p>$$ a \equiv r(mod b) $$</p>
<p>则</p>
<p>$$ gcd(a,b) = gcd(b,r) $$</p>
<p>算法执行过程为辗转相除法。</p>
<p>算法实现也很简单：</p>
<p>递归形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 求解 a, b 两个数的最大公约数。</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 求解 a, b 两个数的最大公约数。</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧几里得算法的时间复杂度为O(lg(n))，最坏情形为斐波那契数列的相邻两项。空间复杂度为O(1)。</p>
<h2 id="Stein算法">Stein算法</h2><p>Stein算法是另一种求解两个数的最大公约数的算法。其原理为：</p>
<p>$$ gcd(ka, kb) = k \times gcd(a, b) $$</p>
<p>Stein算法的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Stein算法</span><br><span class="line"> *</span><br><span class="line"> * 条件：0 &lt;= b &lt; a.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&amp;<span class="number">0x01</span> == <span class="number">0</span> &amp;&amp; b&amp;<span class="number">0x01</span> == <span class="number">0</span>) &#123; <span class="comment">// a, b 都为偶数</span></span><br><span class="line">            a &gt;&gt; <span class="number">1</span>; b &gt;&gt; <span class="number">1</span>; r = r + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(a&amp;0x01 == 0 &amp;&amp; b&amp;0x01 == 1)</span> </span>&#123; <span class="comment">// a 偶，b 奇</span></span><br><span class="line">            a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">()</span> </span>&#123; <span class="comment">// a 奇，b 偶</span></span><br><span class="line">            b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">()</span> </span>&#123; <span class="comment">// a 奇，b 奇</span></span><br><span class="line">            a = (a-b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a &lt; b) &#123;</span><br><span class="line">            a ^= b; b ^= a; a ^= b; <span class="comment">// swap(a, b);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a&lt;&lt;r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与欧几里得算法相比，Stein 算法的优点在于不需要对大整数进行取模运算，只需要进行移位和减法运算。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/25/algorithm/gcd/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/24/algorithm/binary_index_trees/">树状数组</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-23T16:00:00.000Z">2015-02-24</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/24/algorithm/binary_index_trees/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>树状数组(Binary Index Tree, BIT)，是一个查询和修改复杂度都为O(lg(n))的数据结构。</p>
<h2 id="定义">定义</h2><p>对于序列<code>a</code>，我们设一个数组<code>C</code>定义<code>C[i] = a[i – 2^k + 1] + … + a[i]</code>(<strong>i从1开始</strong>)，<code>k</code>为<code>i</code>在二进制下末尾0的个数。 k的计算可以这样:</p>
<pre><code><span class="number">2</span>^k = x <span class="keyword">and</span> (x <span class="keyword">xor</span> (x-<span class="number">1</span>))
</code></pre><p>树状数组的结构如下图所示：</p>
<p><img src="/resource/algorithm/binary_index_trees/binary_index_trees_1.png" alt="树状数组"></p>
<p>在实现时，可以定义宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lowbit(x) ((x)&amp;((x)^((x)-1)))</span></span><br></pre></td></tr></table></figure>
<p>利用补码的特性，可以写为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br></pre></td></tr></table></figure>
<p>来方便求得K值。</p>
<h2 id="建立树状数组">建立树状数组</h2><p>可以将数组中所有元素都初始化为0，然后再逐个插入（修改）。</p>
<h2 id="修改单个位置的值">修改单个位置的值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 将k位置的值增加delta。</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> delta)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= n) &#123;</span><br><span class="line">        c[k] += delta;</span><br><span class="line">        k += lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询区间和">查询区间和</h2><p>首先，可以通过如下方法在O(log(n))的时间内得出前k个元素的和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 求区间[1, k]内元素的和</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _sum += c[k];</span><br><span class="line">        k -= lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间和查询便不难实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 求区间[x, y] 内元素的和。</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_range</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query_sum(y) - query_sum(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维情形">二维情形</h2><p>直接将一维的所有操作扩展到二维即可。</p>
<p>更新：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * (x, y)处的值增加delta</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> delta)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x &lt;= xn) &#123;</span><br><span class="line">        <span class="keyword">while</span>(y &lt;= yn) &#123;</span><br><span class="line">            c[x][y] += delta;</span><br><span class="line">            y += lowbit(y);</span><br><span class="line">        &#125;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询二维区间和操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 查询(0,0)与(x, y)范围内的和。</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _sum += c[x][y];</span><br><span class="line">            y -= lowbit(y);</span><br><span class="line">        &#125;</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 查询(x1, y1)与(x2, y2)范围内的和</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_range</span><span class="params">(x1, y1, x2, y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query_sum(x2, y2) + query_sum(x1-<span class="number">1</span>, y1-<span class="number">1</span>) -</span><br><span class="line">            query_sum(x1-<span class="number">1</span>, y2) - query_sum(x2, y1-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间修改单点查询">区间修改单点查询</h2><p>线段树也可以用于区间修改单点值查询的场合。</p>
<p>在这种模型中，数组<code>C</code>的含义有所不同。<code>c[i]</code>用来表示到目前为止<code>a[1...i]</code>共被整体加了多少。此时，<code>a[i]</code>的值为<code>c[i...n]</code>之和。</p>
<p>对区间[x, y]的修改可以变换为对区间[1, x]和区间[1, y]的修改。具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 将[1, x]位置的值增加delta。</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> delta)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c[k] += delta;</span><br><span class="line">        k -= lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将[x, y]区间的所有值增加delta</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chang</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        change(x-<span class="number">1</span>, -delta);</span><br><span class="line">    &#125;</span><br><span class="line">    change(y, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 求解原序列k处的值</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_value</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= n) &#123;</span><br><span class="line">        _value += c[i];</span><br><span class="line">        k += lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的区间修改单点查询的模型同样可以用于多维情形。</p>
<h2 id="区间修改区间查询">区间修改区间查询</h2><p>这种情形需要两个辅助数组。<code>c[i]</code>用来记录<code>a[1...n]</code>共被整体加了多少次，<code>d[i]</code>用来记录<code>a[1...n]</code>到目前为止共被整体加了多少的总和。也即<code>d[i]=a[i]*i</code>。</p>
<p>代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_c</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> delta)</span> </span>&#123; <span class="comment">// change c[].</span></span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c[k] += delta;</span><br><span class="line">        k -= lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_d</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> delta)</span> </span>&#123; <span class="comment">// change d[].</span></span><br><span class="line">    <span class="keyword">int</span> tmp = k;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= n) &#123;</span><br><span class="line">        d[k] += tmp * delta; <span class="comment">// 总和</span></span><br><span class="line">        k += lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_c</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= n) &#123;</span><br><span class="line">        _sum += c[k];</span><br><span class="line">        k += lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_d</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _sum += d[k];</span><br><span class="line">        k -= lowbit(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    change_c(y, delta); change_d(y, delta);</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        change_c(x-<span class="number">1</span>, -delta); change_d(x-<span class="number">1</span>, -delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum_c(k)*k + sum_d(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query_range</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query_sum(y)-query_sum(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="与线段树的对比">与线段树的对比</h2><h3 id="优势">优势</h3><p>相对于使用线段树进行区间和动态查询，树状数组有如下优势：</p>
<ol>
<li>空间复杂度降低；</li>
<li>编程复杂度降低；</li>
<li>无递归操作，栈空间占用小；</li>
<li>在时间复杂度上，相对于线段树常数要小一些。</li>
</ol>
<h3 id="局限">局限</h3><p>能用树状数组实现的，都能用线段树实现，反之并不成立。</p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://baike.baidu.com/view/1420784.htm" target="_blank" rel="external">树状数组，百度百科</a></li>
</ol>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/24/algorithm/binary_index_trees/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/20/programming language/haskell/dive_into_haskell_3_function/">Dive Into Haskell(3) 函数</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-19T16:00:00.000Z">2015-02-20</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/20/programming language/haskell/dive_into_haskell_3_function/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>在Haskell中，一切皆函数。</p>
<h2 id="定义一个函数">定义一个函数</h2><p>haskell中，可以通过如下方式定义一个简单的函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleMe</span> x = x + x</span><br></pre></td></tr></table></figure>
<p>这样的做法其实是实现了一个绑定(binding)。更广泛的函数定义的方法：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func1</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="comment">&#123;- function body. -&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">func2</span> :: <span class="type">Int</span>-&gt;<span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="comment">&#123;- function body. -&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">func3</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;- function body. -&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title">func4</span> :: (<span class="type">Integral</span> a) =&gt; a-&gt;a -&gt; <span class="type">String</span></span><br><span class="line"><span class="comment">&#123;- function body. -&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面四个例子中可以看出haskell定义函数的几种语法。前两种语法类似，函数名后面前几个类型都为参数类型，最后一个类型为返回值类型。后两种语法类似，使用了类型类来标识参数的类型，同样，最后一个类型为返回值类型，前几个为参数类型。</p>
<h2 id="函数的调用">函数的调用</h2><p>上面定义的几个函数，可以通过如下语法调用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleMe</span> <span class="number">1</span></span><br><span class="line"><span class="title">func1</span> <span class="number">1</span></span><br><span class="line"><span class="title">func2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="title">func3</span> <span class="number">1</span></span><br><span class="line"><span class="title">func4</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果函数有两个参数，那么可以通过中缀函数的方式调用，注意使用中缀函数语法是要在函数名左右两侧各加一个```符号。如下例：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> `func2` <span class="number">2</span></span><br><span class="line"><span class="number">1</span> `func4` <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Haskell的库函数中，可以用中缀函数语法调用的函数还有<code>div</code>, <code>mod</code>等。使用中缀函数的好处在于可以让参数之间的运算关系更加清楚。</p>
<h2 id="函数中的模式匹配">函数中的模式匹配</h2><p>定义函数时，可以为不同的模式分别定义函数体本身。函数匹配可以匹配一切数据类型。如下例：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">func</span> <span class="number">1</span> = <span class="string">"number 1"</span></span><br><span class="line"><span class="title">func</span> <span class="number">2</span> = <span class="string">"number 2"</span></span><br></pre></td></tr></table></figure>
<p>这样，当函数参数为<code>1</code>时，函数返回<code>&quot;number 1&quot;</code>，当函数参数为<code>2</code>时，函数返回<code>&quot;number 2&quot;</code>。如果参数与任何一个模式都不能匹配，那么程序将会出现运行时错误。错误内容为：</p>
<pre><code>Non-exhaustive patterns <span class="operator">in</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span></span>
</code></pre><p>因此，一种解决方法是在函数定义的最后加上一个默认的模式。例如，在上例函数的最后加入：</p>
<pre><code><span class="keyword">func</span> x: "number <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">in</span> all patterns."
</code></pre><p>这样，对于任何不再模式中的参数(既不等于1又不等于2的数)，参数值都将会被<code>x</code>捕获，执行模式<code>x</code>所对应的函数体。</p>
<p>注意：如果将模式<code>x</code>（默认模式）放在最前面，编译时将产生如下Warning:</p>
<pre><code>Pattern <span class="function"><span class="title">match</span><span class="params">(es)</span></span> are overlapped
</code></pre><p>函数运行时，无论参数是什么，都将运行对应于默认模式(<code>x</code>)对应的函数体。</p>
<p>又如下例定义阶乘函数的方法：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fact</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">fact</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fact</span> n = n * fact (n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>与其他编程语法相比，代码简洁明了。</p>
<h2 id="List与模式匹配">List与模式匹配</h2><p>对于List也可以使用<code>[]</code>或<code>:</code>进行模式匹配。例如<code>[1, 2, 3]</code>或<code>1:2:3:[]</code>将匹配元素为1、2、3的列表。</p>
<p>形如<code>x:xs</code>的模式将匹配长度大于等于<code>1</code>的List。并把List的头部绑定到<code>x</code>，其他部分绑定到<code>xs</code>。由此类推，<code>x:y:z:xs</code>将匹配元素个数大于等于<code>3</code>的List。</p>
<p>此外，<code>as</code>模式也常用语List的模式匹配中。例如：</p>
<pre><code><span class="keyword">func</span> <span class="built_in">all</span>@(x, xs)
</code></pre><p>语句中，<code>x</code>将匹配List的第一项，<code>xs</code>将匹配List的其他项，<strong><code>all</code>的函数是整个List</strong>。可以方便地通过<code>all</code>来操作参数的整个List。</p>
<h2 id="哨兵(Guards)">哨兵(Guards)</h2><p>Haskell中与函数有关的另一个重要概念是哨兵(Guards)。模式匹配可以用来匹配参数的值或结构，而哨兵则用来匹配和检验参数的性质（如大小、正负等）。</p>
<p>Guards的应用举例：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func1</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">func1</span> number</span><br><span class="line">    | number == <span class="number">0</span> = <span class="string">"number is equal to 0."</span></span><br><span class="line">    | number &gt; <span class="number">0</span>  = <span class="string">"number is a positive."</span></span><br><span class="line">    | number &lt; <span class="number">0</span>  = <span class="string">"number is a negative."</span></span><br><span class="line"></span><br><span class="line"><span class="title">func2</span> :: <span class="type">Int</span>-&gt;<span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">func2</span> a b</span><br><span class="line">    | a &gt; b  = <span class="string">"a ia greater than b."</span></span><br><span class="line">    | a == b = <span class="string">"a is equal to b."</span></span><br><span class="line">    | a &lt; b  = <span class="string">"a is less than b."</span></span><br></pre></td></tr></table></figure>
<p>一般而言，排在最后的哨兵是<code>otherwise</code>，它能捕获一切条件。如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func1</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">func1</span> number</span><br><span class="line">    | number == <span class="number">0</span> = <span class="string">"number is equal to 0."</span></span><br><span class="line">    | otherwise   = <span class="string">"number is not equal to 0."</span></span><br></pre></td></tr></table></figure>
<p>但需要注意，如果把<code>otherwise</code>放在第一个哨兵的位置，那么所有条件都会被<code>otherwise</code>捕获，只会执行<code>otherwise</code>对应的程序。</p>
<p><strong>注意</strong>:<code>|</code>符号前面至少要有一个空格的缩进，否则会有编译错误。</p>
<p>所有的哨兵也可以写在一行，但代码可读性不好，这一用法仅仅用于展示较短的函数。例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;- 返回两个可比较类型数据中的较大值。 -&#125;</span></span><br><span class="line"><span class="comment">&#123;- 注意，haskell中函数名中可以有"'"(单引号)。</span><br><span class="line"> - 此处这样用是为了与标准库中的 max 函数分开。</span><br><span class="line"> - -&#125;</span></span><br><span class="line"><span class="title">max'</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">max'</span> a b | a &gt; b = a | otherwise = b</span><br></pre></td></tr></table></figure>
<h2 id="where_关键字">where 关键字</h2><p><code>where</code>关键字用于在一个作用域中实现绑定。<code>where</code>关键字既可以绑定名字，也可以定义函数。<code>where</code>关键字定义的名字只对本函数可见，不会污染其他函数的命名空间。</p>
<p><code>where</code>关键字用在函数的底部，在函数的最后来定义绑定。</p>
<h2 id="let_关键字">let 关键字</h2><p><code>let</code>绑定与<code>where</code>绑定类似，<code>let</code>绑定是一个表达式，允许在任何位置定义函数的局部变量。并且对不同的Guard可见性不同。</p>
<p><code>let</code>定义局部绑定的用法为：</p>
<pre><code><span class="built_in">let</span> [bindings] <span class="keyword">in</span> [expressions]
</code></pre><p><code>let</code>定义的绑定仅仅对<code>in</code>部分可见。在函数中，可以直接用</p>
<pre><code>let <span class="keyword">...</span>
</code></pre><p>语句来定义局部变量和局部函数。</p>
<h2 id="case_语句">case 语句</h2><p>模式匹配也可以用<code>case</code>语句来实现，具体用法为：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result</span><br><span class="line">                   pattern -&gt; result</span><br><span class="line">                   ...</span><br></pre></td></tr></table></figure>
<p>函数参数的模式匹配只能在函数定义时使用，而<code>case</code>语句既可以用于函数定义时的参数匹配，也可以用在函数内部的表达式中。</p>
<h2 id="Haskell_中的递归(Recursive)">Haskell 中的递归(Recursive)</h2><p>使用递归函数求解的一个经典例子为求Fibonacci数列。Haskell中实现如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibonacci</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fibonacci</span> n</span><br><span class="line">    | n==<span class="number">0</span>      = <span class="number">0</span></span><br><span class="line">    | n==<span class="number">1</span>      = <span class="number">1</span></span><br><span class="line">    | otherwise = (fibonacci (n-<span class="number">1</span>))+(fibonacci (n-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>函数式编程的一个特点是将对列表的遍历实现为对子列表的递归。例如使用递归的方法来求一个List的最大值：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">max'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">max'</span> []            = (error <span class="string">"abcde"</span>)</span><br><span class="line"><span class="title">max'</span> [x]           = x</span><br><span class="line"><span class="title">max'</span> (x:xs)</span><br><span class="line">    | x &gt;= maxTail = x</span><br><span class="line">    | otherwise    = maxTail</span><br><span class="line">    <span class="keyword">where</span> maxTail  = max' xs</span><br></pre></td></tr></table></figure>
<p>用递归和函数式编程的思想实现快速排序算法：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">qsort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">qsort</span> []  = []</span><br><span class="line"><span class="title">qsort</span> (x:xs) = qsort(filter (&lt; x) xs) ++ [x] ++ qsort(filter (&gt;=x) xs)</span><br></pre></td></tr></table></figure>
<p>用其他一些具有函数式编程特性的语法来实现快速排序同样很方便，比如Python：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="keyword">if</span> a == []:</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"><span class="keyword">return</span> qsort(list(filter(<span class="keyword">lambda</span> e:e&lt;a[<span class="number">0</span>], a[<span class="number">1</span>:]))) \</span><br><span class="line">        + [a[<span class="number">0</span>]] \</span><br><span class="line">        + qsort(list(filter(<span class="keyword">lambda</span> e:e&gt;=a[<span class="number">0</span>], a[<span class="number">1</span>:])))</span><br></pre></td></tr></table></figure>
<p>由此不难看出列表推导(List Comprehension)和递归(Recursive)的威力。</p>
<p>在使用递归来求解问题的时候，一定要注意边界条件，例如上例中的List为空的情形。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/20/programming language/haskell/dive_into_haskell_3_function/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/18/programming language/javascript/variable_scope/">Javascript 变量作用域与闭包</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-17T16:00:00.000Z">2015-02-18</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/18/programming language/javascript/variable_scope/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="Javascript_中的变量">Javascript 中的变量</h2><p>Javascript 中的变量可分为全局变量和局部变量两种。</p>
<p>Javascript 中使用 <code>var</code> 语句声明变量。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> y = [<span class="string">"a"</span>, <span class="number">20</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>
<h2 id="变量相等性比较">变量相等性比较</h2><p>Javascript 中，比较两个变量是否想等是，必须注意 <code>==</code>和<code>===</code> 之间的区别。</p>
<p><code>==</code>只比较变量的值，而 <code>===</code>既比较变量的值，又比较变量的类型。如下例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>);</span><br></pre></td></tr></table></figure>
<p>得到的输出如下：</p>
<pre><code><span class="literal">true</span>
<span class="literal">false</span>
</code></pre><h2 id="变量生命期">变量生命期</h2><p>Javascript 中的变量在声明时初始化。</p>
<ul>
<li>局部变量在函数执行完毕后销毁。</li>
<li>全局变量在页面关闭后销毁。</li>
</ul>
<h2 id="函数参数变量">函数参数变量</h2><p>函数的参数只在函数内起作用，是局部变量。</p>
<h2 id="变量作用域">变量作用域</h2><h3 id="全局变量与局部变量">全局变量与局部变量</h3><p>函数内部可以访问全局变量，但在函数外部无法访问函数的局部变量。</p>
<p>局部变量会在局部作用域中覆盖全局变量。</p>
<p>Javascript 中，<code>function</code>中内容相对于外部的内容形成新的作用域(scope)。</p>
<p>在同一作用域中，同名变量可以重复声明。重复声明的作用相当于赋值操作。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>运行后得到：</p>
<pre><code>10
20
20
</code></pre><p>Javascript 中，如果不用<code>var</code>声明变量，则该变量为全局变量。如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">    n=<span class="number">200</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>得到输出：</p>
<pre><code>100
200
</code></pre><p>在函数体内部，对于每一个变量，Javascript 会首先在函数体内寻找是否用<code>var</code>语句声明了局部变量，如果有（<strong>无论是在该变量使用前声明还是使用后声明</strong>），都会认为该变量是局部变量。如果找不到，在逐层向外寻找该变量(一级一级地向上寻找父对象的变量)。例如下面两段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n); </span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>得到输出：</p>
<pre><code>100
</code></pre><p>而代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n); </span><br><span class="line">    <span class="keyword">return</span> n; </span><br><span class="line">    <span class="keyword">var</span> n;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 var 语句在 return 语句之后！！！</span></span><br></pre></td></tr></table></figure>
<p>运行后得到如下输出：</p>
<pre><code><span class="literal">undefined</span>
</code></pre><p>如果写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="number">200</span>; </span><br><span class="line">    <span class="built_in">console</span>.log(n); </span><br><span class="line">    <span class="keyword">return</span> n; </span><br><span class="line">    <span class="keyword">var</span> n;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(n);</span><br></pre></td></tr></table></figure>
<p>得到输出：</p>
<pre><code>200
100
</code></pre><p>这便是 Javascript 的作用域的运行机制。</p>
<h2 id="从外部读取局部变量">从外部读取局部变量</h2><p>我们知道，在Javascript中，无法直接从外部读取局部变量，但是，Javascript函数(Function对象)的子函数(子对象)是可以读取函数的局部变量的。因此，通过如下方法可以从外部读取和操作局部变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> innerVar = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setInner</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">        innerVar = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> setInner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包">闭包</h2><p>当内部函数在定义它的作用域外部被引用时，就会创建该内部函数的闭包。如果内部函数引用了位于外部函数的变量，当外部函数调用完毕后，这些闭包中的变量不会被释放，会保持在内存中。</p>
<p>闭包对应函数示例，当函数示例销毁时才会销毁闭包，并释放其占用的内存。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/18/programming language/javascript/variable_scope/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/17/linux/linux_compression_cmd/">Linux 文件解压及压缩命令</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-16T16:00:00.000Z">2015-02-17</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/17/linux/linux_compression_cmd/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>Linux下，通常需要用tar命令进行解压和压缩操作，针对不同的压缩文件格式，tar命令的参数也不相同。</p>
<h2 id="tar_命令的常用参数含义:">tar 命令的常用参数含义:</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Main operation mode:</span><br><span class="line"></span><br><span class="line"> -A, --catenate, --concatenate   <span class="keyword">append</span> tar files to <span class="keyword">an</span> archive</span><br><span class="line"> -c, --create               create a new archive</span><br><span class="line"> -<span class="keyword">d</span>, --diff, --<span class="keyword">compare</span>      find differences between archive and <span class="keyword">file</span> system</span><br><span class="line">     --delete               delete from the archive (not <span class="keyword">on</span> mag tapes!)</span><br><span class="line"> -r, --<span class="keyword">append</span>               <span class="keyword">append</span> files to the end of <span class="keyword">an</span> archive</span><br><span class="line"> -t, --<span class="keyword">list</span>                 <span class="keyword">list</span> the contents of <span class="keyword">an</span> archive</span><br><span class="line">     --<span class="keyword">test</span>-<span class="keyword">label</span>           <span class="keyword">test</span> the archive volume <span class="keyword">label</span> and <span class="keyword">exit</span></span><br><span class="line"> -<span class="keyword">u</span>, --<span class="keyword">update</span>               only <span class="keyword">append</span> files newer than <span class="keyword">copy</span> <span class="keyword">in</span> archive</span><br><span class="line"> -x, --extract, --get       extract files from <span class="keyword">an</span> archive</span><br></pre></td></tr></table></figure>
<h2 id="常见压缩文件格式解压参数">常见压缩文件格式解压参数</h2><ol>
<li><p>.tar.Z 格式</p>
<pre><code>解压: tar Zxvf FileName<span class="class">.tar</span><span class="class">.Z</span>
压缩: tar Zcvf FileName<span class="class">.tar</span><span class="class">.Z</span>
</code></pre></li>
<li><p>.zip 格式</p>
<pre><code>压缩: unzip FileName.<span class="keyword">zip</span>
解压: <span class="keyword">zip</span> 
</code></pre></li>
<li><p>.gz 格式</p>
<pre><code>解压：gunzip FileName<span class="class">.gz</span>
  或：gzip -d FileName<span class="class">.gz</span>
压缩：gzip FileName
</code></pre></li>
<li><p>.tar.gz 格式</p>
<pre><code>解压：tar zxvf FileName<span class="class">.tar</span><span class="class">.gz</span>
压缩：tar zcvf FileName<span class="class">.tar</span><span class="class">.gz</span> DirName
</code></pre></li>
<li><p>.bz2 格式</p>
<pre><code>解压：bzip2 -d FileName<span class="class">.bz2</span>
  或：bunzip2 FileName<span class="class">.bz2</span>
压缩：bzip2 -z FileName
</code></pre></li>
<li><p>.tar.bz2 格式</p>
<pre><code>解压：tar jxvf FileName<span class="class">.tar</span><span class="class">.bz2</span>
压缩：tar jcvf FileName<span class="class">.tar</span><span class="class">.bz2</span> DirName
</code></pre></li>
<li><p>.bz 格式</p>
<pre><code>解压：bzip2 -d <span class="keyword">FileName</span>.bz
  或：bunzip2 <span class="keyword">FileName</span>.bz
</code></pre></li>
<li><p>.tar.bz 格式</p>
<pre><code>解压：tar jxvf FileName<span class="class">.tar</span><span class="class">.bz</span>
</code></pre></li>
<li><p>.Z 格式</p>
<pre><code>解压：uncompress <span class="keyword">FileName</span>.Z
压缩：compress <span class="keyword">FileName</span>
</code></pre></li>
<li><p>.tgz 格式</p>
<pre><code>解压：tar zxvf <span class="keyword">FileName</span>.tgz
</code></pre></li>
<li><p>.tar.tgz 格式</p>
<pre><code>解压：tar zxvf FileName<span class="class">.tar</span><span class="class">.tgz</span>
压缩：tar zcvf FileName<span class="class">.tar</span><span class="class">.tgz</span> FileName
</code></pre></li>
<li><p>.zip 格式</p>
<pre><code>解压：unzip FileName<span class="class">.zip</span>
压缩：zip FileName<span class="class">.zip</span> DirName
</code></pre></li>
<li><p>.rar 格式</p>
<pre><code>解压：rar e FileDir
压缩：rar <span class="tag">a</span> FileName<span class="class">.rar</span> 
</code></pre></li>
<li><p>.tar.lz 格式</p>
<pre><code>解压：tar xvf filename<span class="class">.tar</span><span class="class">.lz</span>
</code></pre></li>
<li><p>.tar.xz 格式</p>
<pre><code>解压：xz -d filename<span class="class">.tar</span><span class="class">.xz</span>
压缩：xz -Z FileDir
</code></pre></li>
<li><p>.lzma格式</p>
<pre><code>解压：lzma -d filename<span class="class">.lzma</span>
压缩: lzma -k FileDir
</code></pre></li>
</ol>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/17/linux/linux_compression_cmd/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/17/algorithm/kmp/">KMP算法</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-16T16:00:00.000Z">2015-02-17</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/17/algorithm/kmp/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="一、概述">一、概述</h2><p>KMP算法(Knuth–Morris–Pratt algorithm)是一种快速模式串匹配算法，其核心是next数组的求解和使用。时间复杂度O(mn)，与BF等需要回溯的算法相比，KMP算法具有极高的性能。</p>
<h2 id="二、next数组的求解">二、next数组的求解 </h2><p>next数组的含义是：<code>next[i]</code>为i之前的字符串的前缀和后缀的共有元素的最长长度。具体计算可以有递推式产生。若<code>pattern[i] == pattern[j]</code>,则<code>pattern[i+1] = pattern[j+1]</code>,否则，依次使<code>j = next[j]</code>,向前寻找匹配位置。具体实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> next[], <span class="keyword">char</span> pattern[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pattern[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || pattern[i] == pattern[j]) &#123;</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以做一个小优化，提高匹配效率：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> next[], <span class="keyword">char</span> pattern[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pattern[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || pattern[i] == pattern[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="comment">// 再次判断i位置和j位置的字符的相等关系</span></span><br><span class="line">            <span class="keyword">if</span> (pattern[i] == pattern[j]) &#123;</span><br><span class="line">                next[i] = next[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、匹配">三、匹配 </h2><p>在匹配过程中，就可以充分利用next数组，在很次失配时尽可能向前移动，提高匹配段的效率，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return the first position of pattern appears in src string.</span><br><span class="line"> * if the pattern doesn't appear, return -1.</span><br><span class="line"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> src[], <span class="keyword">char</span> pattern[], <span class="keyword">int</span> next[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i] != <span class="string">'\0'</span> &amp;&amp; pattern[j] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * j == -1: 源字符串中当前字符失配。</span><br><span class="line">         * src[i] == pattern[j]: 当前位置匹配，两个指针都要后移。</span><br><span class="line">         **/</span></span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || src[i] == pattern[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j]; <span class="comment">// when match failed, jump to next[j].</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[j] == <span class="string">'\0'</span>) &#123; <span class="comment">// get to the end of pattern string.</span></span><br><span class="line">        <span class="keyword">return</span> i - <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// failed.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、KMP算法寻找pattern在src中出现的次数">四、KMP算法寻找pattern在src中出现的次数 </h2><p>寻找模式串出现次数，只需要在原来的寻找出现位置的基础上稍作修改即可，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return the times of pattern appears in src string.</span><br><span class="line"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> src[], <span class="keyword">char</span> pattern[], <span class="keyword">int</span> next[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span> || src[i] == pattern[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j]; <span class="comment">// when match failed, jump to next[j].</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == <span class="string">'\0'</span>) &#123; <span class="comment">// get to the end of pattern string.</span></span><br><span class="line">            ans++;</span><br><span class="line">            j = next[j];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种实现方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return the times of pattern appears in src string.</span><br><span class="line"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> src[], <span class="keyword">char</span> pattern[], <span class="keyword">int</span> next[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; src[i] != <span class="string">'\0'</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; src[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (src[j] == pattern[i]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[j] == <span class="string">'\0'</span>) &#123; <span class="comment">// get to the end of pattern.</span></span><br><span class="line">            ans++;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、关于字符串匹配">五、关于字符串匹配</h2><p>某种意义上讲，AC自动机算法相当于是Trie上进行的KMP，其失败指针的含义类似于KMP算法中的next数组。</p>
<p>此外，若只需要判断多个模式串在源字符串中是否存在，则Trie图算法相当于路径压缩的AC自动机。或者说，AC自动机和Trie图分别为字符串匹配的有限状态自动机DFA的不同表达形式。</p>
<h2 id="六、扩展KMP">六、扩展KMP</h2><h3 id="扩展KMP问题定义：">扩展KMP问题定义：</h3><p>给定字母串 S，T，定义 n = |S|, m = |T|, extend[i]=S[i..n] 与 T 的最长公共前缀长度。</p>
<p>要求在线性时间内求出所有的 extend[1..n] 。</p>
<h3 id="分析">分析</h3><p>扩展KMP算法的核心在于如何利用已经求出的前缀长度来减少比较次数。用 next[i] 来表示 T[i..m] 与 T 的最长公共前缀长度。不难建立起 next 数组与 extend 数组之间的关系。</p>
<p>不难发现：计算 next 数组的过程实际上也是一个以 T 为母串、T 为字串的扩展 KMP 算法过程。</p>
<h3 id="实现">实现</h3><p>刘雅琼的PPT中给出了一个扩展KMP的实现。代码如下所示（有改动）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Extend KMP algorithm.</span><br><span class="line"> * This implemention is modified from the code in Liu YaQiong's slides.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extendKmpLYQ</span><span class="params">(<span class="keyword">char</span> pattern[], <span class="keyword">char</span> str[], <span class="keyword">int</span> next[], <span class="keyword">int</span> extend[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(0)</span>, <span class="title">p</span><span class="params">(0)</span>, <span class="title">pLen</span><span class="params">(<span class="built_in">strlen</span>(pattern)</span>), <span class="title">sLen</span><span class="params">(<span class="built_in">strlen</span>(str)</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = -<span class="number">1</span>; i &lt; sLen; ++i, --j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span> || i + next[i-a] &gt;= p) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                j = <span class="number">0</span>, p = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(p &lt; sLen &amp;&amp; j &lt; pLen &amp;&amp; str[p] == pattern[j]) &#123;</span><br><span class="line">                ++p, ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            extend[i] = j, a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            extend[i] = next[i-a];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该算法时，只需要先将 T 即作为母串又作为字串求出 next 数组，在求 extend 数组的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> next[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;, extend[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> S[<span class="number">1000</span>] = &#123;<span class="string">'\0'</span>&#125;, T[<span class="number">1000</span>] = &#123;<span class="string">'\0'</span>&#125;;</span><br><span class="line"></span><br><span class="line">extendKmpLYQ(T, T, next, next);</span><br><span class="line">extendKmpLYQ(T, S, next, extend);</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3><ol>
<li><a href="http://wenku.baidu.com/view/8e9ebefb0242a8956bece4b3.html" target="_blank" rel="external">扩展KMP算法，刘雅琼</a></li>
</ol>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/17/algorithm/kmp/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2015/02/17/algorithm/string_distance/">字符串的编辑距离</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2015-02-16T16:00:00.000Z">2015-02-17</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">DHDave</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              
                <a href="/2015/02/17/algorithm/string_distance/#disqus_thread">Comments</a>

              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="问题描述">问题描述</h2><p>对于存在差异的字符串，我们可以通过如下三种方式使它们变得相同：</p>
<ol>
<li>修改一个字符；</li>
<li>增加一个字符；</li>
<li>删除一个字符。</li>
</ol>
<p>能够通过如上三种变换使得两个字符串相同的最小操作数记为两个字符串的编辑距离。</p>
<p>两个字符串的相似度定义为 <strong>编辑距离+1</strong> 的倒数。</p>
<h2 id="分析">分析</h2><p>与最长公共子序列问题类似，可以通过动态规划(Dynamic Programming)的方法来解决这一问题。</p>
<p>状态转移方程如下：</p>
<pre><code>dis[<span class="link_label">i</span>][<span class="link_reference">j</span>] = dis[<span class="link_label">i-1</span>][<span class="link_reference">j-1</span>]; A[i]==B[j]

dis[<span class="link_label">i</span>][<span class="link_reference">j</span>] = min(dis[<span class="link_label">i-1</span>][<span class="link_reference">j-1</span>]+1, dis[<span class="link_label">i</span>][<span class="link_reference">j-1</span>]+1, dis[<span class="link_label">i-1</span>][<span class="link_reference">j</span>]+1); A[i]!=B[j]
</code></pre><p>最终<code>dis[Alen][Blen]</code>的值即为所求的编辑距离。</p>
<h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * 注意：为方便DP，字符串从索引为 1 的位置开始。</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">char</span> A[], <span class="keyword">char</span> B[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Alen</span><span class="params">(<span class="built_in">strlen</span>(A+1)</span>), <span class="title">Blen</span><span class="params">(<span class="built_in">strlen</span>(B+1)</span>)</span>;</span><br><span class="line">    <span class="keyword">int</span> dis[Alen+<span class="number">5</span>][Blen+<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis[<span class="number">0</span>][<span class="number">0</span>])*(Alen+<span class="number">5</span>)*(Blen+<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Alen; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Blen; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == B[j]) &#123;</span><br><span class="line">                dis[i][j] = dis[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dis[i][j] = min(dis[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>,</span><br><span class="line">                        min(dis[i][j-<span class="number">1</span>], dis[i-<span class="number">1</span>][j])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[Alen][Blen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2015/02/17/algorithm/string_distance/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright"><div class="padding">
	
	  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:dhdave.github.io">
  </form>
</div>
	
	  
<div class="widget recent-post">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2015/03/17/algorithm/backpack/">背包问题总结</a>
      </li>
    
      <li>
        <a href="/2015/02/28/programming language/haskell/dive_into_haskell_4_higher_order_function/">Dive Into Haskell(4) 高阶函数</a>
      </li>
    
      <li>
        <a href="/2015/02/26/algorithm/max_flow/">最大流算法</a>
      </li>
    
      <li>
        <a href="/2015/02/25/algorithm/gcd/">最大公约数算法</a>
      </li>
    
      <li>
        <a href="/2015/02/24/algorithm/binary_index_trees/">树状数组</a>
      </li>
    
  </ul>
</div>

	
	  
<div class="widget category">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Algorithm/">Algorithm</a><small>17</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>2</small></li>
  
    <li><a href="/categories/Math/">Math</a><small>4</small></li>
  
    <li><a href="/categories/Runtime/">Runtime</a><small>1</small></li>
  
    <li><a href="/categories/编程语言/">编程语言</a><small>14</small></li>
  
  </ul>
</div>

	
	  
<div class="widget tag">
  <h3 class="title">标签</h3>
  
    <a href="/tags/Algorithm/">Algorithm<small>17</small></a>
  
    <a href="/tags/C-C/">C/C++<small>4</small></a>
  
    <a href="/tags/CodeStyle/">CodeStyle<small>1</small></a>
  
    <a href="/tags/Cygwin/">Cygwin<small>1</small></a>
  
    <a href="/tags/Haskell/">Haskell<small>4</small></a>
  
    <a href="/tags/JNI/">JNI<small>1</small></a>
  
    <a href="/tags/JVM/">JVM<small>1</small></a>
  
    <a href="/tags/Javascript/">Javascript<small>1</small></a>
  
    <a href="/tags/Linux/">Linux<small>1</small></a>
  
    <a href="/tags/Mathematica/">Mathematica<small>4</small></a>
  
    <a href="/tags/Python/">Python<small>5</small></a>
  
</div>

	
</div></aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="padding">
	<div class="alignleft">
	  
	  &copy; 2015 DHDave
	  
	  Powerd by <a href="http://hexo.io/" target="_blank">hexo</a>
	  and Theme by <a href="https://github.com/halfer53/metro-light" target="_blank">metro-light</a>
	</div>

	<div class="alignright">
		
			<a href="https://plus.google.com/u/0/112661429129878562674/posts" target="_blank" title="DHDave Google Plus"><i class="fa fa-google-plus-square"></i></a>
		
		
			<a href="https://github.com/DHDave" target="_blank" title="DHDave Github"><i class="fa fa-github-square"></i></a>	
		
		
		
		
		
		
	</div>

	<div class="clearfix"></div>
</div>

<div class="scroll-top"><i class="fa fa-arrow-circle-up"></i></div>
</footer>
  

		<script type="text/javascript">
		var disqus_shortname = 'dhdavegithubiodhdave-github-io';

		        (function() {
		            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		        })();
		</script>

		<script type="text/javascript">
		var disqus_shortname = 'dhdavegithubiodhdave-github-io'; 

		(function () {
		var s = document.createElement('script'); s.async = true;
		s.type = 'text/javascript';
		s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
		(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
		}());
		</script>

  


<script src="//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/3.0.4/jquery.imagesloaded.js"></script>
<script src="/js/gallery.js"></script>



<script type="text/javascript">
$(window).scroll(function() {

    if($(this).scrollTop() > 400) {
        $('.scroll-top').fadeIn(200);
    } else {
        $('.scroll-top').fadeOut(200);
    }
});

$('.scroll-top').bind('click', function(e) {
    e.preventDefault();
    $('body,html').animate({scrollTop:0},200);
});
</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
